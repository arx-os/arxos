class ThrottledUpdateManager{constructor(options={}){this.targetFPS=options.targetFPS||60;this.frameInterval=1000/this.targetFPS;this.maxBatchSize=options.maxBatchSize||100;this.batchTimeout=options.batchTimeout||16;this.isRunning=false;this.lastFrameTime=0;this.pendingUpdates=new Map();this.updateQueue=[];this.animationFrameId=null;this.frameCount=0;this.lastFPSUpdate=0;this.currentFPS=0;this.frameTimes=[];this.maxFrameTimeHistory=60;this.devicePerformance=this.detectDevicePerformance();this.adaptiveThrottling=options.adaptiveThrottling!==false;this.eventHandlers=new Map();this.updateTypes={'viewport':{priority:1,throttle:16},'zoom':{priority:1,throttle:16},'pan':{priority:1,throttle:16},'culling':{priority:2,throttle:50},'symbols':{priority:3,throttle:100},'ui':{priority:4,throttle:200},'batch':{priority:0,throttle:0}};this.initialize();}
initialize(){if(window.arxLogger){window.arxLogger.info('ThrottledUpdateManager initialized',{component:'throttled_update_manager',device_performance:this.devicePerformance,target_fps:this.targetFPS});}
this.adaptToDevicePerformance();this.start();}
detectDevicePerformance(){const performance=window.performance;const memory=performance.memory;const hardwareConcurrency=navigator.hardwareConcurrency||1;const refreshRate=this.detectRefreshRate();const canvas=document.createElement('canvas');const gl=canvas.getContext('webgl')||canvas.getContext('experimental-webgl');const hasHardwareAcceleration=gl&&gl.getExtension('WEBGL_debug_renderer_info');let score=0;if(hardwareConcurrency>=8)score+=3;else if(hardwareConcurrency>=4)score+=2;else if(hardwareConcurrency>=2)score+=1;if(memory){const totalMemory=memory.totalJSHeapSizeLimit;if(totalMemory>=2147483648)score+=3;else if(totalMemory>=1073741824)score+=2;else if(totalMemory>=536870912)score+=1;}
if(refreshRate>=120)score+=2;else if(refreshRate>=60)score+=1;if(hasHardwareAcceleration)score+=1;if(score>=8)return'high';else if(score>=5)return'medium';else return'low';}
detectRefreshRate(){let lastTime=performance.now();let frameCount=0;let refreshRate=60;const detectFrame=(currentTime)=>{frameCount++;if(frameCount>=60){const elapsed=currentTime-lastTime;refreshRate=Math.round((frameCount/elapsed)*1000);return;}
requestAnimationFrame(detectFrame);};requestAnimationFrame(detectFrame);return refreshRate||60;}
adaptToDevicePerformance(){if(!this.adaptiveThrottling)return;switch(this.devicePerformance){case'high':this.targetFPS=120;this.frameInterval=1000/this.targetFPS;this.maxBatchSize=200;this.batchTimeout=8;break;case'medium':this.targetFPS=60;this.frameInterval=1000/this.targetFPS;this.maxBatchSize=100;this.batchTimeout=16;break;case'low':this.targetFPS=30;this.frameInterval=1000/this.targetFPS;this.maxBatchSize=50;this.batchTimeout=32;break;}
if(window.arxLogger){window.arxLogger.info('Adapted settings for device performance',{component:'throttled_update_manager',device_performance:this.devicePerformance,target_fps:this.targetFPS,max_batch_size:this.maxBatchSize,batch_timeout_ms:this.batchTimeout});}}
start(){if(this.isRunning)return;this.isRunning=true;this.lastFrameTime=performance.now();this.animationFrameId=requestAnimationFrame(this.updateLoop.bind(this));if(window.arxLogger){window.arxLogger.info('ThrottledUpdateManager: Update loop started',{component:'throttled_update_manager',status:'started'});}}
stop(){if(!this.isRunning)return;this.isRunning=false;if(this.animationFrameId){cancelAnimationFrame(this.animationFrameId);this.animationFrameId=null;}
if(window.arxLogger){window.arxLogger.info('ThrottledUpdateManager: Update loop stopped',{component:'throttled_update_manager',status:'stopped'});}}
updateLoop(currentTime){if(!this.isRunning)return;const frameTime=currentTime-this.lastFrameTime;this.lastFrameTime=currentTime;this.frameTimes.push(frameTime);if(this.frameTimes.length>this.maxFrameTimeHistory){this.frameTimes.shift();}
this.frameCount++;if(currentTime-this.lastFPSUpdate>=1000){this.currentFPS=this.frameCount;this.frameCount=0;this.lastFPSUpdate=currentTime;}
if(frameTime>=this.frameInterval){this.processUpdates(currentTime);}
this.animationFrameId=requestAnimationFrame(this.updateLoop.bind(this));}
processUpdates(currentTime){const sortedUpdates=Array.from(this.pendingUpdates.entries()).sort((a,b)=>{const typeA=a[0];const typeB=b[0];const priorityA=this.updateTypes[typeA]?.priority||5;const priorityB=this.updateTypes[typeB]?.priority||5;return priorityA-priorityB;});let processedCount=0;const processedTypes=new Set();for(const[updateType,updateData]of sortedUpdates){if(processedCount>=this.maxBatchSize)break;const updateConfig=this.updateTypes[updateType];if(!updateConfig)continue;const lastUpdate=updateData.lastUpdate||0;if(currentTime-lastUpdate<updateConfig.throttle)continue;this.executeUpdate(updateType,updateData);processedTypes.add(updateType);processedCount++;updateData.lastUpdate=currentTime;}
for(const updateType of processedTypes){this.pendingUpdates.delete(updateType);}
this.processBatchedUpdates();this.triggerEvent('updateProcessed',{processedCount,currentFPS:this.currentFPS,frameTime:this.frameTimes[this.frameTimes.length-1]||0,pendingUpdates:this.pendingUpdates.size});}
queueUpdate(updateType,updateData={},options={}){if(!this.updateTypes[updateType]){console.warn(`ThrottledUpdateManager: Unknown update type: ${updateType}`);return;}
const{priority=this.updateTypes[updateType].priority,immediate=false,batch=false}=options;if(immediate){this.executeUpdate(updateType,updateData);return;}
if(batch){this.queueBatchedUpdate(updateType,updateData);return;}
this.pendingUpdates.set(updateType,{...updateData,priority,timestamp:performance.now()});}
queueBatchedUpdate(updateType,updateData){this.updateQueue.push({type:updateType,data:updateData,timestamp:performance.now()});setTimeout(()=>{this.processBatchedUpdates();},this.batchTimeout);}
processBatchedUpdates(){if(this.updateQueue.length===0)return;const groupedUpdates=new Map();for(const update of this.updateQueue){if(!groupedUpdates.has(update.type)){groupedUpdates.set(update.type,[]);}
groupedUpdates.get(update.type).push(update);}
for(const[updateType,updates]of groupedUpdates){if(updates.length===1){this.executeUpdate(updateType,updates[0].data);}else{this.executeBatchedUpdate(updateType,updates);}}
this.updateQueue=[];}
executeUpdate(updateType,updateData){try{this.triggerEvent('update',{type:updateType,data:updateData,timestamp:performance.now()});this.triggerEvent(`${updateType}Update`,updateData);}catch(error){console.error(`ThrottledUpdateManager: Error executing ${updateType} update:`,error);}}
executeBatchedUpdate(updateType,updates){try{const batchedData={updates:updates.map(u=>u.data),count:updates.length,timestamp:performance.now()};this.triggerEvent('batchedUpdate',{type:updateType,data:batchedData});this.triggerEvent(`${updateType}BatchedUpdate`,batchedData);}catch(error){console.error(`ThrottledUpdateManager: Error executing batched ${updateType} update:`,error);}}
throttle(func,delay){let lastCall=0;return function(...args){const now=performance.now();if(now-lastCall>=delay){lastCall=now;return func.apply(this,args);}};}
debounce(func,delay){let timeoutId;return function(...args){clearTimeout(timeoutId);timeoutId=setTimeout(()=>{func.apply(this,args);},delay);};}
getPerformanceMetrics(){const avgFrameTime=this.frameTimes.length>0?this.frameTimes.reduce((a,b)=>a+b,0)/this.frameTimes.length:0;return{currentFPS:this.currentFPS,targetFPS:this.targetFPS,averageFrameTime:avgFrameTime,devicePerformance:this.devicePerformance,pendingUpdates:this.pendingUpdates.size,queuedUpdates:this.updateQueue.length,frameTimeHistory:[...this.frameTimes]};}
setUpdateTypeConfig(updateType,config){this.updateTypes[updateType]={...this.updateTypes[updateType],...config};}
addEventListener(event,handler){if(!this.eventHandlers.has(event)){this.eventHandlers.set(event,[]);}
this.eventHandlers.get(event).push(handler);}
removeEventListener(event,handler){if(this.eventHandlers.has(event)){const handlers=this.eventHandlers.get(event);const index=handlers.indexOf(handler);if(index>-1){handlers.splice(index,1);}}}
triggerEvent(event,data={}){if(this.eventHandlers.has(event)){this.eventHandlers.get(event).forEach(handler=>{try{handler(data);}catch(error){console.error(`Error in throttled update event handler for ${event}:`,error);}});}}
clearPendingUpdates(){this.pendingUpdates.clear();this.updateQueue=[];}
forceProcessUpdates(){const currentTime=performance.now();this.processUpdates(currentTime);}
destroy(){this.stop();this.clearPendingUpdates();this.eventHandlers.clear();if(window.arxLogger){window.arxLogger.info('ThrottledUpdateManager: Destroyed',{component:'throttled_update_manager',status:'destroyed'});}}}
if(typeof module!=='undefined'&&module.exports){module.exports=ThrottledUpdateManager;}else if(typeof window!=='undefined'){window.ThrottledUpdateManager=ThrottledUpdateManager;}
