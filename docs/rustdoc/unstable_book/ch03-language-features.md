# Language features
## aarch64_unstable_target_feature

The tracking issue for this feature is: #44839

## aarch64_ver_target_feature

The tracking issue for this feature is: #44839

## abi_avr_interrupt

Allows extern "avr-interrupt" fn() and extern "avr-non-blocking-interrupt" fn().

The tracking issue for this feature is: #69664

## abi_cmse_nonsecure_call

The tracking issue for this feature is: #81391

The TrustZone-M feature is available for targets with the Armv8-M architecture profile (thumbv8m in their target name). LLVM, the Rust compiler and the linker are providing support for the TrustZone-M feature.

One of the things provided with this unstable feature is the "cmse-nonsecure-call" function ABI. This ABI is used on function pointers to non-secure code to mark a non-secure function call (see section 5.5 for details).

With this ABI, the compiler will do the following to perform the call:

save registers needed after the call to Secure memory
clear all registers that might contain confidential information
clear the Least Significant Bit of the function address
branches using the BLXNS instruction
To avoid using the non-secure stack, the compiler will constrain the number and type of parameters/return value.

#![no_std]
#![feature(abi_cmse_nonsecure_call)]

#[no_mangle]
pub fn call_nonsecure_function(addr: usize) -> u32 {
    let non_secure_function =
        unsafe { core::mem::transmute::<usize, extern "cmse-nonsecure-call" fn() -> u32>(addr) };
    non_secure_function()
}
$ rustc --emit asm --crate-type lib --target thumbv8m.main-none-eabi function.rs

call_nonsecure_function:
        .fnstart
        .save   {r7, lr}
        push    {r7, lr}
        .setfp  r7, sp
        mov     r7, sp
        .pad    #16
        sub     sp, #16
        str     r0, [sp, #12]
        ldr     r0, [sp, #12]
        str     r0, [sp, #8]
        b       .LBB0_1
.LBB0_1:
        ldr     r0, [sp, #8]
        push.w  {r4, r5, r6, r7, r8, r9, r10, r11}
        bic     r0, r0, #1
        mov     r1, r0
        mov     r2, r0
        mov     r3, r0
        mov     r4, r0
        mov     r5, r0
        mov     r6, r0
        mov     r7, r0
        mov     r8, r0
        mov     r9, r0
        mov     r10, r0
        mov     r11, r0
        mov     r12, r0
        msr     apsr_nzcvq, r0
        blxns   r0
        pop.w   {r4, r5, r6, r7, r8, r9, r10, r11}
        str     r0, [sp, #4]
        b       .LBB0_2
.LBB0_2:
        ldr     r0, [sp, #4]
        add     sp, #16
        pop     {r7, pc}
## abi_custom

Allows extern "custom" fn().

The tracking issue for this feature is: #140829

## abi_gpu_kernel

Allows extern "gpu-kernel" fn().

The tracking issue for this feature is: #135467

## abi_msp430_interrupt

The tracking issue for this feature is: #38487

In the MSP430 architecture, interrupt handlers have a special calling convention. You can use the "msp430-interrupt" ABI to make the compiler apply the right calling convention to the interrupt handlers you define.

#![feature(abi_msp430_interrupt)]
#![no_std]

// Place the interrupt handler at the appropriate memory address
// (Alternatively, you can use `#[used]` and remove `pub` and `#[no_mangle]`)
#[link_section = "__interrupt_vector_10"]
#[no_mangle]
pub static TIM0_VECTOR: extern "msp430-interrupt" fn() = tim0;

// The interrupt handler
extern "msp430-interrupt" fn tim0() {
    // ..
}
$ msp430-elf-objdump -CD ./target/msp430/release/app
Disassembly of section __interrupt_vector_10:

0000fff2 <TIM0_VECTOR>:
    fff2:       00 c0           interrupt service routine at 0xc000

Disassembly of section .text:

0000c000 <int::tim0>:
    c000:       00 13           reti
## abi_ptx

The tracking issue for this feature is: #38788

When emitting PTX code, all vanilla Rust functions (fn) get translated to "device" functions. These functions are not callable from the host via the CUDA API so a crate with only device functions is not too useful!

OTOH, "global" functions can be called by the host; you can think of them as the real public API of your crate. To produce a global function use the "ptx-kernel" ABI.

#![feature(abi_ptx)]
#![no_std]

pub unsafe extern "ptx-kernel" fn global_function() {
    device_function();
}

pub fn device_function() {
    // ..
}
$ xargo rustc --target nvptx64-nvidia-cuda --release -- --emit=asm

$ cat $(find -name '*.s')
//
// Generated by LLVM NVPTX Back-End
//

.version 3.2
.target sm_20
.address_size 64

        // .globl       _ZN6kernel15global_function17h46111ebe6516b382E

.visible .entry _ZN6kernel15global_function17h46111ebe6516b382E()
{


        ret;
}

        // .globl       _ZN6kernel15device_function17hd6a0e4993bbf3f78E
.visible .func _ZN6kernel15device_function17hd6a0e4993bbf3f78E()
{


        ret;
}
## abi_riscv_interrupt

Allows extern "riscv-interrupt-m" fn() and extern "riscv-interrupt-s" fn().

The tracking issue for this feature is: #111889

## abi_unadjusted

Allows using the unadjusted ABI; perma-unstable.

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## abi_vectorcall

The tracking issue for this feature is: #124485

Adds support for the Windows "vectorcall" ABI, the equivalent of __vectorcall in MSVC.

extern "vectorcall" {
    fn add_f64s(x: f64, y: f64) -> f64;
}

fn main() {
    println!("{}", add_f64s(2.0, 4.0));
}
## abi_x86_interrupt

Allows extern "x86-interrupt" fn().

The tracking issue for this feature is: #40180

## adt_const_params

The tracking issue for this feature is: #95174

Allows for using more complex types for const parameters, such as structs or enums.

#![feature(adt_const_params)]
#![allow(incomplete_features)]

use std::marker::ConstParamTy;

#[derive(ConstParamTy, PartialEq, Eq)]
enum Foo {
    A,
    B,
    C,
}

#[derive(ConstParamTy, PartialEq, Eq)]
struct Bar {
    flag: bool,
}

fn is_foo_a_and_bar_true<const F: Foo, const B: Bar>() -> bool {
    match (F, B.flag) {
        (Foo::A, true) => true,
        _ => false,
    }
}
## alloc_error_handler

Allows defining an #[alloc_error_handler].

The tracking issue for this feature is: #51540

## allocator_internals

This feature does not have a tracking issue, it is an unstable implementation detail of the global_allocator feature not intended for use outside the compiler.

## allow_internal_unsafe

Allows using #[allow_internal_unsafe]. This is an attribute on macro_rules! and can't use the attribute handling below (it has to be checked before expansion possibly makes macros disappear).

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## allow_internal_unstable

Allows using #[allow_internal_unstable]. This is an attribute on macro_rules! and can't use the attribute handling below (it has to be checked before expansion possibly makes macros disappear).

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## anonymous_lifetime_in_impl_trait

Allows using anonymous lifetimes in argument-position impl-trait.

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## apx_target_feature

The tracking issue for this feature is: #139284

## arbitrary_self_types

The tracking issue for this feature is: #44874

Allows any type implementing core::ops::Receiver<Target=T> to be used as the type of self in a method belonging to T.

For example,

#![feature(arbitrary_self_types)]

struct A;

impl A {
    fn f(self: SmartPtr<Self>) -> i32 { 1 }  // note self type
}

struct SmartPtr<T>(T);

impl<T> core::ops::Receiver for SmartPtr<T> {
    type Target = T;
}

fn main() {
    let smart_ptr = SmartPtr(A);
    assert_eq!(smart_ptr.f(), 1);
}
The Receiver trait has a blanket implementation for all T: Deref, so in fact things like this work too:

#![feature(arbitrary_self_types)]

use std::rc::Rc;

struct A;

impl A {
    fn f(self: Rc<Self>) -> i32 { 1 } // Rc implements Deref
}

fn main() {
    let smart_ptr = Rc::new(A);
    assert_eq!(smart_ptr.f(), 1);
}
Interestingly, that works even without the arbitrary_self_types feature

but that's because certain types are effectively hard coded, including Rc. ("Hard coding" isn't quite true; they use a lang-item called LegacyReceiver to denote their special-ness in this way). With the arbitrary_self_types feature, their special-ness goes away, and custom smart pointers can achieve the same.
Changes to method lookup

Method lookup previously used to work by stepping through the Deref chain then using the resulting list of steps in two different ways:

To identify types that might contribute methods via their impl blocks (inherent methods) or via traits
To identify the types that the method receiver (a in the above examples) can be converted to.
With this feature, these lists are created by instead stepping through the Receiver chain. However, a note is kept about whether the type can be reached also via the Deref chain.

The full chain (via Receiver hops) is used for the first purpose (identifying relevant impl blocks and traits); whereas the shorter list (reachable via Deref) is used for the second purpose. That's because, to convert the method target (a in a.b()) to the self type, Rust may need to be able to use Deref::deref. Type conversions, then, can only proceed as far as the end of the Deref chain whereas the longer Receiver chain can be used to explore more places where useful methods might reside.

Types suitable for use as smart pointers

This feature allows the creation of customised smart pointers - for example your own equivalent to Rc or Box with whatever capabilities you like. Those smart pointers can either implement Deref (if it's safe to create a reference to the referent) or Receiver (if it isn't).

Either way, smart pointer types should mostly avoid having methods. Calling methods on a smart pointer leads to ambiguity about whether you're aiming for a method on the pointer, or on the referent.

Best practice is therefore to put smart pointer functionality into associated functions instead - that's what's done in all the smart pointer types within Rust's standard library which implement Receiver.

If you choose to add any methods to your smart pointer type, your users may run into errors from deshadowing, as described in the next section.

Avoiding shadowing

With or without this feature, Rust emits an error if it finds two method candidates, like this:

use std::pin::Pin;
use std::pin::pin;

struct A;

impl A {
    fn get_ref(self: Pin<&A>) {}
}

fn main() {
    let pinned_a: Pin<&A> = pin!(A).as_ref();
    let pinned_a: Pin<&A> = pinned_a.as_ref();
    pinned_a.get_ref(); // error[E0034]: multiple applicable items in scope
}
(this is why Rust's smart pointers are mostly carefully designed to avoid having methods at all, and shouldn't add new methods in future.)

With arbitrary_self_types, we take care to spot some other kinds of conflict:

#![feature(arbitrary_self_types)]

use std::pin::Pin;
use std::pin::pin;

struct A;

impl A {
    fn get_ref(self: &Pin<&A>) {}  // note &Pin
}

fn main() {
    let pinned_a: Pin<&mut A> = pin!(A);
    let pinned_a: Pin<&A> = pinned_a.as_ref();
    pinned_a.get_ref();
}
This is to guard against the case where an inner (referent) type has a method of a given name, taking the smart pointer by reference, and then the smart pointer implementer adds a similar method taking self by value. As noted in the previous section, the safe option is simply not to add methods to smart pointers, and then these errors can't occur.

## arbitrary_self_types_pointers

The tracking issue for this feature is: [#44874]

This extends the arbitrary self types feature to allow methods to receive self by pointer. For example:

#![feature(arbitrary_self_types_pointers)]

struct A;

impl A {
    fn m(self: *const Self) {}
}

fn main() {
    let a = A;
    let a_ptr: *const A = &a as *const A;
    a_ptr.m();
}
In general this is not advised: it's thought to be better practice to wrap raw pointers in a newtype wrapper which implements the core::ops::Receiver trait, then you need "only" the arbitrary_self_types feature. For example:

#![feature(arbitrary_self_types)]
#![allow(dead_code)]

struct A;

impl A {
    fn m(self: Wrapper<Self>) {} // can extract the pointer and do
        // what it needs
}

struct Wrapper<T>(*const T);

impl<T> core::ops::Receiver for Wrapper<T> {
    type Target = T;
}

fn main() {
    let a = A;
    let a_ptr: *const A = &a as *const A;
    let a_wrapper = Wrapper(a_ptr);
    a_wrapper.m();
}
## arm_target_feature

The tracking issue for this feature is: #44839

## asm_cfg

Allows #[cfg(...)] on inline assembly templates and operands.

The tracking issue for this feature is: #140364

## asm_experimental_arch

The tracking issue for this feature is: #93335

This feature tracks asm! and global_asm! support for the following architectures:

NVPTX
PowerPC
Hexagon
MIPS32r2 and MIPS64r2
wasm32
BPF
SPIR-V
AVR
MSP430
M68k
CSKY
SPARC
Register classes

Architecture	Register class	Registers	LLVM constraint code
MIPS	reg	$[2-25]	r
MIPS	freg	$f[0-31]	f
NVPTX	reg16	None*	h
NVPTX	reg32	None*	r
NVPTX	reg64	None*	l
Hexagon	reg	r[0-28]	r
Hexagon	preg	p[0-3]	Only clobbers
PowerPC	reg	r0, r[3-12], r[14-29]*	r
PowerPC	reg_nonzero	r[3-12], r[14-29]*	b
PowerPC	freg	f[0-31]	f
PowerPC	vreg	v[0-31]	v
PowerPC	`vsreg	vs[0-63]	wa
PowerPC	cr	cr[0-7], cr	Only clobbers
PowerPC	ctr	ctr	Only clobbers
PowerPC	lr	lr	Only clobbers
PowerPC	xer	xer	Only clobbers
wasm32	local	None*	r
BPF	reg	r[0-10]	r
BPF	wreg	w[0-10]	w
AVR	reg	r[2-25], XH, XL, ZH, ZL	r
AVR	reg_upper	r[16-25], XH, XL, ZH, ZL	d
AVR	reg_pair	r3r2 .. r25r24, X, Z	r
AVR	reg_iw	r25r24, X, Z	w
AVR	reg_ptr	X, Z	e
MSP430	reg	r[0-15]	r
M68k	reg	d[0-7], a[0-7]	r
M68k	reg_data	d[0-7]	d
M68k	reg_addr	a[0-3]	a
CSKY	reg	r[0-31]	r
CSKY	freg	f[0-31]	f
SPARC	reg	r[2-29]	r
SPARC	yreg	y	Only clobbers
Notes:

NVPTX doesn't have a fixed register set, so named registers are not supported.

WebAssembly doesn't have registers, so named registers are not supported.

r29 is reserved only on 32 bit PowerPC targets.

Register class supported types

Architecture	Register class	Target feature	Allowed types
MIPS32	reg	None	i8, i16, i32, f32
MIPS32	freg	None	f32, f64
MIPS64	reg	None	i8, i16, i32, i64, f32, f64
MIPS64	freg	None	f32, f64
NVPTX	reg16	None	i8, i16
NVPTX	reg32	None	i8, i16, i32, f32
NVPTX	reg64	None	i8, i16, i32, f32, i64, f64
Hexagon	reg	None	i8, i16, i32, f32
Hexagon	preg	N/A	Only clobbers
PowerPC	reg	None	i8, i16, i32, i64 (powerpc64 only)
PowerPC	reg_nonzero	None	i8, i16, i32, i64 (powerpc64 only)
PowerPC	freg	None	f32, f64
PowerPC	vreg	altivec	i8x16, i16x8, i32x4, f32x4
PowerPC	vreg	vsx	f32, f64, i64x2, f64x2
PowerPC	vsreg	vsx	The union of vsx and altivec vreg types
PowerPC	cr	N/A	Only clobbers
PowerPC	ctr	N/A	Only clobbers
PowerPC	lr	N/A	Only clobbers
PowerPC	xer	N/A	Only clobbers
wasm32	local	None	i8 i16 i32 i64 f32 f64
BPF	reg	None	i8 i16 i32 i64
BPF	wreg	alu32	i8 i16 i32
AVR	reg, reg_upper	None	i8
AVR	reg_pair, reg_iw, reg_ptr	None	i16
MSP430	reg	None	i8, i16
M68k	reg, reg_addr	None	i16, i32
M68k	reg_data	None	i8, i16, i32
CSKY	reg	None	i8, i16, i32
CSKY	freg	None	f32,
SPARC	reg	None	i8, i16, i32, i64 (SPARC64 only)
SPARC	yreg	N/A	Only clobbers
Register aliases

Architecture	Base register	Aliases
Hexagon	r29	sp
Hexagon	r30	fr
Hexagon	r31	lr
PowerPC	r1	sp
PowerPC	r31	fp
PowerPC	r[0-31]	[0-31]
PowerPC	f[0-31]	fr[0-31]
BPF	r[0-10]	w[0-10]
AVR	XH	r27
AVR	XL	r26
AVR	ZH	r31
AVR	ZL	r30
MSP430	r0	pc
MSP430	r1	sp
MSP430	r2	sr
MSP430	r3	cg
MSP430	r4	fp
M68k	a5	bp
M68k	a6	fp
M68k	a7	sp, usp, ssp, isp
CSKY	r[0-3]	a[0-3]
CSKY	r[4-11]	l[0-7]
CSKY	r[12-13]	t[0-1]
CSKY	r14	sp
CSKY	r15	lr
CSKY	r[16-17]	l[8-9]
CSKY	r[18-25]	t[2-9]
CSKY	r28	rgb
CSKY	r29	rtb
CSKY	r30	svbr
CSKY	r31	tls
SPARC	r[0-7]	g[0-7]
SPARC	r[8-15]	o[0-7]
SPARC	r[16-23]	l[0-7]
SPARC	r[24-31]	i[0-7]
Notes:

TI does not mandate a frame pointer for MSP430, but toolchains are allowed to use one; LLVM uses r4.
Unsupported registers

Architecture	Unsupported register	Reason
All	sp, r14/o6 (SPARC)	The stack pointer must be restored to its original value at the end of an asm code block.
All	fr (Hexagon), fp (PowerPC), $fp (MIPS), Y (AVR), r4 (MSP430), a6 (M68k), r30/i6 (SPARC)	The frame pointer cannot be used as an input or output.
All	r19 (Hexagon), r29 (PowerPC 32 bit only), r30 (PowerPC)	These are used internally by LLVM as "base pointer" for functions with complex stack frames.
MIPS	$0 or $zero	This is a constant zero register which can't be modified.
MIPS	$1 or $at	Reserved for assembler.
MIPS	$26/$k0, $27/$k1	OS-reserved registers.
MIPS	$28/$gp	Global pointer cannot be used as inputs or outputs.
MIPS	$ra	Return address cannot be used as inputs or outputs.
Hexagon	lr	This is the link register which cannot be used as an input or output.
PowerPC	r2, r13	These are system reserved registers.
PowerPC	vrsave	The vrsave register cannot be used as an input or output.
AVR	r0, r1, r1r0	Due to an issue in LLVM, the r0 and r1 registers cannot be used as inputs or outputs. If modified, they must be restored to their original values before the end of the block.
MSP430	r0, r2, r3	These are the program counter, status register, and constant generator respectively. Neither the status register nor constant generator can be written to.
M68k	a4, a5	Used internally by LLVM for the base pointer and global base pointer.
CSKY	r7, r28	Used internally by LLVM for the base pointer and global base pointer.
CSKY	r8	Used internally by LLVM for the frame pointer.
CSKY	r14	Used internally by LLVM for the stack pointer.
CSKY	r15	This is the link register.
CSKY	r[26-30]	Reserved by its ABI.
CSKY	r31	This is the TLS register.
SPARC	r0/g0	This is always zero and cannot be used as inputs or outputs.
SPARC	r1/g1	Used internally by LLVM.
SPARC	r5/g5	Reserved for system. (SPARC32 only)
SPARC	r6/g6, r7/g7	Reserved for system.
SPARC	r31/i7	Return address cannot be used as inputs or outputs.
Template modifiers

Architecture	Register class	Modifier	Example output	LLVM modifier
MIPS	reg	None	$2	None
MIPS	freg	None	$f0	None
NVPTX	reg16	None	rs0	None
NVPTX	reg32	None	r0	None
NVPTX	reg64	None	rd0	None
Hexagon	reg	None	r0	None
PowerPC	reg	None	0	None
PowerPC	reg_nonzero	None	3	None
PowerPC	freg	None	0	None
PowerPC	vreg	None	0	None
PowerPC	vsreg	None	0	None
SPARC	reg	None	%o0	None
CSKY	reg	None	r0	None
CSKY	freg	None	f0	None
Flags covered by preserves_flags

These flags registers must be restored upon exiting the asm block if the preserves_flags option is set:

AVR
The status register SREG.
MSP430
The status register r2.
M68k
The condition code register ccr.
SPARC
Integer condition codes (icc and xcc)
Floating-point condition codes (fcc[0-3])
CSKY
Condition/carry bit (C) in PSR.
asm_experimental_arch

The tracking issue for this feature is: #133416

This tracks support for additional registers in architectures where inline assembly is already stable.

Register classes

Architecture	Register class	Registers	LLVM constraint code
s390x	vreg	v[0-31]	v
Notes:

s390x vreg is clobber-only in stable.
Register class supported types

Architecture	Register class	Target feature	Allowed types
s390x	vreg	vector	i32, f32, i64, f64, i128, f128, i8x16, i16x8, i32x4, i64x2, f32x4, f64x2
Register aliases

Architecture	Base register	Aliases
Unsupported registers

Architecture	Unsupported register	Reason
Template modifiers

Architecture	Register class	Modifier	Example output	LLVM modifier
s390x	vreg	None	%v0	None
## asm_goto_with_outputs

The tracking issue for this feature is: #119364

This feature allows label operands to be used together with output operands.

Example:


unsafe {
    let a: usize;
    asm!(
        "mov {}, 1"
        "jmp {}",
        out(reg) a,
        label {
            println!("Jumped from asm {}!", a);
        }
    );
}
The output operands are assigned before the label blocks are executed.

## asm_unwind

The tracking issue for this feature is: #93334

This feature adds a may_unwind option to asm! which allows an asm block to unwind stack and be part of the stack unwinding process. This option is only supported by the LLVM backend right now.

## associated_const_equality

Allows users to enforce equality of associated constants TraitImpl<AssocConst=3>.

The tracking issue for this feature is: #92827

## associated_type_defaults

Allows associated type defaults.

The tracking issue for this feature is: #29661

## async_drop

Allows implementing AsyncDrop.

The tracking issue for this feature is: #126482

## async_fn_in_dyn_trait

Allows async functions to be called from dyn Trait.

The tracking issue for this feature is: #133119

## async_fn_track_caller

Allows #[track_caller] on async functions.

The tracking issue for this feature is: #110011

## async_for_loop

Allows for await loops.

The tracking issue for this feature is: #118898

## async_trait_bounds

Allows async trait bound modifier.

The tracking issue for this feature is: #62290

## auto_traits

The tracking issue for this feature is #13231

The auto_traits feature gate allows you to define auto traits.

Auto traits, like Send or Sync in the standard library, are marker traits that are automatically implemented for every type, unless the type, or a type it contains, has explicitly opted out via a negative impl. (Negative impls are separately controlled by the negative_impls feature.)

impl !Trait for Type {}
Example:

#![feature(negative_impls)]
#![feature(auto_traits)]

auto trait Valid {}

struct True;
struct False;

impl !Valid for False {}

struct MaybeValid<T>(T);

fn must_be_valid<T: Valid>(_t: T) { }

fn main() {
    // works
    must_be_valid( MaybeValid(True) );

    // compiler error - trait bound not satisfied
    // must_be_valid( MaybeValid(False) );
}
Automatic trait implementations

When a type is declared as an auto trait, we will automatically create impls for every struct/enum/union, unless an explicit impl is provided. These automatic impls contain a where clause for each field of the form T: AutoTrait, where T is the type of the field and AutoTrait is the auto trait in question. As an example, consider the struct List and the auto trait Send:

struct List<T> {
  data: T,
  next: Option<Box<List<T>>>,
}
Presuming that there is no explicit impl of Send for List, the compiler will supply an automatic impl of the form:

struct List<T> {
  data: T,
  next: Option<Box<List<T>>>,
}

unsafe impl<T> Send for List<T>
where
  T: Send, // from the field `data`
  Option<Box<List<T>>>: Send, // from the field `next`
{ }
Explicit impls may be either positive or negative. They take the form:

impl<...> AutoTrait for StructName<..> { }
impl<...> !AutoTrait for StructName<..> { }
Coinduction: Auto traits permit cyclic matching

Unlike ordinary trait matching, auto traits are coinductive. This means, in short, that cycles which occur in trait matching are considered ok. As an example, consider the recursive struct List introduced in the previous section. In attempting to determine whether List: Send, we would wind up in a cycle: to apply the impl, we must show that Option<Box<List>>: Send, which will in turn require Box<List>: Send and then finally List: Send again. Under ordinary trait matching, this cycle would be an error, but for an auto trait it is considered a successful match.

Items

Auto traits cannot have any trait items, such as methods or associated types. This ensures that we can generate default implementations.

Supertraits

Auto traits cannot have supertraits. This is for soundness reasons, as the interaction of coinduction with implied bounds is difficult to reconcile.

## avx10_target_feature

Allows using Intel AVX10 target features and intrinsics

The tracking issue for this feature is: #138843

## box_patterns

The tracking issue for this feature is: #29641

Note: This feature will be superseded by deref_patterns in the future.

Box patterns let you match on Box<T>s:

#![feature(box_patterns)]

fn main() {
    let b = Some(Box::new(5));
    match b {
        Some(box n) if n < 0 => {
            println!("Box contains negative number {n}");
        },
        Some(box n) if n >= 0 => {
            println!("Box contains non-negative number {n}");
        },
        None => {
            println!("No box");
        },
        _ => unreachable!()
    }
}
## bpf_target_feature

The tracking issue for this feature is: #44839

## builtin_syntax

Allows builtin # foo() syntax

The tracking issue for this feature is: #110680

## c_variadic

The tracking issue for this feature is: #44930

The c_variadic language feature enables C-variadic functions to be defined in Rust. They may be called both from within Rust and via FFI.

Examples

#![feature(c_variadic)]

pub unsafe extern "C" fn add(n: usize, mut args: ...) -> usize {
    let mut sum = 0;
    for _ in 0..n {
        sum += args.arg::<usize>();
    }
    sum
}
## cfg_contract_checks

Allows the use of #[cfg(contract_checks) to check if contract checks are enabled.

The tracking issue for this feature is: #128044

## cfg_emscripten_wasm_eh

Allows access to the emscripten_wasm_eh config, used by panic_unwind and unwind

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## cfg_overflow_checks

Allows the use of #[cfg(overflow_checks) to check if integer overflow behaviour.

The tracking issue for this feature is: #111466

## cfg_relocation_model

Provides the relocation model information as cfg entry

The tracking issue for this feature is: #114929

## cfg_sanitize

The tracking issue for this feature is: #39699

The cfg_sanitize feature makes it possible to execute different code depending on whether a particular sanitizer is enabled or not.

Examples

#![feature(cfg_sanitize)]

#[cfg(sanitize = "thread")]
fn a() {
    // ...
}

#[cfg(not(sanitize = "thread"))]
fn a() {
    // ...
}

fn b() {
    if cfg!(sanitize = "leak") {
        // ...
    } else {
        // ...
    }
}
## cfg_sanitizer_cfi

Allows cfg(sanitizer_cfi_generalize_pointers) and cfg(sanitizer_cfi_normalize_integers).

The tracking issue for this feature is: #89653

## cfg_target_compact

Allows cfg(target(abi = "...")).

The tracking issue for this feature is: #96901

## cfg_target_has_atomic

Allows cfg(target_has_atomic_load_store = "...").

The tracking issue for this feature is: #94039

## cfg_target_has_atomic_equal_alignment

Allows cfg(target_has_atomic_equal_alignment = "...").

The tracking issue for this feature is: #93822

## cfg_target_has_reliable_f16_f128

Allows checking whether or not the backend correctly supports unstable float types.

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## cfg_target_thread_local

Allows cfg(target_thread_local).

The tracking issue for this feature is: #29594

## cfg_ub_checks

Allows the use of #[cfg(ub_checks) to check if UB checks are enabled.

The tracking issue for this feature is: #123499

## cfg_version

The tracking issue for this feature is: #64796

The cfg_version feature makes it possible to execute different code depending on the compiler version. It will return true if the compiler version is greater than or equal to the specified version.

Examples

#![feature(cfg_version)]

#[cfg(version("1.42"))] // 1.42 and above
fn a() {
    // ...
}

#[cfg(not(version("1.42")))] // 1.41 and below
fn a() {
    // ...
}

fn b() {
    if cfg!(version("1.42")) {
        // ...
    } else {
        // ...
    }
}
## cfi_encoding

The tracking issue for this feature is: #89653

The cfi_encoding feature allows the user to define a CFI encoding for a type. It allows the user to use a different names for types that otherwise would be required to have the same name as used in externally defined C functions.

Examples

#![feature(cfi_encoding, extern_types)]

#[cfi_encoding = "3Foo"]
pub struct Type1(i32);

extern {
    #[cfi_encoding = "3Bar"]
    type Type2;
}
## closure_lifetime_binder

Allows for<...> on closures and coroutines.

The tracking issue for this feature is: #97362

## closure_track_caller

The tracking issue for this feature is: #87417

Allows using the #[track_caller] attribute on closures and coroutines. Calls made to the closure or coroutine will have caller information available through std::panic::Location::caller(), just like using #[track_caller] on a function.

## cmse_nonsecure_entry

The tracking issue for this feature is: #75835

The TrustZone-M feature is available for targets with the Armv8-M architecture profile (thumbv8m in their target name). LLVM, the Rust compiler and the linker are providing support for the TrustZone-M feature.

One of the things provided with this unstable feature is the "cmse-nonsecure-entry" ABI. This ABI marks a Secure function as an entry function (see section 5.4 for details). With this ABI, the compiler will do the following:

add a special symbol on the function which is the __acle_se_ prefix and the standard function name
constrain the number of parameters to avoid using the Non-Secure stack
before returning from the function, clear registers that might contain Secure information
use the BXNS instruction to return
Because the stack can not be used to pass parameters, there will be compilation errors if:

the total size of all parameters is too big (for example, more than four 32-bit integers)
The special symbol __acle_se_ will be used by the linker to generate a secure gateway veneer.

#![no_std]
#![feature(cmse_nonsecure_entry)]

#[no_mangle]
pub extern "cmse-nonsecure-entry" fn entry_function(input: u32) -> u32 {
    input + 6
}
$ rustc --emit obj --crate-type lib --target thumbv8m.main-none-eabi function.rs
$ arm-none-eabi-objdump -D function.o

00000000 <entry_function>:
   0:   b580            push    {r7, lr}
   2:   466f            mov     r7, sp
   4:   b082            sub     sp, #8
   6:   9001            str     r0, [sp, #4]
   8:   1d81            adds    r1, r0, #6
   a:   460a            mov     r2, r1
   c:   4281            cmp     r1, r0
   e:   9200            str     r2, [sp, #0]
  10:   d30b            bcc.n   2a <entry_function+0x2a>
  12:   e7ff            b.n     14 <entry_function+0x14>
  14:   9800            ldr     r0, [sp, #0]
  16:   b002            add     sp, #8
  18:   e8bd 4080       ldmia.w sp!, {r7, lr}
  1c:   4671            mov     r1, lr
  1e:   4672            mov     r2, lr
  20:   4673            mov     r3, lr
  22:   46f4            mov     ip, lr
  24:   f38e 8800       msr     CPSR_f, lr
  28:   4774            bxns    lr
  2a:   f240 0000       movw    r0, #0
  2e:   f2c0 0000       movt    r0, #0
  32:   f240 0200       movw    r2, #0
  36:   f2c0 0200       movt    r2, #0
  3a:   211c            movs    r1, #28
  3c:   f7ff fffe       bl      0 <_ZN4core9panicking5panic17h5c028258ca2fb3f5E>
  40:   defe            udf     #254    ; 0xfe
## compiler_builtins

This feature is internal to the Rust compiler and is not intended for general use.

## const_async_blocks

Allows async {} expressions in const contexts.

The tracking issue for this feature is: #85368

## const_closures

Allows const || {} closures in const contexts.

The tracking issue for this feature is: #106003

## const_destruct

Allows using [const] Destruct bounds and calling drop impls in const contexts.

The tracking issue for this feature is: #133214

## const_for

Allows for _ in _ loops in const contexts.

The tracking issue for this feature is: #87575

## const_precise_live_drops

Be more precise when looking for live drops in a const context.

The tracking issue for this feature is: #73255

## const_trait_impl

Allows impl const Trait for T syntax.

The tracking issue for this feature is: #143874

## const_try

Allows the ? operator in const contexts.

The tracking issue for this feature is: #74935

## contracts

Allows use of contracts attributes.

The tracking issue for this feature is: #128044

## contracts_internals

Allows access to internal machinery used to implement contracts.

The tracking issue for this feature is: #128044

## coroutine_clone

Allows coroutines to be cloned.

The tracking issue for this feature is: #95360

## coroutines

The tracking issue for this feature is: #43122

The coroutines feature gate in Rust allows you to define coroutine or coroutine literals. A coroutine is a "resumable function" that syntactically resembles a closure but compiles to much different semantics in the compiler itself. The primary feature of a coroutine is that it can be suspended during execution to be resumed at a later date. Coroutines use the yield keyword to "return", and then the caller can resume a coroutine to resume execution just after the yield keyword.

Coroutines are an extra-unstable feature in the compiler right now. Added in RFC 2033 they're mostly intended right now as a information/constraint gathering phase. The intent is that experimentation can happen on the nightly compiler before actual stabilization. A further RFC will be required to stabilize coroutines and will likely contain at least a few small tweaks to the overall design.

A syntactical example of a coroutine is:

#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]

use std::ops::{Coroutine, CoroutineState};
use std::pin::Pin;

fn main() {
    let mut coroutine = #[coroutine] || {
        yield 1;
        return "foo"
    };

    match Pin::new(&mut coroutine).resume(()) {
        CoroutineState::Yielded(1) => {}
        _ => panic!("unexpected value from resume"),
    }
    match Pin::new(&mut coroutine).resume(()) {
        CoroutineState::Complete("foo") => {}
        _ => panic!("unexpected value from resume"),
    }
}
Coroutines are closure-like literals which are annotated with #[coroutine] and can contain a yield statement. The yield statement takes an optional expression of a value to yield out of the coroutine. All coroutine literals implement the Coroutine trait in the std::ops module. The Coroutine trait has one main method, resume, which resumes execution of the coroutine at the previous suspension point.

An example of the control flow of coroutines is that the following example prints all numbers in order:

#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]

use std::ops::Coroutine;
use std::pin::Pin;

fn main() {
    let mut coroutine = #[coroutine] || {
        println!("2");
        yield;
        println!("4");
    };

    println!("1");
    Pin::new(&mut coroutine).resume(());
    println!("3");
    Pin::new(&mut coroutine).resume(());
    println!("5");
}
At this time the main use case of coroutines is an implementation primitive for async/await and gen syntax, but coroutines will likely be extended to other primitives in the future. Feedback on the design and usage is always appreciated!

The Coroutine trait

The Coroutine trait in std::ops currently looks like:


pub trait Coroutine<R = ()> {
    type Yield;
    type Return;
    fn resume(self: Pin<&mut Self>, resume: R) -> CoroutineState<Self::Yield, Self::Return>;
}
The Coroutine::Yield type is the type of values that can be yielded with the yield statement. The Coroutine::Return type is the returned type of the coroutine. This is typically the last expression in a coroutine's definition or any value passed to return in a coroutine. The resume function is the entry point for executing the Coroutine itself.

The return value of resume, CoroutineState, looks like:

pub enum CoroutineState<Y, R> {
    Yielded(Y),
    Complete(R),
}
The Yielded variant indicates that the coroutine can later be resumed. This corresponds to a yield point in a coroutine. The Complete variant indicates that the coroutine is complete and cannot be resumed again. Calling resume after a coroutine has returned Complete will likely result in a panic of the program.

Closure-like semantics

The closure-like syntax for coroutines alludes to the fact that they also have closure-like semantics. Namely:

When created, a coroutine executes no code. A closure literal does not actually execute any of the closure's code on construction, and similarly a coroutine literal does not execute any code inside the coroutine when constructed.

Coroutines can capture outer variables by reference or by move, and this can be tweaked with the move keyword at the beginning of the closure. Like closures all coroutines will have an implicit environment which is inferred by the compiler. Outer variables can be moved into a coroutine for use as the coroutine progresses.

Coroutine literals produce a value with a unique type which implements the std::ops::Coroutine trait. This allows actual execution of the coroutine through the Coroutine::resume method as well as also naming it in return types and such.

Traits like Send and Sync are automatically implemented for a Coroutine depending on the captured variables of the environment. Unlike closures, coroutines also depend on variables live across suspension points. This means that although the ambient environment may be Send or Sync, the coroutine itself may not be due to internal variables live across yield points being not-Send or not-Sync. Note that coroutines do not implement traits like Copy or Clone automatically.

Whenever a coroutine is dropped it will drop all captured environment variables.

Coroutines as state machines

In the compiler, coroutines are currently compiled as state machines. Each yield expression will correspond to a different state that stores all live variables over that suspension point. Resumption of a coroutine will dispatch on the current state and then execute internally until a yield is reached, at which point all state is saved off in the coroutine and a value is returned.

Let's take a look at an example to see what's going on here:

#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]

use std::ops::Coroutine;
use std::pin::Pin;

fn main() {
    let ret = "foo";
    let mut coroutine = #[coroutine] move || {
        yield 1;
        return ret
    };

    Pin::new(&mut coroutine).resume(());
    Pin::new(&mut coroutine).resume(());
}
This coroutine literal will compile down to something similar to:

#![feature(arbitrary_self_types, coroutine_trait)]

use std::ops::{Coroutine, CoroutineState};
use std::pin::Pin;

fn main() {
    let ret = "foo";
    let mut coroutine = {
        enum __Coroutine {
            Start(&'static str),
            Yield1(&'static str),
            Done,
        }

        impl Coroutine for __Coroutine {
            type Yield = i32;
            type Return = &'static str;

            fn resume(mut self: Pin<&mut Self>, resume: ()) -> CoroutineState<i32, &'static str> {
                use std::mem;
                match mem::replace(&mut *self, __Coroutine::Done) {
                    __Coroutine::Start(s) => {
                        *self = __Coroutine::Yield1(s);
                        CoroutineState::Yielded(1)
                    }

                    __Coroutine::Yield1(s) => {
                        *self = __Coroutine::Done;
                        CoroutineState::Complete(s)
                    }

                    __Coroutine::Done => {
                        panic!("coroutine resumed after completion")
                    }
                }
            }
        }

        __Coroutine::Start(ret)
    };

    Pin::new(&mut coroutine).resume(());
    Pin::new(&mut coroutine).resume(());
}
Notably here we can see that the compiler is generating a fresh type, __Coroutine in this case. This type has a number of states (represented here as an enum) corresponding to each of the conceptual states of the coroutine. At the beginning we're closing over our outer variable foo and then that variable is also live over the yield point, so it's stored in both states.

When the coroutine starts it'll immediately yield 1, but it saves off its state just before it does so indicating that it has reached the yield point. Upon resuming again we'll execute the return ret which returns the Complete state.

Here we can also note that the Done state, if resumed, panics immediately as it's invalid to resume a completed coroutine. It's also worth noting that this is just a rough desugaring, not a normative specification for what the compiler does.

## coverage_attribute

The tracking issue for this feature is: #84605

The coverage attribute can be used to selectively disable coverage instrumentation in an annotated function. This might be useful to:

Avoid instrumentation overhead in a performance critical function
Avoid generating coverage for a function that is not meant to be executed, but still target 100% coverage for the rest of the program.
Example

#![feature(coverage_attribute)]

// `foo()` will get coverage instrumentation (by default)
fn foo() {
  // ...
}

#[coverage(off)]
fn bar() {
  // ...
}
## csky_target_feature

The tracking issue for this feature is: #44839

## custom_inner_attributes

Allows non-builtin attributes in inner attribute position.

The tracking issue for this feature is: #54726

## custom_mir

Allows writing custom MIR

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## custom_test_frameworks

The tracking issue for this feature is: #50297

The custom_test_frameworks feature allows the use of #[test_case] and #![test_runner]. Any function, const, or static can be annotated with #[test_case] causing it to be aggregated (like #[test]) and be passed to the test runner determined by the #![test_runner] crate attribute.

#![feature(custom_test_frameworks)]
#![test_runner(my_runner)]

fn my_runner(tests: &[&i32]) {
    for t in tests {
        if **t == 0 {
            println!("PASSED");
        } else {
            println!("FAILED");
        }
    }
}

#[test_case]
const WILL_PASS: i32 = 0;

#[test_case]
const WILL_FAIL: i32 = 4;
## decl_macro

Allows declarative macros 2.0 (macro).

The tracking issue for this feature is: #39412

## default_field_values

The tracking issue for this feature is: #132162

The RFC for this feature is: #3681

The default_field_values feature allows users to specify a const value for individual fields in struct definitions, allowing those to be omitted from initializers.

Examples

#![feature(default_field_values)]

#[derive(Default)]
struct Pet {
    name: Option<String>, // impl Default for Pet will use Default::default() for name
    age: i128 = 42, // impl Default for Pet will use the literal 42 for age
}

fn main() {
    let a = Pet { name: Some(String::new()), .. }; // Pet { name: Some(""), age: 42 }
    let b = Pet::default(); // Pet { name: None, age: 42 }
    assert_eq!(a.age, b.age);
    // The following would be a compilation error: `name` needs to be specified
    // let _ = Pet { .. };
}
#[derive(Default)]

When deriving Default, the provided values are then used. On enum variants, the variant must still be marked with #[default] and have all its fields with default values.

#![feature(default_field_values)]

#[derive(Default)]
enum A {
    #[default]
    B {
        x: i32 = 0,
        y: i32 = 0,
    },
    C,
}
Enum variants

This feature also supports enum variants for both specifying default values and #[derive(Default)].

Interaction with #[non_exhaustive]

A struct or enum variant marked with #[non_exhaustive] is not allowed to have default field values.

Lints

When manually implementing the Default trait for a type that has default field values, if any of these are overridden in the impl the default_overrides_default_fields lint will trigger. This lint is in place to avoid surprising diverging behavior between S { .. } and S::default(), where using the same type in both ways could result in different values. The appropriate way to write a manual Default implementation is to use the functional update syntax:

#![feature(default_field_values)]

struct Pet {
    name: String,
    age: i128 = 42, // impl Default for Pet will use the literal 42 for age
}

impl Default for Pet {
    fn default() -> Pet {
        Pet {
            name: "no-name".to_string(),
            ..
        }
    }
}
## deprecated_safe

Allows using #[deprecated_safe] to deprecate the safeness of a function or trait

The tracking issue for this feature is: #94978

## deprecated_suggestion

Allows having using suggestion in the #[deprecated] attribute.

The tracking issue for this feature is: #94785

## deref_patterns

The tracking issue for this feature is: #87121

Note: This feature is incomplete. In the future, it is meant to supersede box_patterns and string_deref_patterns.

This feature permits pattern matching on smart pointers in the standard library through their Deref target types, either implicitly or with explicit deref!(_) patterns (the syntax of which is currently a placeholder).

#![feature(deref_patterns)]
#![allow(incomplete_features)]

let mut v = vec![Box::new(Some(0))];

// Implicit dereferences are inserted when a pattern can match against the
// result of repeatedly dereferencing but can't match against a smart
// pointer itself. This works alongside match ergonomics for references.
if let [Some(x)] = &mut v {
    *x += 1;
}

// Explicit `deref!(_)` patterns may instead be used when finer control is
// needed, e.g. to dereference only a single smart pointer, or to bind the
// the result of dereferencing to a variable.
if let deref!([deref!(opt_x @ Some(1))]) = &mut v {
    opt_x.as_mut().map(|x| *x += 1);
}

assert_eq!(v, [Box::new(Some(2))]);
Without this feature, it may be necessary to introduce temporaries to represent dereferenced places when matching on nested structures:

let mut v = vec![Box::new(Some(0))];
if let [b] = &mut *v {
    if let Some(x) = &mut **b {
        *x += 1;
    }
}
if let [b] = &mut *v {
    if let opt_x @ Some(1) = &mut **b {
        opt_x.as_mut().map(|x| *x += 1);
    }
}
assert_eq!(v, [Box::new(Some(2))]);
Like box_patterns, deref patterns may move out of boxes:

struct NoCopy;
let deref!(x) = Box::new(NoCopy);
drop::<NoCopy>(x);
Additionally, deref_patterns implements changes to string and byte string literal patterns, allowing then to be used in deref patterns:

match ("test".to_string(), Box::from("test"), b"test".to_vec()) {
    ("test", "test", b"test") => {}
    _ => panic!(),
}

// This works through multiple layers of reference and smart pointer:
match (&Box::new(&"test".to_string()), &&&"test") {
    ("test", "test") => {}
    _ => panic!(),
}

// `deref!("...")` syntax may also be used:
match "test".to_string() {
    deref!("test") => {}
    _ => panic!(),
}

// Matching on slices and arrays using literals is possible elsewhere as well:
match *"test" {
    "test" => {}
    _ => panic!(),
}
match *b"test" {
    b"test" => {}
    _ => panic!(),
}
match *(b"test" as &[u8]) {
    b"test" => {}
    _ => panic!(),
}
## derive_from

Allows deriving the From trait on single-field structs.

The tracking issue for this feature is: #144889

## doc_cfg

The tracking issue for this feature is: #43781

The doc_cfg feature allows an API be documented as only available in some specific platforms. This attribute has two effects:

In the annotated item's documentation, there will be a message saying "Available on (platform) only".

The item's doc-tests will only run on the specific platform.

In addition to allowing the use of the #[doc(cfg)] attribute, this feature enables the use of a special conditional compilation flag, #[cfg(doc)], set whenever building documentation on your crate.

This feature was introduced as part of PR #43348 to allow the platform-specific parts of the standard library be documented.

#![feature(doc_cfg)]

#[cfg(any(windows, doc))]
#[doc(cfg(windows))]
/// The application's icon in the notification area (a.k.a. system tray).
///
/// # Examples
///
/// ```no_run
/// extern crate my_awesome_ui_library;
/// use my_awesome_ui_library::current_app;
/// use my_awesome_ui_library::windows::notification;
///
/// let icon = current_app().get::<notification::Icon>();
/// icon.show();
/// icon.show_message("Hello");
/// ```
pub struct Icon {
    // ...
}
## doc_masked

The tracking issue for this feature is: #44027

The doc_masked feature allows a crate to exclude types from a given crate from appearing in lists of trait implementations. The specifics of the feature are as follows:

When rustdoc encounters an extern crate statement annotated with a #[doc(masked)] attribute, it marks the crate as being masked.

When listing traits a given type implements, rustdoc ensures that traits from masked crates are not emitted into the documentation.

When listing types that implement a given trait, rustdoc ensures that types from masked crates are not emitted into the documentation.

This feature was introduced in PR #44026 to ensure that compiler-internal and implementation-specific types and traits were not included in the standard library's documentation. Such types would introduce broken links into the documentation.

## doc_notable_trait

The tracking issue for this feature is: #45040

The doc_notable_trait feature allows the use of the #[doc(notable_trait)] attribute, which will display the trait in a "Notable traits" dialog for functions returning types that implement the trait. For example, this attribute is applied to the Iterator, Future, io::Read, and io::Write traits in the standard library.

You can do this on your own traits like so:

#![feature(doc_notable_trait)]

#[doc(notable_trait)]
pub trait MyTrait {}

pub struct MyStruct;
impl MyTrait for MyStruct {}

/// The docs for this function will have a button that displays a dialog about
/// `MyStruct` implementing `MyTrait`.
pub fn my_fn() -> MyStruct { MyStruct }
This feature was originally implemented in PR #45039.

See also its documentation in the rustdoc book.

## dropck_eyepatch

Allows using the may_dangle attribute (RFC 1327).

The tracking issue for this feature is: #34761

## effective_target_features

Allows features to allow target_feature to better interact with traits.

The tracking issue for this feature is: #143352

## ergonomic_clones

Allows the .use postfix syntax x.use and use closures use |x| { ... }

The tracking issue for this feature is: #132290

## ermsb_target_feature

The tracking issue for this feature is: #44839

## exhaustive_patterns

Allows exhaustive pattern matching on types that contain uninhabited types.

The tracking issue for this feature is: #51085

## explicit_extern_abis

The tracking issue for this feature is: #134986

Disallow extern without an explicit ABI. We should write extern "C" (or another ABI) instead of just extern.

By making the ABI explicit, it becomes much clearer that "C" is just one of the possible choices, rather than the "standard" way for external functions. Removing the default makes it easier to add a new ABI on equal footing as "C".

#![feature(explicit_extern_abis)]

extern fn function1() {}  // ERROR `extern` declarations without an explicit ABI
                          // are disallowed

extern "C" fn function2() {} // compiles

extern "aapcs" fn function3() {} // compiles
## explicit_tail_calls

Allows explicit tail calls via become expression.

The tracking issue for this feature is: #112788

## export_stable

Allows using #[export_stable] which indicates that an item is exportable.

The tracking issue for this feature is: #139939

## extern_system_varargs

Allows using system as a calling convention with varargs.

The tracking issue for this feature is: #136946

## extern_types

Allows defining extern types.

The tracking issue for this feature is: #43467

## f128

The tracking issue for this feature is: #116909

Enable the f128 type for IEEE 128-bit floating numbers (quad precision).

## f16

The tracking issue for this feature is: #116909

Enable the f16 type for IEEE 16-bit floating numbers (half precision).

## ffi_const

The tracking issue for this feature is: #58328

The #[ffi_const] attribute applies clang's const attribute to foreign functions declarations.

That is, #[ffi_const] functions shall have no effects except for its return value, which can only depend on the values of the function parameters, and is not affected by changes to the observable state of the program.

Applying the #[ffi_const] attribute to a function that violates these requirements is undefined behaviour.

This attribute enables Rust to perform common optimizations, like sub-expression elimination, and it can avoid emitting some calls in repeated invocations of the function with the same argument values regardless of other operations being performed in between these functions calls (as opposed to #[ffi_pure] functions).

Pitfalls

A #[ffi_const] function can only read global memory that would not affect its return value for the whole execution of the program (e.g. immutable global memory). #[ffi_const] functions are referentially-transparent and therefore more strict than #[ffi_pure] functions.

A common pitfall involves applying the #[ffi_const] attribute to a function that reads memory through pointer arguments which do not necessarily point to immutable global memory.

A #[ffi_const] function that returns unit has no effect on the abstract machine's state, and a #[ffi_const] function cannot be #[ffi_pure].

A #[ffi_const] function must not diverge, neither via a side effect (e.g. a call to abort) nor by infinite loops.

When translating C headers to Rust FFI, it is worth verifying for which targets the const attribute is enabled in those headers, and using the appropriate cfg macros in the Rust side to match those definitions. While the semantics of const are implemented identically by many C and C++ compilers, e.g., clang, GCC, ARM C/C++ compiler, IBM ILE C/C++, etc. they are not necessarily implemented in this way on all of them. It is therefore also worth verifying that the semantics of the C toolchain used to compile the binary being linked against are compatible with those of the #[ffi_const].

## ffi_pure

The tracking issue for this feature is: #58329

The #[ffi_pure] attribute applies clang's pure attribute to foreign functions declarations.

That is, #[ffi_pure] functions shall have no effects except for its return value, which shall not change across two consecutive function calls with the same parameters.

Applying the #[ffi_pure] attribute to a function that violates these requirements is undefined behavior.

This attribute enables Rust to perform common optimizations, like sub-expression elimination and loop optimizations. Some common examples of pure functions are strlen or memcmp.

These optimizations are only applicable when the compiler can prove that no program state observable by the #[ffi_pure] function has changed between calls of the function, which could alter the result. See also the #[ffi_const] attribute, which provides stronger guarantees regarding the allowable behavior of a function, enabling further optimization.

Pitfalls

A #[ffi_pure] function can read global memory through the function parameters (e.g. pointers), globals, etc. #[ffi_pure] functions are not referentially-transparent, and are therefore more relaxed than #[ffi_const] functions.

However, accessing global memory through volatile or atomic reads can violate the requirement that two consecutive function calls shall return the same value.

A pure function that returns unit has no effect on the abstract machine's state.

A #[ffi_pure] function must not diverge, neither via a side effect (e.g. a call to abort) nor by infinite loops.

When translating C headers to Rust FFI, it is worth verifying for which targets the pure attribute is enabled in those headers, and using the appropriate cfg macros in the Rust side to match those definitions. While the semantics of pure are implemented identically by many C and C++ compilers, e.g., clang, GCC, ARM C/C++ compiler, IBM ILE C/C++, etc. they are not necessarily implemented in this way on all of them. It is therefore also worth verifying that the semantics of the C toolchain used to compile the binary being linked against are compatible with those of the #[ffi_pure].

## fmt_debug

Controlling the behavior of fmt::Debug

The tracking issue for this feature is: #129709

## fn_align

Allows using #[align(...)] on function items

The tracking issue for this feature is: #82232

## fn_delegation

Support delegating implementation of functions to other already implemented functions.

The tracking issue for this feature is: #118212

## freeze_impls

Allows impls for the Freeze trait.

The tracking issue for this feature is: #121675

## frontmatter

The tracking issue for this feature is: #136889

The frontmatter feature allows an extra metadata block at the top of files for consumption by external tools. For example, it can be used by cargo-script files to specify dependencies.

#!/usr/bin/env -S cargo -Zscript
---
[dependencies]
libc = "0.2.172"
---
#![feature(frontmatter)]

fn main() {
    let x: libc::c_int = 1i32;
}
## fundamental

Allows using the #[fundamental] attribute.

The tracking issue for this feature is: #29635

## gen_blocks

Allows defining gen blocks and gen fn.

The tracking issue for this feature is: #117078

## generic_assert

Outputs useful assert! messages

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## generic_const_exprs

Allows non-trivial generic constants which have to have wfness manually propagated to callers

The tracking issue for this feature is: #76560

## generic_const_items

Allows generic parameters and where-clauses on free & associated const items.

The tracking issue for this feature is: #113521

## generic_const_parameter_types

Allows the type of const generics to depend on generic parameters

The tracking issue for this feature is: #137626

## generic_pattern_types

Allows any generic constants being used as pattern type range ends

The tracking issue for this feature is: #136574

## global_registration

Allows registering static items globally, possibly across crates, to iterate over at runtime.

The tracking issue for this feature is: #125119

## guard_patterns

Allows using guards in patterns.

The tracking issue for this feature is: #129967

## half_open_range_patterns_in_slices

The tracking issue for this feature is: #67264 It is a future part of the exclusive_range_pattern feature, tracked at #37854.

This feature allow using top-level half-open range patterns in slices.

#![feature(half_open_range_patterns_in_slices)]

fn main() {
    let xs = [13, 1, 5, 2, 3, 1, 21, 8];
    let [a @ 3.., b @ ..3, c @ 4..6, ..] = xs else { return; };
}
Note that this feature is not required if the patterns are wrapped between parenthesis.

fn main() {
    let xs = [13, 1];
    let [(a @ 3..), c] = xs else { return; };
}
## hexagon_target_feature

The tracking issue for this feature is: #44839

## if_let_guard

Allows if let guard in match arms.

The tracking issue for this feature is: #51114

## impl_trait_in_assoc_type

Allows impl Trait to be used inside associated types (RFC 2515).

The tracking issue for this feature is: #63063

## impl_trait_in_bindings

Allows impl Trait in bindings (let).

The tracking issue for this feature is: #63065

## impl_trait_in_fn_trait_return

Allows impl Trait as output type in Fn traits in return position of functions.

The tracking issue for this feature is: #99697

## import_trait_associated_functions

The tracking issue for this feature is: #134691

This feature allows importing associated functions and constants from traits and then using them like regular items.

#![feature(import_trait_associated_functions)]

use std::ops::Add::add;

fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6];
    let sum = numbers.into_iter().reduce(add); // instead of `.reduce(Add:add)`

    assert_eq!(sum, Some(21));
}
## inherent_associated_types

Allows associated types in inherent impls.

The tracking issue for this feature is: #8995

intra-doc-pointers

The tracking issue for this feature is: #80896

Rustdoc does not currently allow disambiguating between *const and *mut, and raw pointers in intra-doc links are unstable until it does.

## intra_doc_pointers
//! [pointer::add]
## intrinsics

The tracking issue for this feature is: None.

Intrinsics are rarely intended to be stable directly, but are usually exported in some sort of stable manner. Prefer using the stable interfaces to the intrinsic directly when you can.

Intrinsics with fallback logic

Many intrinsics can be written in pure rust, albeit inefficiently or without supporting some features that only exist on some backends. Backends can simply not implement those intrinsics without causing any code miscompilations or failures to compile. All intrinsic fallback bodies are automatically made cross-crate inlineable (like #[inline]) by the codegen backend, but not the MIR inliner.

#![feature(intrinsics)]
#![allow(internal_features)]

#[rustc_intrinsic]
const unsafe fn const_deallocate(_ptr: *mut u8, _size: usize, _align: usize) {}
Since these are just regular functions, it is perfectly ok to create the intrinsic twice:

#![feature(intrinsics)]
#![allow(internal_features)]

#[rustc_intrinsic]
const unsafe fn const_deallocate(_ptr: *mut u8, _size: usize, _align: usize) {}

mod foo {
    #[rustc_intrinsic]
    const unsafe fn const_deallocate(_ptr: *mut u8, _size: usize, _align: usize) {
        panic!("noisy const dealloc")
    }
}

The behaviour on backends that override the intrinsic is exactly the same. On other backends, the intrinsic behaviour depends on which implementation is called, just like with any regular function.

Intrinsics lowered to MIR instructions

Various intrinsics have native MIR operations that they correspond to. Instead of requiring backends to implement both the intrinsic and the MIR operation, the lower_intrinsics pass will convert the calls to the MIR operation. Backends do not need to know about these intrinsics at all. These intrinsics only make sense without a body, and can be declared as a #[rustc_intrinsic]. The body is never used as the lowering pass implements support for all backends, so we never have to use the fallback logic.

Intrinsics without fallback logic

These must be implemented by all backends.

#[rustc_intrinsic] declarations

These are written without a body:

#![feature(intrinsics)]
#![allow(internal_features)]

#[rustc_intrinsic]
pub fn abort() -> !;
## lahfsahf_target_feature

The tracking issue for this feature is: #44839

## lang_items

The tracking issue for this feature is: None.

The rustc compiler has certain pluggable operations, that is, functionality that isn't hard-coded into the language, but is implemented in libraries, with a special marker to tell the compiler it exists. The marker is the attribute #[lang = "..."] and there are various different values of ..., i.e. various different 'lang items'. Most of them can only be defined once.

Lang items are loaded lazily by the compiler; e.g. if one never uses Box then there is no need to define a function for exchange_malloc. rustc will emit an error when an item is needed but not found in the current crate or any that it depends on.

Some features provided by lang items:

overloadable operators via traits: the traits corresponding to the ==, <, dereferencing (*) and + (etc.) operators are all marked with lang items; those specific four are eq, partial_ord, deref/deref_mut, and add respectively.
panicking: the panic and panic_impl lang items, among others.
stack unwinding: the lang item eh_personality is a function used by the failure mechanisms of the compiler. This is often mapped to GCC's personality function (see the std implementation for more information), but programs which don't trigger a panic can be assured that this function is never called. Additionally, a eh_catch_typeinfo static is needed for certain targets which implement Rust panics on top of C++ exceptions.
the traits in core::marker used to indicate types of various kinds; e.g. lang items sized, sync and copy.
memory allocation, see below.
Most lang items are defined by core, but if you're trying to build an executable without the std crate, you might run into the need for lang item definitions.

Example: Implementing a Box

Box pointers require two lang items: one for the type itself and one for allocation. A freestanding program that uses the Box sugar for dynamic allocations via malloc and free:

#![feature(lang_items, core_intrinsics, rustc_private, panic_unwind, rustc_attrs)]
#![allow(internal_features)]
#![no_std]
#![no_main]

extern crate libc;
extern crate unwind;

use core::ffi::{c_int, c_void};
use core::intrinsics;
use core::panic::PanicInfo;
use core::ptr::NonNull;

pub struct Global; // the global allocator
struct Unique<T>(NonNull<T>);

#[lang = "owned_box"]
pub struct Box<T, A = Global>(Unique<T>, A);

impl<T> Box<T> {
    pub fn new(x: T) -> Self {
        #[rustc_box]
        Box::new(x)
    }
}

impl<T, A> Drop for Box<T, A> {
    fn drop(&mut self) {
        unsafe {
            libc::free(self.0.0.as_ptr() as *mut c_void);
        }
    }
}

#[lang = "exchange_malloc"]
unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {
    let p = libc::malloc(size) as *mut u8;

    // Check if `malloc` failed:
    if p.is_null() {
        intrinsics::abort();
    }

    p
}

#[no_mangle]
extern "C" fn main(_argc: c_int, _argv: *const *const u8) -> c_int {
    let _x = Box::new(1);

    0
}

#[lang = "eh_personality"]
fn rust_eh_personality() {}

#[panic_handler]
fn panic_handler(_info: &PanicInfo) -> ! { intrinsics::abort() }
Note the use of abort: the exchange_malloc lang item is assumed to return a valid pointer, and so needs to do the check internally.

List of all language items

An up-to-date list of all language items can be found here in the compiler code.

## large_assignments

Allows setting the threshold for the large_assignments lint.

The tracking issue for this feature is: #83518

## lazy_type_alias

Allow to have type alias types for inter-crate use.

The tracking issue for this feature is: #112792

## link_arg_attribute

The tracking issue for this feature is: #99427

The link_arg_attribute feature allows passing arguments into the linker from inside of the source code. Order is preserved for link attributes as they were defined on a single extern block:

#![feature(link_arg_attribute)]

#[link(kind = "link-arg", name = "--start-group")]
#[link(kind = "static", name = "c")]
#[link(kind = "static", name = "gcc")]
#[link(kind = "link-arg", name = "--end-group")]
extern "C" {}
## link_cfg

This feature is internal to the Rust compiler and is not intended for general use.

## link_llvm_intrinsics

Allows using #[link_name="llvm.*"].

The tracking issue for this feature is: #29602

## linkage

Allows using the #[linkage = ".."] attribute.

The tracking issue for this feature is: #29603

## loongarch_target_feature

The tracking issue for this feature is: #44839

## loop_match

The tracking issue for this feature is: #132306

The #[loop_match] and #[const_continue] attributes can be used to improve the code generation of logic that fits this shape:

loop {
    state = 'blk: {
        match state {
            State::A => {
                break 'blk State::B
            }
            State::B => { /* ... */ }
            /* ... */
        }
    }
}
Here the loop itself can be annotated with #[loop_match], and any break 'blk with #[const_continue] if the value is know at compile time:

#[loop_match]
loop {
    state = 'blk: {
        match state {
            State::A => {
                #[const_continue]
                break 'blk State::B
            }
            State::B => { /* ... */ }
            /* ... */
        }
    }
}
The observable behavior of this loop is exactly the same as without the extra attributes. The difference is in the generated output: normally, when the state is A, control flow moves from the A branch, back to the top of the loop, then to the B branch. With the attributes, The A branch will immediately jump to the B branch.

Removing the indirection can be beneficial for stack usage and branch prediction, and enables other optimizations by clearly splitting out the control flow paths that your program will actually use.

## m68k_target_feature

The tracking issue for this feature is: #134328

## macro_attr

Allow macro_rules! attribute rules

The tracking issue for this feature is: #143547

## macro_derive

Allow macro_rules! derive rules

The tracking issue for this feature is: #143549

## macro_metavar_expr

The tracking issue for this feature is: #83527

This feature is not to be confused with macro_metavar_expr_concat.

## macro_metavar_expr_concat

The tracking issue for this feature is: #124225

In stable Rust, there is no way to create new identifiers by joining identifiers to literals or other identifiers without using procedural macros such as paste. #![feature(macro_metavar_expr_concat)] introduces a way to do this, using the concat metavariable expression.

This feature uses the syntax from macro_metavar_expr but is otherwise independent. It replaces the since-removed unstable feature concat_idents.

This is an experimental feature; it and its syntax will require a RFC before stabilization.

Overview

#![feature(macro_metavar_expr_concat)] provides the concat metavariable expression for creating new identifiers:

#![feature(macro_metavar_expr_concat)]

macro_rules! create_some_structs {
    ($name:ident) => {
        pub struct ${ concat(First, $name) };
        pub struct ${ concat(Second, $name) };
        pub struct ${ concat(Third, $name) };
    }
}

create_some_structs!(Thing);
This macro invocation expands to:

pub struct FirstThing;
pub struct SecondThing;
pub struct ThirdThing;
Syntax

This feature builds upon the metavariable expression syntax ${ .. } as specified in RFC 3086 (macro_metavar_expr). concat is available like ${ concat(items) }, where items is a comma separated sequence of idents and/or literals.

Examples

Create a function or method with a concatenated name

#![feature(macro_metavar_expr_concat)]

macro_rules! make_getter {
    ($name:ident, $field: ident, $ret:ty) => {
        impl $name {
            pub fn ${ concat(get_, $field) }(&self) -> &$ret {
                &self.$field
            }
        }
    }
}

pub struct Thing {
    description: String,
}

make_getter!(Thing, description, String);
This expands to:

pub struct Thing {
    description: String,
}

impl Thing {
    pub fn get_description(&self) -> &String {
        &self.description
    }
}
Create names for macro generated tests

#![feature(macro_metavar_expr_concat)]

macro_rules! test_math {
    ($integer:ident) => {
        #[test]
        fn ${ concat(test_, $integer, _, addition) } () {
            let a: $integer = 73;
            let b: $integer = 42;
            assert_eq!(a + b, 115)
        }

        #[test]
        fn ${ concat(test_, $integer, _, subtraction) } () {
            let a: $integer = 73;
            let b: $integer = 42;
            assert_eq!(a - b, 31)
        }
    }
}

test_math!(i32);
test_math!(u64);
test_math!(u128);
Running this returns the following output:

running 6 tests
test test_i32_subtraction ... ok
test test_i32_addition ... ok
test test_u128_addition ... ok
test test_u128_subtraction ... ok
test test_u64_addition ... ok
test test_u64_subtraction ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
## marker_trait_attr

The tracking issue for this feature is: #29864

Normally, Rust keeps you from adding trait implementations that could overlap with each other, as it would be ambiguous which to use. This feature, however, carves out an exception to that rule: a trait can opt-in to having overlapping implementations, at the cost that those implementations are not allowed to override anything (and thus the trait itself cannot have any associated items, as they're pointless when they'd need to do the same thing for every type anyway).

#![feature(marker_trait_attr)]

#[marker] trait CheapToClone: Clone {}

impl<T: Copy> CheapToClone for T {}

// These could potentially overlap with the blanket implementation above,
// so are only allowed because CheapToClone is a marker trait.
impl<T: CheapToClone, U: CheapToClone> CheapToClone for (T, U) {}
impl<T: CheapToClone> CheapToClone for std::ops::Range<T> {}

fn cheap_clone<T: CheapToClone>(t: T) -> T {
    t.clone()
}
This is expected to replace the unstable overlapping_marker_traits feature, which applied to all empty traits (without needing an opt-in).

## min_generic_const_args

Enables the generic const args MVP (only bare paths, not arbitrary computation).

The tracking issue for this feature is: #132980

## min_specialization

A minimal, sound subset of specialization intended to be used by the standard library until the soundness issues with specialization are fixed.

The tracking issue for this feature is: #31844

## mips_target_feature

The tracking issue for this feature is: #44839

## more_maybe_bounds

Allows using ?Trait trait bounds in more contexts.

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## more_qualified_paths

The more_qualified_paths feature can be used in order to enable the use of qualified paths in patterns.

The tracking issue for this feature is: #86935.

Example

#![feature(more_qualified_paths)]

fn main() {
    // destructure through a qualified path
    let <Foo as A>::Assoc { br } = StructStruct { br: 2 };
}

struct StructStruct {
    br: i8,
}

struct Foo;

trait A {
    type Assoc;
}

impl A for Foo {
    type Assoc = StructStruct;
}
## movrs_target_feature

The tracking issue for this feature is: #137976

## multiple_supertrait_upcastable

Allows the multiple_supertrait_upcastable lint.

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## must_not_suspend

Allows the #[must_not_suspend] attribute.

The tracking issue for this feature is: #83310

## mut_ref

Allows mut ref and mut ref mut identifier patterns.

The tracking issue for this feature is: #123076

## naked_functions_rustic_abi

Allows using #[naked] on extern "Rust" functions.

The tracking issue for this feature is: #138997

## naked_functions_target_feature

Allows using #[target_feature(enable = "...")] on #[naked] on functions.

The tracking issue for this feature is: #138568

## native_link_modifiers_as_needed

The tracking issue for this feature is: #81490

The native_link_modifiers_as_needed feature allows you to use the as-needed modifier.

as-needed is only compatible with the dynamic and framework linking kinds. Using any other kind will result in a compiler error.

+as-needed means that the library will be actually linked only if it satisfies some undefined symbols at the point at which it is specified on the command line, making it similar to static libraries in this regard.

This modifier translates to --as-needed for ld-like linkers, and to -dead_strip_dylibs / -needed_library / -needed_framework for ld64. The modifier does nothing for linkers that don't support it (e.g. link.exe).

The default for this modifier is unclear, some targets currently specify it as +as-needed, some do not. We may want to try making +as-needed a default for all targets.

## needs_panic_runtime

Allows declaring with #![needs_panic_runtime] that a panic runtime is needed.

The tracking issue for this feature is: #32837

## negative_bounds

Allow negative trait bounds. This is an internal-only feature for testing the trait solver!

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## negative_impls

The tracking issue for this feature is #68318.

With the feature gate negative_impls, you can write negative impls as well as positive ones:

#![feature(negative_impls)]
trait DerefMut { }
impl<T: ?Sized> !DerefMut for &T { }
Negative impls indicate a semver guarantee that the given trait will not be implemented for the given types. Negative impls play an additional purpose for auto traits, described below.

Negative impls have the following characteristics:

They do not have any items.
They must obey the orphan rules as if they were a positive impl.
They cannot "overlap" with any positive impls.
Semver interaction

It is a breaking change to remove a negative impl. Negative impls are a commitment not to implement the given trait for the named types.

Orphan and overlap rules

Negative impls must obey the same orphan rules as a positive impl. This implies you cannot add a negative impl for types defined in upstream crates and so forth.

Similarly, negative impls cannot overlap with positive impls, again using the same "overlap" check that we ordinarily use to determine if two impls overlap. (Note that positive impls typically cannot overlap with one another either, except as permitted by specialization.)

Interaction with auto traits

Declaring a negative impl impl !SomeAutoTrait for SomeType for an auto-trait serves two purposes:

as with any trait, it declares that SomeType will never implement SomeAutoTrait;
it disables the automatic SomeType: SomeAutoTrait impl that would otherwise have been generated.
Note that, at present, there is no way to indicate that a given type does not implement an auto trait but that it may do so in the future. For ordinary types, this is done by simply not declaring any impl at all, but that is not an option for auto traits. A workaround is that one could embed a marker type as one of the fields, where the marker type is !AutoTrait.

Immediate uses

Negative impls are used to declare that &T: !DerefMut and &mut T: !Clone, as required to fix the soundness of Pin described in #66544.

This serves two purposes:

For proving the correctness of unsafe code, we can use that impl as evidence that no DerefMut or Clone impl exists.
It prevents downstream crates from creating such impls.
## never_patterns

Allows the ! pattern.

The tracking issue for this feature is: #118155

## never_type

Allows the ! type. Does not imply 'exhaustive_patterns' (below) any more.

The tracking issue for this feature is: #35121

## never_type_fallback

Allows diverging expressions to fall back to ! rather than ().

The tracking issue for this feature is: #65992

## new_range

The tracking issue for this feature is: #123741

Switch the syntaxes a.., a..b, and a..=b to resolve the new range types.

## no_core

Allows #![no_core].

The tracking issue for this feature is: #29639

## non_exhaustive_omitted_patterns_lint

Allows using the non_exhaustive_omitted_patterns lint.

The tracking issue for this feature is: #89554

## non_lifetime_binders

Allows for<T> binders in where-clauses

The tracking issue for this feature is: #108185

## nvptx_target_feature

The tracking issue for this feature is: #44839

## offset_of_enum

The tracking issue for this feature is: #120141

When the offset_of_enum feature is enabled, the offset_of! macro may be used to obtain the offsets of fields of enums; to express this, enum variants may be traversed as if they were fields. Variants themselves do not have an offset, so they cannot appear as the last path component.

#![feature(offset_of_enum)]
use std::mem;

#[repr(u8)]
enum Enum {
    A(u8, u16),
    B { one: u8, two: u16 },
}

assert_eq!(mem::offset_of!(Enum, A.0), 1);
assert_eq!(mem::offset_of!(Enum, B.two), 2);

assert_eq!(mem::offset_of!(Option<&u8>, Some.0), 0);
## offset_of_slice

The tracking issue for this feature is: #126151

When the offset_of_slice feature is enabled, the offset_of! macro may be used to determine the offset of fields whose type is [T], that is, a slice of dynamic size.

In general, fields whose type is dynamically sized do not have statically known offsets because they do not have statically known alignments. However, [T] has the same alignment as T, so it specifically may be allowed.

#![feature(offset_of_slice)]

#[repr(C)]
pub struct Struct {
    head: u32,
    tail: [u8],
}

fn main() {
    assert_eq!(std::mem::offset_of!(Struct, tail), 4);
}
## optimize_attribute

Allows using #[optimize(X)].

The tracking issue for this feature is: #54882

## panic_runtime

Allows using the #![panic_runtime] attribute.

The tracking issue for this feature is: #32837

## patchable_function_entry

Allows specifying nop padding on functions for dynamic patching.

The tracking issue for this feature is: #123115

## pattern_complexity_limit

Set the maximum pattern complexity allowed (not limited by default).

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## pattern_types

Allows using pattern types.

The tracking issue for this feature is: #123646

## pin_ergonomics

Experimental features that make Pin more ergonomic.

The tracking issue for this feature is: #130494

postfix-match

postfix-match adds the feature for matching upon values postfix the expressions that generate the values.

The tracking issue for this feature is: #121618.

## postfix_match

enum Foo {
    Bar,
    Baz
}

fn get_foo() -> Foo {
    Foo::Bar
}

get_foo().match {
    Foo::Bar => {},
    Foo::Baz => panic!(),
}
## powerpc_target_feature

The tracking issue for this feature is: #44839

## prelude_import

Allows using #[prelude_import] on glob use items.

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## prfchw_target_feature

The tracking issue for this feature is: #44839

## proc_macro_hygiene

Allows macro attributes on expressions, statements and non-inline modules.

The tracking issue for this feature is: #54727

## profiler_runtime

The tracking issue for this feature is: #42524.

## raw_dylib_elf

Allows the use of raw-dylibs on ELF platforms

The tracking issue for this feature is: #135694

## reborrow

The tracking issue for this feature is: #145612

## ref_pat_eat_one_layer_2024

The tracking issue for this feature is: #123076

This feature is incomplete and not yet intended for general use.

This implements experimental, Edition-dependent match ergonomics under consideration for inclusion in Rust, allowing & patterns in more places. For example:

#![feature(ref_pat_eat_one_layer_2024)]
#![allow(incomplete_features)]

// `&` can match against a `ref` binding mode instead of a reference type:
let (x, &y) = &(0, 1);
has_type::<&u8>(x);
has_type::<u8>(y);

// `&` can match against `&mut` references:
let &z = &mut 2;
has_type::<u8>(z);
For specifics, see the corresponding typing rules for Editions 2021 and earlier and for Editions 2024 and later. For more information on binding modes, see The Rust Reference.

For alternative experimental match ergonomics, see the feature ref_pat_eat_one_layer_2024_structural.

## ref_pat_eat_one_layer_2024_structural

The tracking issue for this feature is: #123076

This feature is incomplete and not yet intended for general use.

This implements experimental, Edition-dependent match ergonomics under consideration for inclusion in Rust, allowing & patterns in more places. For example:

#![feature(ref_pat_eat_one_layer_2024_structural)]
#![allow(incomplete_features)]

// `&` can match against a `ref` binding mode instead of a reference type:
let (x, &y) = &(0, 1);
has_type::<&u8>(x);
has_type::<u8>(y);

// `&` can match against `&mut` references:
let &z = &mut 2;
has_type::<u8>(z);
For specifics, see the corresponding typing rules for Editions 2021 and earlier and for Editions 2024 and later. For more information on binding modes, see The Rust Reference.

For alternative experimental match ergonomics, see the feature ref_pat_eat_one_layer_2024.

## register_tool

The tracking issue for this feature is: #66079

The register_tool language feature informs the compiler that attributes in your code are meant to be used with tools other than the compiler itself. This can be useful if your code has semantic meaning without the external tool, but enables additional features when the tool is present.

register_tool also allows configuring lint levels for external tools.

Tool attributes are only meant for ignorable attributes. If your code changes meaning when the attribute is present, it should not use a tool attribute (because it cannot be compiled with anything other than the external tool, and in a sense is a fork of the language).

#![register_tool(tool)] is an attribute, and is only valid at the crate root. Attributes using the registered tool are checked for valid syntax, and lint attributes are checked to be in a valid format. However, the compiler cannot validate the semantics of the attribute, nor can it tell whether the configured lint is present in the external tool.

Semantically, clippy::*, rustdoc::*, and rustfmt::* lints and attributes all behave as if #![register_tool(clippy, rustdoc, rustfmt)] were injected into the crate root, except that the rustdoc namespace can only be used for lints, not for attributes. When compiling with -Z unstable-features, rustc::* lints can also be used. Like rustdoc, the rustc namespace can only be used with lints, not attributes.

The compiler will emit an error if it encounters a lint/attribute whose namespace isn't a registered tool.

Tool namespaces cannot be nested; register_tool(main_tool::subtool) is an error.

Examples

Tool attributes:

#![feature(register_tool)]
#![register_tool(c2rust)]

// Mark which C header file this module was generated from.
#[c2rust::header_src = "operations.h"]
pub mod operations_h {
    use std::ffi::c_int;

    // Mark which source line this struct was generated from.
    #[c2rust::src_loc = "11:0"]
    pub struct Point {
        pub x: c_int,
        pub y: c_int,
    }
}
Tool lints:

#![feature(register_tool)]
#![register_tool(bevy)]
#![deny(bevy::duplicate_bevy_dependencies)]
## repr_simd

Allows repr(simd) and importing the various simd intrinsics.

The tracking issue for this feature is: #27731

## return_type_notation

Allows bounding the return type of AFIT/RPITIT.

The tracking issue for this feature is: #109417

## riscv_target_feature

The tracking issue for this feature is: #44839

## rtm_target_feature

The tracking issue for this feature is: #44839

## rust_cold_cc

Allows extern "rust-cold".

The tracking issue for this feature is: #97544

## rustc_allow_const_fn_unstable

Allows using #[rustc_allow_const_fn_unstable]. This is an attribute on const fn for the same purpose as #[allow_internal_unstable].

The tracking issue for this feature is: #69399

## rustc_attrs

This feature has no tracking issue, and is therefore internal to the compiler, not being intended for general use.

Note: rustc_attrs enables many rustc-internal attributes and this page only discuss a few of them.

The rustc_attrs feature allows debugging rustc type layouts by using #[rustc_layout(...)] to debug layout at compile time (it even works with cargo check) as an alternative to rustc -Z print-type-sizes that is way more verbose.

Options provided by #[rustc_layout(...)] are debug, size, align, abi. Note that it only works on sized types without generics.

Examples

#![feature(rustc_attrs)]

#[rustc_layout(abi, size)]
pub enum X {
    Y(u8, u8, u8),
    Z(isize),
}
When that is compiled, the compiler will error with something like

error: abi: Aggregate { sized: true }
 --> src/lib.rs:4:1
  |
4 | / pub enum T {
5 | |     Y(u8, u8, u8),
6 | |     Z(isize),
7 | | }
  | |_^

error: size: Size { raw: 16 }
 --> src/lib.rs:4:1
  |
4 | / pub enum T {
5 | |     Y(u8, u8, u8),
6 | |     Z(isize),
7 | | }
  | |_^

error: aborting due to 2 previous errors
## rustc_private

The tracking issue for this feature is: #27812

This feature allows access to unstable internal compiler crates such as rustc_driver.

The presence of this feature changes the way the linkage format for dylibs is calculated in a way that is necessary for linking against dylibs that statically link std (such as rustc_driver). This makes this feature "viral" in linkage; its use in a given crate makes its use required in dependent crates which link to it (including integration tests, which are built as separate crates).

Common linker failures related to missing LLVM libraries

When using rustc-private with Official Toolchains

When using the rustc_private feature with official toolchains distributed via rustup, you'll need to install:

The rustc-dev component (provides compiler libraries)
The llvm-tools component (provides LLVM libraries needed for linking)
You can install these components using rustup:

rustup component add rustc-dev llvm-tools
Without the llvm-tools component, you may encounter linking errors like:

error: linking with `cc` failed: exit status: 1
  |
  = note: rust-lld: error: unable to find library -lLLVM-{version}
When using rustc-private with Custom Toolchains

For custom-built toolchains or environments not using rustup, different configuration may be required:

Ensure LLVM libraries are available in your library search paths
You might need to configure library paths explicitly depending on your LLVM installation
## rustdoc_internals

Allows using internal rustdoc features like doc(keyword).

The tracking issue for this feature is: #90418

## rustdoc_missing_doc_code_examples

Allows using the rustdoc::missing_doc_code_examples lint

The tracking issue for this feature is: #101730

## s390x_target_feature

The tracking issue for this feature is: #44839

## sanitize

The tracking issue for this feature is: #39699

The sanitize attribute can be used to selectively disable or enable sanitizer instrumentation in an annotated function. This might be useful to: avoid instrumentation overhead in a performance critical function, or avoid instrumenting code that contains constructs unsupported by given sanitizer.

The precise effect of this annotation depends on particular sanitizer in use. For example, with sanitize(thread = "off"), the thread sanitizer will no longer instrument non-atomic store / load operations, but it will instrument atomic operations to avoid reporting false positives and provide meaning full stack traces.

This attribute was previously named no_sanitize.

Examples

#![feature(sanitize)]

#[sanitize(address = "off")]
fn foo() {
  // ...
}
It is also possible to disable sanitizers for entire modules and enable them for single items or functions.

#![feature(sanitize)]

#[sanitize(address = "off")]
mod foo {
  fn unsanitized() {
    // ...
  }

  #[sanitize(address = "on")]
  fn sanitized() {
    // ...
  }
}
It's also applicable to impl blocks.

#![feature(sanitize)]

trait MyTrait {
  fn foo(&self);
  fn bar(&self);
}

#[sanitize(address = "off")]
impl MyTrait for () {
  fn foo(&self) {
    // ...
  }

  #[sanitize(address = "on")]
  fn bar(&self) {
    // ...
  }
}
## simd_ffi

Allows the use of SIMD types in functions declared in extern blocks.

The tracking issue for this feature is: #27731

## sized_hierarchy

Introduces a hierarchy of Sized traits (RFC 3729).

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## sparc_target_feature

The tracking issue for this feature is: #132783

## specialization

Allows specialization of implementations (RFC 1210).

The tracking issue for this feature is: #31844

## staged_api

Allows using the #[stable] and #[unstable] attributes.

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## static_align

Allows using #[rustc_align_static(...)] on static items.

The tracking issue for this feature is: #146177

## stmt_expr_attributes

Allows attributes on expressions and non-item statements.

The tracking issue for this feature is: #15701

## strict_provenance_lints

The tracking issue for this feature is: #95228

The strict_provenance_lints feature allows to enable the fuzzy_provenance_casts and lossy_provenance_casts lints. These lint on casts between integers and pointers, that are recommended against or invalid in the strict provenance model.

Example

#![feature(strict_provenance_lints)]
#![warn(fuzzy_provenance_casts)]

fn main() {
    let _dangling = 16_usize as *const u8;
    //~^ WARNING: strict provenance disallows casting integer `usize` to pointer `*const u8`
}
## string_deref_patterns

The tracking issue for this feature is: #87121

Note: This feature will be superseded by deref_patterns in the future.

This feature permits pattern matching String to &str through its Deref implementation.

#![feature(string_deref_patterns)]

pub enum Value {
    String(String),
    Number(u32),
}

pub fn is_it_the_answer(value: Value) -> bool {
    match value {
        Value::String("42") => true,
        Value::Number(42) => true,
        _ => false,
    }
}
Without this feature other constructs such as match guards have to be used.

pub fn is_it_the_answer(value: Value) -> bool {
    match value {
        Value::String(s) if s == "42" => true,
        Value::Number(42) => true,
        _ => false,
    }
}
## structural_match

Allows using #[structural_match] which indicates that a type is structurally matchable. FIXME: Subsumed by trait StructuralPartialEq, cannot move to removed until a library feature with the same name exists.

The tracking issue for this feature is: #31434

## super_let

Allows super let statements.

The tracking issue for this feature is: #139076

## supertrait_item_shadowing

Allows subtrait items to shadow supertrait items.

The tracking issue for this feature is: #89151

## target_feature_inline_always

Allows the use of target_feature when a function is marked inline(always).

The tracking issue for this feature is: #145574

## test_unstable_lint

Added for testing unstable lints; perma-unstable.

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## thread_local

Allows using #[thread_local] on static items.

The tracking issue for this feature is: #29594

## trait_alias

The tracking issue for this feature is: #41517

The trait_alias feature adds support for trait aliases. These allow aliases to be created for one or more traits (currently just a single regular trait plus any number of auto-traits), and used wherever traits would normally be used as either bounds or trait objects.

#![feature(trait_alias)]

trait Foo = std::fmt::Debug + Send;
trait Bar = Foo + Sync;

// Use trait alias as bound on type parameter.
fn foo<T: Foo>(v: &T) {
    println!("{:?}", v);
}

pub fn main() {
    foo(&1);

    // Use trait alias for trait objects.
    let a: &Bar = &123;
    println!("{:?}", a);
    let b = Box::new(456) as Box<dyn Foo>;
    println!("{:?}", b);
}
## transmute_generic_consts

Allows for transmuting between arrays with sizes that contain generic consts.

The tracking issue for this feature is: #109929

## transparent_unions

The tracking issue for this feature is #60405

The transparent_unions feature allows you mark unions as #[repr(transparent)]. A union may be #[repr(transparent)] in exactly the same conditions in which a struct may be #[repr(transparent)] (generally, this means the union must have exactly one non-zero-sized field). Some concrete illustrations follow.

#![feature(transparent_unions)]

// This union has the same representation as `f32`.
#[repr(transparent)]
union SingleFieldUnion {
    field: f32,
}

// This union has the same representation as `usize`.
#[repr(transparent)]
union MultiFieldUnion {
    field: usize,
    nothing: (),
}
For consistency with transparent structs, unions must have exactly one non-zero-sized field. If all fields are zero-sized, the union must not be #[repr(transparent)]:

#![feature(transparent_unions)]

// This (non-transparent) union is already valid in stable Rust:
pub union GoodUnion {
    pub nothing: (),
}

// Error: transparent union needs exactly one non-zero-sized field, but has 0
// #[repr(transparent)]
// pub union BadUnion {
//     pub nothing: (),
// }
The one exception is if the union is generic over T and has a field of type T, it may be #[repr(transparent)] even if T is a zero-sized type:

#![feature(transparent_unions)]

// This union has the same representation as `T`.
#[repr(transparent)]
pub union GenericUnion<T: Copy> { // Unions with non-`Copy` fields are unstable.
    pub field: T,
    pub nothing: (),
}

// This is okay even though `()` is a zero-sized type.
pub const THIS_IS_OKAY: GenericUnion<()> = GenericUnion { field: () };
Like transparent structs, a transparent union of type U has the same layout, size, and ABI as its single non-ZST field. If it is generic over a type T, and all its fields are ZSTs except for exactly one field of type T, then it has the same layout and ABI as T (even if T is a ZST when monomorphized).

Like transparent structs, transparent unions are FFI-safe if and only if their underlying representation type is also FFI-safe.

A union may not be eligible for the same nonnull-style optimizations that a struct or enum (with the same fields) are eligible for. Adding #[repr(transparent)] to union does not change this. To give a more concrete example, it is unspecified whether size_of::<T>() is equal to size_of::<Option<T>>(), where T is a union (regardless of whether or not it is transparent). The Rust compiler is free to perform this optimization if possible, but is not required to, and different compiler versions may differ in their application of these optimizations.

## trivial_bounds

Allows inconsistent bounds in where clauses.

The tracking issue for this feature is: #48214

## try_blocks

The tracking issue for this feature is: #31436

The try_blocks feature adds support for try blocks. A try block creates a new scope one can use the ? operator in.

#![feature(try_blocks)]

use std::num::ParseIntError;

let result: Result<i32, ParseIntError> = try {
    "1".parse::<i32>()?
        + "2".parse::<i32>()?
        + "3".parse::<i32>()?
};
assert_eq!(result, Ok(6));

let result: Result<i32, ParseIntError> = try {
    "1".parse::<i32>()?
        + "foo".parse::<i32>()?
        + "3".parse::<i32>()?
};
assert!(result.is_err());
## type_alias_impl_trait

The tracking issue for this feature is: #63063

This feature is not to be confused with trait_alias or impl_trait_in_assoc_type.

What is impl Trait?

impl Trait in return position is useful for declaring types that are constrained by traits, but whose concrete type should be hidden:

use std::fmt::Debug;

fn new() -> impl Debug {
    42
}

fn main() {
    let thing = new();
    // What actually is a `thing`?
    // No idea but we know it implements `Debug`, so we can debug print it
    println!("{thing:?}");
}
See the reference for more information about impl Trait in return position.

type_alias_impl_trait

However, we might want to use an impl Trait in multiple locations but actually use the same concrete type everywhere while keeping it hidden. This can be useful in libraries where you want to hide implementation details.

The #[define_opaque] attribute must be used to explicitly list opaque items constrained by the item it's on.

#![feature(type_alias_impl_trait)]
trait Trait {}

struct MyType;

impl Trait for MyType {}

type Alias = impl Trait;

#[define_opaque(Alias)] // To constrain the type alias to `MyType`
fn new() -> Alias {
    MyType
}

#[define_opaque(Alias)] // So we can name the concrete type inside this item
fn main() {
    let thing: MyType = new();
}

// It can be a part of a struct too
struct HaveAlias {
    stuff: String,
    thing: Alias,
}
In this example, the concrete type referred to by Alias is guaranteed to be the same wherever Alias occurs.

Originally this feature included type aliases as an associated type of a trait. In #110237 this was split off to impl_trait_in_assoc_type.

type_alias_impl_trait in argument position.

Note that using Alias as an argument type is not the same as argument-position impl Trait, as Alias refers to a unique type, whereas the concrete type for argument-position impl Trait is chosen by the caller.

// this...
pub fn take_alias(x: Alias) {
    // ...
}

// ...is *not* the same as
pub fn take_impl(x: impl Trait) {
    // ...
}
// a user's crate using the trait and type alias
struct UserType;
impl Trait for UserType {}

let x = UserType;
take_alias(x);
// ERROR expected opaque type, found `UserType`
// this function *actually* takes a `MyType` as is constrained in `new`

let x = UserType;
take_impl(x);
// OK

let x = new();
take_alias(x);
// OK

let x = new();
take_impl(x);
// OK
Note that the user cannot use #[define_opaque(Alias)] to reify the opaque type because only the crate where the type alias is declared may do so. But if this happened in the same crate and the opaque type was reified, they'd get a familiar error: "expected MyType, got UserType".

## type_changing_struct_update

The tracking issue for this feature is: #86555

This implements RFC2528. When turned on, you can create instances of the same struct that have different generic type or lifetime parameters.

#![allow(unused_variables, dead_code)]
#![feature(type_changing_struct_update)]

fn main () {
    struct Foo<T, U> {
        field1: T,
        field2: U,
    }

    let base: Foo<String, i32> = Foo {
        field1: String::from("hello"),
        field2: 1234,
    };
    let updated: Foo<f64, i32> = Foo {
        field1: 3.14,
        ..base
    };
}
## unboxed_closures

The tracking issue for this feature is #29625

See Also: fn_traits

The unboxed_closures feature allows you to write functions using the "rust-call" ABI, required for implementing the Fn* family of traits. "rust-call" functions must have exactly one (non self) argument, a tuple representing the argument list.

#![feature(unboxed_closures)]

extern "rust-call" fn add_args(args: (u32, u32)) -> u32 {
    args.0 + args.1
}

fn main() {}
## unqualified_local_imports

Helps with formatting for group_imports = "StdExternalCrate".

The tracking issue for this feature is: #138299

## unsafe_binders

Allows using unsafe<'a> &'a T unsafe binder types.

The tracking issue for this feature is: #130516

## unsafe_fields

Allows declaring fields unsafe.

The tracking issue for this feature is: #132922

## unsized_const_params

Allows const generic parameters to be defined with types that are not Sized, e.g. fn foo<const N: [u8]>() {.

The tracking issue for this feature is: #95174

## unsized_fn_params

Allows unsized fn parameters.

The tracking issue for this feature is: #48055

## used_with_arg

Allows using the #[used(linker)] (or #[used(compiler)]) attribute.

The tracking issue for this feature is: #93798

## wasm_target_feature

The tracking issue for this feature is: #44839

## where_clause_attrs

Allows use of attributes in where clauses.

The tracking issue for this feature is: #115590

## with_negative_coherence

Use for stable + negative coherence and strict coherence depending on trait's rustc_strict_coherence value.

This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.

## x86_amx_intrinsics

Allows use of x86 AMX target-feature attributes and intrinsics

The tracking issue for this feature is: #126622

## x87_target_feature

The tracking issue for this feature is: #44839

## xop_target_feature

Allows use of the xop target-feature

The tracking issue for this feature is: #127208

## yeet_expr

The tracking issue for this feature is: #96373

The yeet_expr feature adds support for do yeet expressions, which can be used to early-exit from a function or try block.

These are highly experimental, thus the placeholder syntax.

#![feature(yeet_expr)]

fn foo() -> Result<String, i32> {
    do yeet 4;
}
assert_eq!(foo(), Err(4));

fn bar() -> Option<String> {
    do yeet;
}
assert_eq!(bar(), None);
## yield_expr

The tracking issue for this feature is: #43122
