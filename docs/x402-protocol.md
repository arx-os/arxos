# x402 Protocol Specification
## HTTP 402 Payment Required for Spatial Data Access

**Version**: 1.0  
**Date**: 2025-12-09  
**Status**: Final

---

## Overview

The x402 protocol enables micropayments for accessing building spatial data through ArxOS. It extends HTTP 402 (Payment Required) with on-chain payment verification via the ArxPaymentRouter smart contract.

## Core Principles

1. **Standard HTTP**: Uses existing HTTP 402 status code
2. **Atomic**: Payment proof = data access (no race conditions)
3. **Verifiable**: Server checks blockchain before releasing data
4. **Non-custodial**: Users retain full control of funds
5. **Efficient**: One-time payment for session-based access

---

## Protocol Flow

### 1. Initial Request (No Payment)

**Client Request**:
```http
GET /buildings/ps-118/floors/2 HTTP/1.1
Host: api.arxos.io
Authorization: Bearer <jwt_token>
```

**Server Response** (Payment Required):
```http
HTTP/1.1 402 Payment Required
Content-Type: application/json
X-Payment-Required: true
X-Payment-Address: 0xPaymentRouterAddress
X-Payment-Amount: 100000000000000000
X-Payment-Building-Id: ps-118
X-Payment-Nonce: 550e8400e29b41d4a716446655440000
X-Payment-Expires: 1702123456

{
  "error": "payment_required",
  "message": "This building requires payment for access",
  "payment": {
    "contract": "0xPaymentRouterAddress",
    "amount": "100000000000000000",
    "token": "ARXO",
    "building_id": "ps-118",
    "nonce": "550e8400e29b41d4a716446655440000",
    "expires_at": 1702123456
  }
}
```

### 2. Execute Payment (On-Chain)

**Client Action**:
```solidity
// Approve ARXO spending (if not already approved)
arxoToken.approve(paymentRouterAddress, amount);

// Execute payment
ArxPaymentRouter.payForAccess(
    "ps-118",           // buildingId
    100000000000000000, // amount (0.1 ARXO)
    0x550e8400...       // nonce
);
```

**Smart Contract Event**:
```solidity
event AccessPaid(
    string indexed buildingId,
    address indexed payer,
    uint256 amount,
    bytes32 indexed nonce,
    uint256 timestamp
);
```

### 3. Retry Request with Proof

**Client Request**:
```http
GET /buildings/ps-118/floors/2 HTTP/1.1
Host: api.arxos.io
Authorization: Bearer <jwt_token>
X-Payment-Tx: 0xTransactionHashFromStep2
X-Payment-Nonce: 550e8400e29b41d4a716446655440000
```

**Server Action**:
1. Extract payment transaction hash and nonce
2. Query blockchain for `AccessPaid` event
3. Verify:
   - Transaction exists and is confirmed
   - Nonce matches request
   - Amount is sufficient
   - Payer address matches JWT identity
   - Payment not expired (1 hour TTL)
   - Nonce not previously used for data delivery

**Server Response** (Success):
```http
HTTP/1.1 200 OK
Content-Type: application/json
X-Payment-Verified: true
X-Payment-Tx: 0x...

{
  "building": {
    "id": "ps-118",
    "floors": [...]
  }
}
```

---

## Payment Distribution

All payments through ArxPaymentRouter follow the 70/10/10/10 split:

- **70%** ‚Üí Building Wallet (registered building owner)
- **10%** ‚Üí Building Twin Fund (for future redistribution)
- **10%** ‚Üí Maintainers/Open-Source Vault (RPGF)
- **10%** ‚Üí ArxOS LLC Treasury

---

## Security Considerations

### Nonce Management
- Nonces are UUIDs generated by server
- One-time use only (prevents replay)
- Expired after 1 hour
- Server tracks used nonces in database

### Payment Verification
```typescript
interface PaymentVerification {
    tx_hash: string;
    block_number: number;
    building_id: string;
    payer: address;
    amount: bigint;
    nonce: bytes32;
    timestamp: number;
    confirmations: number;  // Require >= 2 confirmations
}
```

### Attack Prevention

**Scenario**: Malicious client requests data without payment
- **Mitigation**: Server always checks blockchain before releasing data

**Scenario**: Payment front-running
- **Mitigation**: Nonce ties payment to specific request, wrong payer can't steal access

**Scenario**: Double-spending nonce
- **Mitigation**: Server tracks used nonces, rejects duplicates

**Scenario**: Expired payment proof
- **Mitigation**: 1-hour TTL on payments, server rejects old proofs

---

## Implementation Examples

### Rust Client (CLI)

```rust
use ethers::prelude::*;
use reqwest;

pub async fn fetch_with_payment(
    building_id: &str,
    payment_router: &ArxPaymentRouter<Provider<Http>>,
    signer: &Wallet<SigningKey>,
) -> Result<Building> {
    let client = reqwest::Client::new();
    let url = format!("https://api.arxos.io/buildings/{}", building_id);
    
    // Initial request
    let response = client.get(&url)
        .bearer_auth(get_jwt_token())
        .send()
        .await?;
    
    if response.status() == StatusCode::PAYMENT_REQUIRED {
        let payment_info: PaymentInfo = response.json().await?;
        
        // Execute payment on-chain
        let tx = payment_router
            .pay_for_access(
                building_id.to_string(),
                payment_info.amount,
                payment_info.nonce.into(),
            )
            .send()
            .await?
            .await?;
        
        println!("‚úÖ Payment confirmed: {}", tx.transaction_hash);
        
        // Retry with proof
        let response = client.get(&url)
            .bearer_auth(get_jwt_token())
            .header("X-Payment-Tx", format!("{:?}", tx.transaction_hash))
            .header("X-Payment-Nonce", payment_info.nonce)
            .send()
            .await?;
        
        if response.status() == StatusCode::OK {
            return Ok(response.json().await?);
        }
    }
    
    Err(anyhow!("Payment verification failed"))
}
```

### Server (Event Listener)

```rust
use ethers::prelude::*;
use std::collections::HashMap;
use tokio::sync::RwLock;

pub struct AccessCache {
    grants: RwLock<HashMap<Bytes32, AccessGrant>>,
}

#[derive(Debug)]
struct AccessGrant {
    building_id: String,
    payer: Address,
    amount: U256,
    granted_at: u64,
    expires_at: u64,
}

impl AccessCache {
    pub async fn start_listener(
        &self,
        payment_router: ArxPaymentRouter<Provider<Ws>>,
    ) -> Result<()> {
        let events = payment_router
            .event::<AccessPaidFilter>()
            .from_block(BlockNumber::Latest)
            .subscribe()
            .await?;
        
        let mut stream = events.take_while(|_| future::ready(true));
        
        while let Some(Ok(event)) = stream.next().await {
            let grant = AccessGrant {
                building_id: event.building_id,
                payer: event.payer,
                amount: event.amount,
                granted_at: event.timestamp.as_u64(),
                expires_at: event.timestamp.as_u64() + 3600, // 1 hour
            };
            
            self.grants.write().await.insert(event.nonce, grant);
            
            tracing::info!(
                "Access granted: {} ‚Üí {} ({})",
                event.payer,
                event.building_id,
                event.nonce
            );
        }
        
        Ok(())
    }
    
    pub async fn verify_access(
        &self,
        nonce: Bytes32,
        expected_payer: Address,
    ) -> Result<bool> {
        let grants = self.grants.read().await;
        
        if let Some(grant) = grants.get(&nonce) {
            let now = chrono::Utc::now().timestamp() as u64;
            
            Ok(grant.payer == expected_payer && grant.expires_at > now)
        } else {
            Ok(false)
        }
    }
}
```

### Server (HTTP Handler)

```rust
use axum::{extract::Path, http::StatusCode, Json};

pub async fn get_building_data(
    Path(building_id): Path<String>,
    headers: HeaderMap,
    State(state): State<AppState>,
) -> Result<Json<Building>, StatusCode> {
    // Check for payment proof
    let payment_tx = headers.get("X-Payment-Tx");
    let payment_nonce = headers.get("X-Payment-Nonce");
    
    match (payment_tx, payment_nonce) {
        (Some(tx), Some(nonce)) => {
            // Verify payment on-chain
            let nonce_bytes = Bytes32::from_str(nonce.to_str().unwrap())?;
            let payer = extract_address_from_jwt(&headers)?;
            
            if state.access_cache.verify_access(nonce_bytes, payer).await? {
                // Payment verified, return data
                let building = state.db.get_building(&building_id).await?;
                Ok(Json(building))
            } else {
                Err(StatusCode::FORBIDDEN)
            }
        }
        _ => {
            // No payment proof, return 402
            Err(StatusCode::PAYMENT_REQUIRED)
        }
    }
}
```

---

## CLI Integration

### Command: `arx pull --pay`

```bash
# Fetch building with automatic payment
arx pull --building ps-118 --pay

# Output:
# üí≥ Payment required: 0.1 ARXO for building ps-118
# üîê Approve spending? [y/N]: y
# ‚õìÔ∏è  Sending payment transaction...
# ‚úÖ Payment confirmed: 0xabc123...
# üì• Downloading building data...
# ‚úÖ Saved to buildings/ps-118.yaml
```

### Configuration

```toml
# ~/.arxos/config.toml

[payments]
auto_pay = true              # Automatically pay when 402 encountered
max_auto_amount = "1.0"      # Max ARXO to spend without confirmation
payment_router = "0x..."     # ArxPaymentRouter contract address
arxo_token = "0x..."         # ARXO token contract address

[wallet]
private_key_path = "~/.arxos/wallet.key"
provider_url = "https://mainnet.base.org"
```

---

## Error Codes

| Code | Description | Client Action |
|------|-------------|---------------|
| `payment_required` | No payment detected | Execute payment and retry |
| `payment_insufficient` | Amount too low | Pay correct amount |
| `payment_expired` | Payment older than 1 hour | Execute new payment |
| `nonce_already_used` | Nonce consumed | Request new nonce |
| `payment_not_found` | Tx hash not on chain | Wait for confirmation |
| `payer_mismatch` | Payment from wrong address | Pay from correct wallet |

---

## Future Enhancements

### V2: Subscription Model
- Monthly/annual passes for unlimited access
- Staking ARXO for free access tier

### V3: Content-Aware Pricing
- Charge based on data size
- Premium for real-time sensor data
- Discounts for open-source contributors

### V4: L2 Micropayments
- Lightning-style state channels
- Even cheaper payments (<$0.001)

---

## Reference Implementation

See:
- Smart contract: `/contracts/src/ArxPaymentRouter.sol`
- Rust client: `/src/blockchain/payment.rs`
- Server: `/src/agent/x402.rs`
- Tests: `/contracts/test/ArxPayment.t.sol`

---

**Ready for implementation! üöÄ**
