<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARXOS - Building Intelligence Platform</title>
    
    <!-- Security Headers -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    
    <!-- CSP should be set by server, but meta tag as fallback -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'nonce-{{.CSPNonce}}' https://unpkg.com;
        style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com;
        font-src 'self' https://cdnjs.cloudflare.com;
        img-src 'self' data: https:;
        connect-src 'self' wss://{{.Host}} https://{{.Host}};
        frame-ancestors 'none';
        base-uri 'self';
        form-action 'self';
        upgrade-insecure-requests;
    ">
    
    <!-- CSRF Token -->
    <meta name="csrf-token" content="{{.CSRFToken}}">
    
    <!-- HTMX with Subresource Integrity -->
    <script src="https://unpkg.com/htmx.org@1.9.10" 
            integrity="sha384-D1Kt99CQMDuVetoL1lrYwg5t+9QdHe7NLX/SoJYkXDFfX37iInKRy5xLSi8nO7UC" 
            crossorigin="anonymous"></script>
    
    <!-- HTMX Security Extension -->
    <script src="https://unpkg.com/htmx.org/dist/ext/head-support.js"></script>
    
    <!-- Hyperscript with SRI -->
    <script src="https://unpkg.com/hyperscript.org@0.9.12" 
            integrity="sha384-xaDsLz1lj5Ht2EaFJKTlMp2V7B2DZ7W2Hqn2J6D5p2LqS5m8zYQK3V5G5D5Y7B5A" 
            crossorigin="anonymous"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/css/github-theme.css">
    <link rel="stylesheet" href="/css/htmx-secure.css">
    
    <!-- Icons with SRI -->
    <link rel="stylesheet" 
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
          integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
          crossorigin="anonymous">
</head>
<body hx-boost="true" 
      hx-ext="head-support"
      hx-headers='{"X-CSRF-Token": "{{.CSRFToken}}"}'>
    
    <!-- Security notice for JavaScript disabled -->
    <noscript>
        <div class="security-notice">
            <p>JavaScript is required for security features. Please enable JavaScript to continue.</p>
        </div>
    </noscript>
    
    <!-- Main Application -->
    <div id="app" 
         hx-get="/api/app/shell" 
         hx-trigger="load"
         hx-swap="outerHTML"
         hx-headers='{"X-Requested-With": "XMLHttpRequest"}'>
        <div class="loading-shell">
            <div class="spinner"></div>
            <p>Loading ARXOS securely...</p>
        </div>
    </div>

    <!-- Security-focused JavaScript -->
    <script nonce="{{.CSPNonce}}">
        (function() {
            'use strict';
            
            // Security configuration
            const security = {
                // Use sessionStorage for sensitive data instead of localStorage
                storage: {
                    setToken(token) {
                        // Store in memory and sessionStorage (not localStorage)
                        this._token = token;
                        sessionStorage.setItem('arxos_token', token);
                    },
                    
                    getToken() {
                        return this._token || sessionStorage.getItem('arxos_token');
                    },
                    
                    clearToken() {
                        this._token = null;
                        sessionStorage.removeItem('arxos_token');
                        sessionStorage.removeItem('arxos_user');
                    },
                    
                    _token: null
                },
                
                // CSRF token management
                csrf: {
                    getToken() {
                        return document.querySelector('meta[name="csrf-token"]')?.content;
                    },
                    
                    refreshToken() {
                        // Request new CSRF token
                        fetch('/api/csrf/refresh', {
                            method: 'POST',
                            credentials: 'same-origin'
                        })
                        .then(res => res.json())
                        .then(data => {
                            const meta = document.querySelector('meta[name="csrf-token"]');
                            if (meta) meta.content = data.token;
                            // Update HTMX headers
                            htmx.config.requestHeaders['X-CSRF-Token'] = data.token;
                        });
                    }
                },
                
                // Input sanitization
                sanitize: {
                    html(str) {
                        const div = document.createElement('div');
                        div.textContent = str;
                        return div.innerHTML;
                    },
                    
                    attribute(str) {
                        return str.replace(/[^\w\s-]/gi, '');
                    },
                    
                    url(str) {
                        try {
                            const url = new URL(str, window.location.origin);
                            // Only allow same-origin or explicitly trusted domains
                            const trustedHosts = ['{{.Host}}', 'localhost'];
                            if (trustedHosts.includes(url.hostname)) {
                                return url.toString();
                            }
                            return '#';
                        } catch {
                            return '#';
                        }
                    }
                },
                
                // Rate limiting
                rateLimiter: {
                    attempts: new Map(),
                    
                    check(action, limit = 5, window = 60000) {
                        const now = Date.now();
                        const key = `${action}`;
                        const attempts = this.attempts.get(key) || [];
                        
                        // Clean old attempts
                        const recent = attempts.filter(t => now - t < window);
                        
                        if (recent.length >= limit) {
                            const resetTime = recent[0] + window;
                            const waitTime = Math.ceil((resetTime - now) / 1000);
                            throw new Error(`Rate limit exceeded. Try again in ${waitTime} seconds.`);
                        }
                        
                        recent.push(now);
                        this.attempts.set(key, recent);
                        return true;
                    }
                }
            };
            
            // HTMX Security Configuration
            htmx.config.allowEval = false;  // Disable eval
            htmx.config.selfRequestsOnly = true;  // Only same-origin requests
            htmx.config.getCacheBusterParam = true;  // Cache busting
            
            // Add security headers to all HTMX requests
            document.body.addEventListener('htmx:configRequest', (evt) => {
                // CSRF Token
                evt.detail.headers['X-CSRF-Token'] = security.csrf.getToken();
                
                // Auth Token (from secure storage)
                const token = security.storage.getToken();
                if (token) {
                    evt.detail.headers['Authorization'] = `Bearer ${token}`;
                }
                
                // Request ID for tracking
                evt.detail.headers['X-Request-ID'] = crypto.randomUUID();
                
                // Add timestamp to prevent replay attacks
                evt.detail.headers['X-Request-Timestamp'] = Date.now().toString();
            });
            
            // Validate responses
            document.body.addEventListener('htmx:beforeSwap', (evt) => {
                // Check for security headers in response
                const headers = evt.detail.xhr.getAllResponseHeaders();
                
                // Verify X-Content-Type-Options
                if (!headers.includes('x-content-type-options')) {
                    console.warn('Missing X-Content-Type-Options header');
                }
                
                // Check for new CSRF token
                const newCsrf = evt.detail.xhr.getResponseHeader('X-CSRF-Token');
                if (newCsrf) {
                    const meta = document.querySelector('meta[name="csrf-token"]');
                    if (meta) meta.content = newCsrf;
                }
                
                // Validate content type
                const contentType = evt.detail.xhr.getResponseHeader('Content-Type');
                if (contentType && !contentType.includes('text/html')) {
                    console.error('Unexpected content type:', contentType);
                    evt.detail.shouldSwap = false;
                    return;
                }
                
                // Sanitize response if needed
                if (evt.detail.serverResponse) {
                    // Check for potential XSS in response
                    const dangerous = /<script|javascript:|on\w+=/i;
                    if (dangerous.test(evt.detail.serverResponse)) {
                        console.error('Potentially dangerous content detected');
                        evt.detail.serverResponse = security.sanitize.html(evt.detail.serverResponse);
                    }
                }
            });
            
            // Handle authentication securely
            document.body.addEventListener('auth:login', (evt) => {
                try {
                    // Rate limit login attempts
                    security.rateLimiter.check('login', 5, 300000); // 5 attempts per 5 minutes
                    
                    // Validate token format
                    const token = evt.detail.token;
                    if (!token || typeof token !== 'string' || token.length < 20) {
                        throw new Error('Invalid token format');
                    }
                    
                    // Store securely
                    security.storage.setToken(token);
                    
                    // Refresh CSRF token after login
                    security.csrf.refreshToken();
                    
                } catch (error) {
                    console.error('Login failed:', error);
                    evt.preventDefault();
                }
            });
            
            // Secure logout
            document.body.addEventListener('auth:logout', () => {
                security.storage.clearToken();
                // Clear all sensitive data
                sessionStorage.clear();
                // Refresh CSRF token
                security.csrf.refreshToken();
            });
            
            // Prevent clickjacking
            if (window.self !== window.top) {
                document.body.style.display = 'none';
                window.top.location = window.self.location;
            }
            
            // Monitor for XSS attempts
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) { // Element node
                            // Check for inline scripts
                            if (node.tagName === 'SCRIPT' && !node.nonce) {
                                console.error('Script without nonce detected, removing:', node);
                                node.remove();
                            }
                            // Check for inline event handlers
                            const attributes = node.attributes || [];
                            for (let attr of attributes) {
                                if (attr.name.startsWith('on')) {
                                    console.error('Inline event handler detected, removing:', attr.name);
                                    node.removeAttribute(attr.name);
                                }
                            }
                        }
                    });
                });
            });
            
            // Start observing
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['onclick', 'onload', 'onerror', 'onmouseover']
            });
            
            // Session timeout
            let sessionTimer;
            const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
            
            function resetSessionTimer() {
                clearTimeout(sessionTimer);
                sessionTimer = setTimeout(() => {
                    // Show warning before logout
                    if (confirm('Your session is about to expire. Stay logged in?')) {
                        // Refresh token
                        fetch('/api/auth/refresh', {
                            method: 'POST',
                            credentials: 'same-origin'
                        }).then(() => resetSessionTimer());
                    } else {
                        security.storage.clearToken();
                        window.location.href = '/login';
                    }
                }, SESSION_TIMEOUT);
            }
            
            // Reset timer on user activity
            ['mousedown', 'keypress', 'scroll', 'touchstart'].forEach(event => {
                document.addEventListener(event, resetSessionTimer, { passive: true });
            });
            
            resetSessionTimer();
            
            // Expose minimal secure API
            window.arxosSecure = {
                sanitize: security.sanitize,
                rateLimit: security.rateLimiter.check.bind(security.rateLimiter)
            };
        })();
    </script>
</body>
</html>