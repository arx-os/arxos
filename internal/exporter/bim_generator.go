package exporter

import (
	"context"
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
	"time"

	"github.com/arx-os/arxos/internal/common/logger"
	"github.com/arx-os/arxos/internal/database"
	"github.com/arx-os/arxos/internal/spatial"
	"github.com/arx-os/arxos/pkg/models"
)

// BIMGenerator generates .bim.txt format from database
type BIMGenerator struct {
	// Options for generation
	IncludeMetadata bool
	IncludeStatus   bool
	SortByRoom      bool
}

// NewBIMGenerator creates a new BIM text generator
func NewBIMGenerator() *BIMGenerator {
	return &BIMGenerator{
		IncludeMetadata: true,
		IncludeStatus:   true,
		SortByRoom:      true,
	}
}

// GenerateFromFloorPlans generates .bim.txt from floor plan data
func (g *BIMGenerator) GenerateFromFloorPlans(plans []*models.FloorPlan, w io.Writer) error {
	if len(plans) == 0 {
		return fmt.Errorf("no floor plans provided")
	}

	// Sort floor plans by level
	sort.Slice(plans, func(i, j int) bool {
		return plans[i].Level < plans[j].Level
	})

	// Write header
	if err := g.writeHeader(w, plans[0]); err != nil {
		return err
	}

	// Write each floor
	for _, plan := range plans {
		if err := g.writeFloor(w, plan); err != nil {
			return fmt.Errorf("failed to write floor %d: %w", plan.Level, err)
		}
	}

	// Write footer
	if err := g.writeFooter(w); err != nil {
		return err
	}

	return nil
}

// writeHeader writes the BIM file header
func (g *BIMGenerator) writeHeader(w io.Writer, plan *models.FloorPlan) error {
	header := []string{
		"# ArxOS Building Information Model",
		fmt.Sprintf("# Generated: %s", time.Now().Format("2006-01-02 15:04:05")),
		"# Universal Address Format: ARXOS-<continent>-<country>-<state>-<city>-<id>",
		"",
	}

	// Add building information
	if plan.UUID != "" {
		header = append(header, fmt.Sprintf("BUILDING: %s %s", plan.UUID, plan.Building))
	} else {
		header = append(header, fmt.Sprintf("BUILDING: %s", plan.Building))
	}

	if plan.Description != "" {
		header = append(header, fmt.Sprintf("DESCRIPTION: %s", plan.Description))
	}

	header = append(header, "")

	for _, line := range header {
		if _, err := fmt.Fprintln(w, line); err != nil {
			return err
		}
	}

	return nil
}

// writeFloor writes a floor section
func (g *BIMGenerator) writeFloor(w io.Writer, plan *models.FloorPlan) error {
	// Write floor header
	floorLine := fmt.Sprintf("FLOOR: %d %s", plan.Level, plan.Name)
	if _, err := fmt.Fprintln(w, floorLine); err != nil {
		return err
	}

	// Group equipment by room
	roomEquipment := g.groupEquipmentByRoom(plan)

	// Sort rooms by ID
	var roomIDs []string
	for id := range roomEquipment {
		roomIDs = append(roomIDs, id)
	}
	sort.Strings(roomIDs)

	// Write each room
	for _, roomID := range roomIDs {
		room := g.findRoom(plan, roomID)
		if room == nil {
			// Room not found, create placeholder
			room = &models.Room{
				ID:   roomID,
				Name: "Unknown Room",
			}
		}

		// Write room line
		roomLine := fmt.Sprintf("  ROOM: %s %s", room.ID, room.Name)
		if _, err := fmt.Fprintln(w, roomLine); err != nil {
			return err
		}

		// Write equipment in room
		equipment := roomEquipment[roomID]
		sort.Slice(equipment, func(i, j int) bool {
			return equipment[i].ID < equipment[j].ID
		})

		for _, eq := range equipment {
			if err := g.writeEquipment(w, eq); err != nil {
				return err
			}
		}

		// Add blank line between rooms
		if _, err := fmt.Fprintln(w, ""); err != nil {
			return err
		}
	}

	return nil
}

// writeEquipment writes an equipment line
func (g *BIMGenerator) writeEquipment(w io.Writer, eq *models.Equipment) error {
	// Build equipment line
	var parts []string

	// Basic format: EQUIPMENT: ID [type] Name
	parts = append(parts, fmt.Sprintf("    EQUIPMENT: %s", eq.ID))

	if eq.Type != "" {
		parts = append(parts, fmt.Sprintf("[%s]", strings.ToLower(eq.Type)))
	}

	if eq.Name != "" {
		parts = append(parts, eq.Name)
	}

	// Add status if enabled
	if g.IncludeStatus && eq.Status != "" && eq.Status != models.StatusOperational {
		parts = append(parts, fmt.Sprintf("<%s>", eq.Status))
	}

	// Add model if available
	if eq.Model != "" {
		parts = append(parts, fmt.Sprintf("(%s)", eq.Model))
	}

	line := strings.Join(parts, " ")
	if _, err := fmt.Fprintln(w, line); err != nil {
		return err
	}

	// Add metadata as comments if enabled
	if g.IncludeMetadata {
		if eq.Serial != "" {
			if _, err := fmt.Fprintf(w, "      # Serial: %s\n", eq.Serial); err != nil {
				return err
			}
		}
		if eq.Installed != nil {
			if _, err := fmt.Fprintf(w, "      # Installed: %s\n", eq.Installed.Format("2006-01-02")); err != nil {
				return err
			}
		}
		if eq.Notes != "" {
			if _, err := fmt.Fprintf(w, "      # Notes: %s\n", eq.Notes); err != nil {
				return err
			}
		}
	}

	return nil
}

// writeFooter writes the BIM file footer
func (g *BIMGenerator) writeFooter(w io.Writer) error {
	footer := []string{
		"",
		"# End of Building Information Model",
		fmt.Sprintf("# Generated by ArxOS v%s", getVersion()),
	}

	for _, line := range footer {
		if _, err := fmt.Fprintln(w, line); err != nil {
			return err
		}
	}

	return nil
}

// groupEquipmentByRoom groups equipment by their room ID
func (g *BIMGenerator) groupEquipmentByRoom(plan *models.FloorPlan) map[string][]*models.Equipment {
	roomEquipment := make(map[string][]*models.Equipment)

	// First, add equipment that has explicit room assignments
	for _, eq := range plan.Equipment {
		roomID := eq.RoomID
		if roomID == "" {
			// Try to infer from path (e.g., "3/A/301/E/OUTLET_02")
			if parts := strings.Split(eq.Path, "/"); len(parts) >= 3 {
				roomID = parts[2] // Assumes room is third component
			}
		}
		if roomID == "" {
			roomID = "UNASSIGNED"
		}
		roomEquipment[roomID] = append(roomEquipment[roomID], eq)
	}

	// Also check rooms for their equipment lists
	for _, room := range plan.Rooms {
		for _, eqID := range room.Equipment {
			// Find equipment by ID
			for _, eq := range plan.Equipment {
				if eq.ID == eqID {
					roomEquipment[room.ID] = append(roomEquipment[room.ID], eq)
					break
				}
			}
		}
	}

	return roomEquipment
}

// findRoom finds a room by ID
func (g *BIMGenerator) findRoom(plan *models.FloorPlan, roomID string) *models.Room {
	for _, room := range plan.Rooms {
		if room.ID == roomID {
			return room
		}
	}
	return nil
}

// GenerateFromDatabase generates .bim.txt by querying the database (PostGIS or SQLite)
func (g *BIMGenerator) GenerateFromDatabase(ctx context.Context, db interface{}, buildingID string, w io.Writer) error {
	logger.Info("Generating BIM text for building: %s from database", buildingID)

	// Write header
	header := []string{
		"# ArxOS Building Information Model",
		fmt.Sprintf("# Generated: %s", time.Now().Format("2006-01-02 15:04:05")),
		fmt.Sprintf("# Building: %s", buildingID),
		"# Source: PostGIS Spatial Database",
		"# Coordinates: Millimeter precision (SRID 900913)",
		"",
	}

	for _, line := range header {
		if _, err := fmt.Fprintln(w, line); err != nil {
			return err
		}
	}

	// Check if we have a PostGIS database
	if postgisDB, ok := db.(*database.PostGISDB); ok {
		// Generate with spatial data
		return g.generateWithSpatialData(ctx, postgisDB, buildingID, w)
	}

	return fmt.Errorf("unsupported database type for BIM generation")
}

// generateWithSpatialData generates BIM from PostGIS spatial data
func (g *BIMGenerator) generateWithSpatialData(ctx context.Context, spatialDB database.SpatialDB, buildingID string, w io.Writer) error {
	// Query equipment by spatial proximity (get all within building bounds)
	center := spatial.Point3D{X: 0, Y: 0, Z: 0}
	radius := 1000000.0 // 1km radius in meters to get all building equipment

	equipment, err := spatialDB.QueryBySpatialProximity(center, radius)
	if err != nil {
		return fmt.Errorf("failed to query spatial equipment: %w", err)
	}

	// Group equipment by floor based on Z coordinate
	floorMap := make(map[int][]*database.SpatialEquipment)
	for _, eq := range equipment {
		if eq.SpatialData != nil {
			// Determine floor from Z coordinate (assume 3500mm per floor)
			floor := int(eq.SpatialData.Position.Z / 3500)
			floorMap[floor] = append(floorMap[floor], eq)
		}
	}

	// Sort floors
	var floors []int
	for f := range floorMap {
		floors = append(floors, f)
	}
	sort.Ints(floors)

	// Write floors and equipment
	for _, floor := range floors {
		fmt.Fprintf(w, "\nFLOOR: %d Level_%d\n", floor, floor)

		// Sort equipment by position for consistent output
		equipment := floorMap[floor]
		sort.Slice(equipment, func(i, j int) bool {
			return equipment[i].ID < equipment[j].ID
		})

		// Write equipment with spatial coordinates
		for _, eq := range equipment {
			if eq.SpatialData != nil {
				fmt.Fprintf(w, "  EQUIPMENT: %s [%s] %s @ %.3f,%.3f,%.3f",
					eq.ID, eq.Type, eq.Name,
					eq.SpatialData.Position.X,
					eq.SpatialData.Position.Y,
					eq.SpatialData.Position.Z)

				// Add confidence indicator
				if eq.SpatialData.PositionConfidence == spatial.ConfidenceHigh {
					fmt.Fprint(w, " â˜…")
				}

				fmt.Fprintln(w)

				// Add metadata
				if g.IncludeMetadata {
					fmt.Fprintf(w, "    # Source: %s\n", eq.SpatialData.PositionSource)
					fmt.Fprintf(w, "    # Updated: %s\n", eq.SpatialData.PositionUpdated.Format("2006-01-02"))
					fmt.Fprintf(w, "    # Grid: [%d,%d]\n",
						eq.SpatialData.GridPosition.X,
						eq.SpatialData.GridPosition.Y)
				}
			}
		}
	}

	// Add spatial statistics
	fmt.Fprintln(w, "\n## SPATIAL STATISTICS")
	fmt.Fprintf(w, "Total Equipment: %d\n", len(equipment))

	highConfidence := 0
	for _, eq := range equipment {
		if eq.SpatialData != nil && eq.SpatialData.PositionConfidence == spatial.ConfidenceHigh {
			highConfidence++
		}
	}
	fmt.Fprintf(w, "High Confidence Positions: %d (%.1f%%)\n",
		highConfidence,
		float64(highConfidence)/float64(len(equipment))*100)

	fmt.Fprintln(w, "\n# End of Building Information Model")

	return nil
}

// generateFromSQLite removed - using PostGIS only

// getVersion returns the current ArxOS version
func getVersion() string {
	// Get from build info or config
	// In a real implementation, this would read from build info or config
	version := os.Getenv("ARXOS_VERSION")
	if version == "" {
		version = "1.0.0" // Default fallback
	}
	return version
}

// GenerateSummary generates a summary of the building
func (g *BIMGenerator) GenerateSummary(plans []*models.FloorPlan) string {
	if len(plans) == 0 {
		return "No building data"
	}

	totalRooms := 0
	totalEquipment := 0
	statusCounts := make(map[string]int)

	for _, plan := range plans {
		totalRooms += len(plan.Rooms)
		totalEquipment += len(plan.Equipment)

		for _, eq := range plan.Equipment {
			statusCounts[eq.Status]++
		}
	}

	var summary strings.Builder
	summary.WriteString(fmt.Sprintf("Building: %s\n", plans[0].Building))
	summary.WriteString(fmt.Sprintf("Floors: %d\n", len(plans)))
	summary.WriteString(fmt.Sprintf("Total Rooms: %d\n", totalRooms))
	summary.WriteString(fmt.Sprintf("Total Equipment: %d\n", totalEquipment))

	if len(statusCounts) > 0 {
		summary.WriteString("\nEquipment Status:\n")
		for status, count := range statusCounts {
			if status == "" {
				status = "Unknown"
			}
			summary.WriteString(fmt.Sprintf("  %s: %d\n", status, count))
		}
	}

	return summary.String()
}
