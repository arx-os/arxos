package daemon

import (
	"fmt"
	"sync"
	"testing"
	"time"
)

func TestWorkQueue_AddAndRetrieve(t *testing.T) {
	queue := NewWorkQueue(5)
	defer queue.Close()

	// Add items
	item1 := &WorkItem{
		Type:      WorkTypeImport,
		FilePath:  "/tmp/file1.ifc",
		Timestamp: time.Now(),
	}

	err := queue.Add(item1)
	if err != nil {
		t.Fatalf("Failed to add item: %v", err)
	}

	// Retrieve item
	select {
	case retrieved := <-queue.Items():
		if retrieved.FilePath != item1.FilePath {
			t.Errorf("Retrieved wrong item: got %s, want %s", retrieved.FilePath, item1.FilePath)
		}
	case <-time.After(100 * time.Millisecond):
		t.Fatal("Failed to retrieve item from queue")
	}
}

func TestWorkQueue_Deduplication(t *testing.T) {
	queue := NewWorkQueue(5)
	defer queue.Close()

	filePath := "/tmp/duplicate.ifc"

	// Add same file multiple times
	for i := 0; i < 3; i++ {
		item := &WorkItem{
			Type:      WorkTypeImport,
			FilePath:  filePath,
			Timestamp: time.Now().Add(time.Duration(i) * time.Second),
		}
		err := queue.Add(item)
		if err != nil {
			t.Fatalf("Failed to add item %d: %v", i, err)
		}
	}

	// Should only have one item in queue
	if queue.Size() != 1 {
		t.Errorf("Queue size = %d, want 1", queue.Size())
	}

	// Retrieve the item
	select {
	case item := <-queue.Items():
		if item.FilePath != filePath {
			t.Errorf("Retrieved wrong file: got %s, want %s", item.FilePath, filePath)
		}
	case <-time.After(100 * time.Millisecond):
		t.Fatal("Failed to retrieve item from queue")
	}

	// Queue should be empty now
	if queue.Size() != 0 {
		t.Errorf("Queue size after retrieval = %d, want 0", queue.Size())
	}
}

func TestWorkQueue_FullQueue(t *testing.T) {
	queue := NewWorkQueue(2)
	defer queue.Close()

	// Fill queue
	for i := 0; i < 2; i++ {
		item := &WorkItem{
			Type:      WorkTypeImport,
			FilePath:  fmt.Sprintf("/tmp/file%d.ifc", i),
			Timestamp: time.Now(),
		}
		err := queue.Add(item)
		if err != nil {
			t.Fatalf("Failed to add item %d: %v", i, err)
		}
	}

	// Try to add one more (should fail)
	item := &WorkItem{
		Type:      WorkTypeImport,
		FilePath:  "/tmp/file3.ifc",
		Timestamp: time.Now(),
	}
	err := queue.Add(item)
	if err == nil {
		t.Fatal("Expected error when adding to full queue")
	}
	if err.Error() != "queue is full" {
		t.Errorf("Wrong error: got %v, want 'queue is full'", err)
	}
}

func TestWorkQueue_CloseAndAdd(t *testing.T) {
	queue := NewWorkQueue(5)
	queue.Close()

	// Try to add after closing
	item := &WorkItem{
		Type:      WorkTypeImport,
		FilePath:  "/tmp/file.ifc",
		Timestamp: time.Now(),
	}
	err := queue.Add(item)
	if err == nil {
		t.Fatal("Expected error when adding to closed queue")
	}
	if err.Error() != "queue is closed" {
		t.Errorf("Wrong error: got %v, want 'queue is closed'", err)
	}
}

func TestWorkQueue_ConcurrentAccess(t *testing.T) {
	queue := NewWorkQueue(100)
	defer queue.Close()

	var wg sync.WaitGroup
	numProducers := 10
	numConsumers := 5
	itemsPerProducer := 10

	// Track items
	produced := make(map[string]bool)
	consumed := make(map[string]bool)
	var producedMu, consumedMu sync.Mutex

	// Start consumers
	for i := 0; i < numConsumers; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			for item := range queue.Items() {
				if item == nil {
					break
				}
				consumedMu.Lock()
				consumed[item.FilePath] = true
				consumedMu.Unlock()
			}
		}(i)
	}

	// Start producers
	for i := 0; i < numProducers; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			for j := 0; j < itemsPerProducer; j++ {
				filePath := fmt.Sprintf("/tmp/producer%d_file%d.ifc", id, j)
				item := &WorkItem{
					Type:      WorkTypeImport,
					FilePath:  filePath,
					Timestamp: time.Now(),
				}

				// Retry on full queue
				for retries := 0; retries < 3; retries++ {
					err := queue.Add(item)
					if err == nil {
						producedMu.Lock()
						produced[filePath] = true
						producedMu.Unlock()
						break
					}
					time.Sleep(10 * time.Millisecond)
				}
			}
		}(i)
	}

	// Wait for producers to finish
	time.Sleep(100 * time.Millisecond)

	// Close queue to signal consumers
	queue.Close()

	// Wait for all goroutines
	wg.Wait()

	// Verify counts
	t.Logf("Produced: %d, Consumed: %d", len(produced), len(consumed))

	// All produced items should be consumed (minus duplicates)
	for path := range produced {
		if !consumed[path] {
			// This might happen due to queue being full or closing
			t.Logf("Item not consumed: %s", path)
		}
	}
}

func TestWorkQueue_AutoGeneratedID(t *testing.T) {
	queue := NewWorkQueue(5)
	defer queue.Close()

	// Add item without ID
	item := &WorkItem{
		Type:      WorkTypeImport,
		FilePath:  "/tmp/file.ifc",
		Timestamp: time.Now(),
	}

	err := queue.Add(item)
	if err != nil {
		t.Fatalf("Failed to add item: %v", err)
	}

	// Retrieve and check ID
	select {
	case retrieved := <-queue.Items():
		if retrieved.ID == "" {
			t.Error("Item ID was not auto-generated")
		}
		if retrieved.FilePath != item.FilePath {
			t.Errorf("Wrong item retrieved")
		}
	case <-time.After(100 * time.Millisecond):
		t.Fatal("Failed to retrieve item from queue")
	}
}

func TestWorkQueue_UpdateExistingItem(t *testing.T) {
	queue := NewWorkQueue(5)
	defer queue.Close()

	filePath := "/tmp/update.ifc"
	baseTime := time.Now()

	// Add initial item
	item1 := &WorkItem{
		Type:      WorkTypeImport,
		FilePath:  filePath,
		Timestamp: baseTime,
	}
	err := queue.Add(item1)
	if err != nil {
		t.Fatalf("Failed to add item1: %v", err)
	}

	// Add update with newer timestamp
	item2 := &WorkItem{
		Type:      WorkTypeUpdate,
		FilePath:  filePath,
		Timestamp: baseTime.Add(1 * time.Second),
	}
	err = queue.Add(item2)
	if err != nil {
		t.Fatalf("Failed to add item2: %v", err)
	}

	// Should still have only one item
	if queue.Size() != 1 {
		t.Errorf("Queue size = %d, want 1", queue.Size())
	}

	// Retrieve and check it's updated
	select {
	case retrieved := <-queue.Items():
		// Note: The deduplication logic updates the existing item's timestamp and type
		// but the item in the channel might still be the original
		if retrieved.FilePath != filePath {
			t.Errorf("Wrong file path: got %s, want %s", retrieved.FilePath, filePath)
		}
	case <-time.After(100 * time.Millisecond):
		t.Fatal("Failed to retrieve item from queue")
	}
}