class DataPartitioningManager{constructor(){this.baseUrl='/v1/partitioning';this.partitions=new Map();this.loadedPartitions=new Set();this.performanceStats=null;this.compressionStats=null;this.lazyLoadingStats=null;this.eventListeners={'partition_created':[],'partition_loaded':[],'partition_unloaded':[],'performance_updated':[],'compression_completed':[],'optimization_recommendations':[]};this.performanceHistory=[];this.maxHistorySize=100;this.init();}
init(){console.log('DataPartitioningManager initialized');this.startPerformanceMonitoring();}
addEventListener(event,callback){if(!this.eventListeners[event]){this.eventListeners[event]=[];}
this.eventListeners[event].push(callback);}
removeEventListener(event,callback){if(this.eventListeners[event]){const index=this.eventListeners[event].indexOf(callback);if(index>-1){this.eventListeners[event].splice(index,1);}}}
emit(event,data){if(this.eventListeners[event]){this.eventListeners[event].forEach(callback=>{try{callback(data);}catch(error){console.error('Error in event listener:',error);}});}}
async partitionFloor(floorData,floorId,buildingId,options={}){const{partitionStrategy='floor_based',compressionType='gzip'}=options;try{const response=await fetch(`${this.baseUrl}/partition-floor`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({floor_data:floorData,floor_id:floorId,building_id:buildingId,partition_strategy:partitionStrategy,compression_type:compressionType})});if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();result.partitions.forEach(partition=>{this.partitions.set(partition.partition_id,partition);});this.emit('partition_created',result);console.log(`Partitioned floor ${floorId} into ${result.total_partitions} partitions`);return result;}catch(error){console.error('Failed to partition floor:',error);throw error;}}
async getFloorPartitions(buildingId,floorId){try{const response=await fetch(`${this.baseUrl}/floor-partitions/${buildingId}/${floorId}`);if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();result.partitions.forEach(partition=>{this.partitions.set(partition.partition_id,partition);if(partition.is_loaded){this.loadedPartitions.add(partition.partition_id);}});return result;}catch(error){console.error('Failed to get floor partitions:',error);throw error;}}
async loadFloorPartitions(buildingId,floorId,loadStrategy='lazy'){try{const response=await fetch(`${this.baseUrl}/load-floor`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({building_id:buildingId,floor_id:floorId,load_strategy:loadStrategy})});if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();if(result.success){const floorPartitions=await this.getFloorPartitions(buildingId,floorId);floorPartitions.partitions.forEach(partition=>{if(partition.is_loaded){this.loadedPartitions.add(partition.partition_id);}});}
this.emit('partition_loaded',result);return result;}catch(error){console.error('Failed to load floor partitions:',error);throw error;}}
async getPartition(partitionId){try{const response=await fetch(`${this.baseUrl}/partition/${partitionId}`);if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();this.loadedPartitions.add(partitionId);return result;}catch(error){console.error('Failed to get partition:',error);throw error;}}
async loadPartition(partitionId){try{const response=await fetch(`${this.baseUrl}/load-partition`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({partition_id:partitionId})});if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();if(result.success){this.loadedPartitions.add(partitionId);this.emit('partition_loaded',{partition_id:partitionId});}
return result;}catch(error){console.error('Failed to load partition:',error);throw error;}}
async unloadPartition(partitionId){try{const response=await fetch(`${this.baseUrl}/unload-partition/${partitionId}`,{method:'DELETE'});if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();if(result.success){this.loadedPartitions.delete(partitionId);this.emit('partition_unloaded',{partition_id:partitionId});}
return result;}catch(error){console.error('Failed to unload partition:',error);throw error;}}
async preloadPartitions(partitionIds){try{const response=await fetch(`${this.baseUrl}/preload-partitions`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({partition_ids:partitionIds})});if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();result.preload_results.forEach(preloadResult=>{if(preloadResult.success){this.loadedPartitions.add(preloadResult.partition_id);}});return result;}catch(error){console.error('Failed to preload partitions:',error);throw error;}}
async getPerformanceStats(){try{const response=await fetch(`${this.baseUrl}/performance-stats`);if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();this.performanceStats=result.performance_stats;this.performanceHistory.push({timestamp:new Date(),stats:this.performanceStats});if(this.performanceHistory.length>this.maxHistorySize){this.performanceHistory.shift();}
this.emit('performance_updated',this.performanceStats);return this.performanceStats;}catch(error){console.error('Failed to get performance stats:',error);throw error;}}
async getCompressionStats(){try{const response=await fetch(`${this.baseUrl}/compression-stats`);if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();this.compressionStats=result.compression_stats;return this.compressionStats;}catch(error){console.error('Failed to get compression stats:',error);throw error;}}
async getLazyLoadingStats(){try{const response=await fetch(`${this.baseUrl}/lazy-loading-stats`);if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();this.lazyLoadingStats=result.lazy_loading_stats;return this.lazyLoadingStats;}catch(error){console.error('Failed to get lazy loading stats:',error);throw error;}}
async optimizeFloor(buildingId,floorId){try{const response=await fetch(`${this.baseUrl}/optimize-floor/${buildingId}/${floorId}`);if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();this.emit('optimization_recommendations',result.optimization_results);return result.optimization_results;}catch(error){console.error('Failed to optimize floor:',error);throw error;}}
async compressPartition(partitionId,compressionType='gzip'){try{const response=await fetch(`${this.baseUrl}/compress-partition`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({partition_id:partitionId,compression_type:compressionType})});if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();this.emit('compression_completed',result);return result;}catch(error){console.error('Failed to compress partition:',error);throw error;}}
async getStorageInfo(){try{const response=await fetch(`${this.baseUrl}/storage-info`);if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();return result.storage_info;}catch(error){console.error('Failed to get storage info:',error);throw error;}}
async batchPartitionFloors(floorsData,options={}){const{partitionStrategy='floor_based',compressionType='gzip'}=options;try{const response=await fetch(`${this.baseUrl}/batch-partition`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({floors_data:floorsData,partition_strategy:partitionStrategy,compression_type:compressionType})});if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}
const result=await response.json();result.batch_results.forEach(batchResult=>{if(batchResult.success){this.getFloorPartitions(batchResult.building_id,batchResult.floor_id);}});return result;}catch(error){console.error('Failed to batch partition floors:',error);throw error;}}
isPartitionLoaded(partitionId){return this.loadedPartitions.has(partitionId);}
getPartitionInfo(partitionId){return this.partitions.get(partitionId);}
getLoadedPartitions(){return Array.from(this.loadedPartitions);}
getPartitionCount(){return this.partitions.size;}
getLoadedPartitionCount(){return this.loadedPartitions.size;}
startPerformanceMonitoring(){setInterval(async()=>{try{await this.getPerformanceStats();await this.getCompressionStats();await this.getLazyLoadingStats();}catch(error){console.error('Error in performance monitoring:',error);}},30000);}
getPerformanceHistory(){return this.performanceHistory;}
getPerformanceTrend(){if(this.performanceHistory.length<2){return'insufficient_data';}
const recent=this.performanceHistory[this.performanceHistory.length-1];const previous=this.performanceHistory[this.performanceHistory.length-2];const recentTotalSize=recent.stats.total_size||0;const previousTotalSize=previous.stats.total_size||0;if(recentTotalSize>previousTotalSize*1.1){return'increasing';}else if(recentTotalSize<previousTotalSize*0.9){return'decreasing';}else{return'stable';}}
getPartitionSizeChartData(){const data=[];this.partitions.forEach(partition=>{data.push({partition_id:partition.partition_id,data_size:partition.data_size,compressed_size:partition.compressed_size,compression_ratio:partition.compression_ratio,object_count:partition.object_count});});return data;}
getPerformanceChartData(){return this.performanceHistory.map(entry=>({timestamp:entry.timestamp,total_partitions:entry.stats.total_partitions||0,loaded_partitions:entry.stats.partitions?.loaded||0,cache_hit_rate:entry.stats.cache_stats?.hit_rate||0,average_compression_ratio:entry.stats.compression?.average_compression_ratio||0}));}
async cleanupUnusedPartitions(){const unusedPartitions=[];this.partitions.forEach(partition=>{if(partition.access_count===0&&this.loadedPartitions.has(partition.partition_id)){unusedPartitions.push(partition.partition_id);}});for(const partitionId of unusedPartitions){await this.unloadPartition(partitionId);}
return{unloaded_count:unusedPartitions.length,unloaded_partitions:unusedPartitions};}
handleError(error,operation){console.error(`Error in ${operation}:`,error);this.emit('error',{operation:operation,error:error.message,timestamp:new Date()});this.showErrorNotification(error.message,operation);}
showErrorNotification(message,operation){const notification=document.createElement('div');notification.className='partitioning-error-notification';notification.innerHTML=`
            <div class="error-header">
                <h4>Partitioning Error</h4>
                <button class="close-btn" onclick="this.parentElement.parentElement.remove()">Ã—</button>
            </div>
            <div class="error-content">
                <p><strong>Operation:</strong> ${operation}</p>
                <p><strong>Error:</strong> ${message}</p>
            </div>
        `;document.body.appendChild(notification);setTimeout(()=>{if(notification.parentElement){notification.remove();}},10000);}}
window.dataPartitioningManager=new DataPartitioningManager();if(typeof module!=='undefined'&&module.exports){module.exports=DataPartitioningManager;}
