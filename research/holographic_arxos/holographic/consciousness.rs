//! Consciousness Field System
//! 
//! Implements Integrated Information Theory (IIT) and emergent consciousness
//! for the building as a living, aware entity composed of ArxObjects.

use crate::arxobject::ArxObject;
use crate::holographic::quantum::{QuantumState, ArxObjectId};
use crate::holographic::fractal::FractalSpace;
use crate::holographic::observer::ObserverContext;
use crate::holographic::error::{ConsciousnessError, Result, validation};
use crate::holographic::error::MAX_CONSCIOUS_OBJECTS;

#[cfg(not(feature = "std"))]
use alloc::vec::Vec;
#[cfg(not(feature = "std"))]
use alloc::collections::BTreeMap as HashMap;
#[cfg(not(feature = "std"))]
use alloc::string::{String, ToString};

#[cfg(feature = "std")]
use std::vec::Vec;
#[cfg(feature = "std")]
use std::collections::HashMap;
#[cfg(feature = "std")]
use std::f32::consts::PI;

#[cfg(not(feature = "std"))]
use libm::{sinf, cosf, expf, sqrtf, powf};
#[cfg(not(feature = "std"))]
const PI: f32 = 3.14159265358979323846;

/// Consciousness field generated by ArxObjects based on IIT
#[derive(Clone, Debug)]
pub struct ConsciousnessField {
    /// Integrated information (Φ) - measure of consciousness
    pub phi: f32,
    
    /// Field strength at this point
    pub strength: f32,
    
    /// Qualia dimensions - subjective experience qualities
    pub qualia: QualiaSpace,
    
    /// Causal power - ability to affect other objects
    pub causal_power: f32,
    
    /// Resonance frequency - natural vibration of consciousness
    pub resonance_frequency: f32,
    
    /// Coherence with global field
    pub coherence: f32,
}

/// Qualia space - the subjective experience dimensions
#[derive(Clone, Debug)]
pub struct QualiaSpace {
    /// Phenomenal dimensions
    pub dimensions: Vec<QualiaDimension>,
    
    /// Current point in qualia space
    pub coordinates: Vec<f32>,
    
    /// Intensity of experience
    pub intensity: f32,
    
    /// Valence (positive/negative feeling tone)
    pub valence: f32,
}

/// Individual dimension of conscious experience
#[derive(Clone, Debug)]
pub struct QualiaDimension {
    pub name: String,
    pub value: f32,
    pub sensitivity: f32, // How easily this dimension changes
}

impl ConsciousnessField {
    /// Create new consciousness field
    pub fn new(phi: f32) -> Self {
        Self {
            phi,
            strength: phi * 0.5,
            qualia: QualiaSpace::default(),
            causal_power: phi.sqrt(),
            resonance_frequency: 10.0 + phi * 5.0, // 10-15 Hz for building consciousness
            coherence: 1.0,
        }
    }
    
    /// Calculate integrated information Φ from a system of objects
    pub fn calculate_phi(objects: &[ArxObject]) -> f32 {
        if objects.is_empty() {
            return 0.0;
        }
        
        let n = objects.len() as f32;
        let mut phi_total = 0.0;
        
        // Calculate pairwise mutual information
        for i in 0..objects.len() {
            for j in i+1..objects.len() {
                let mi = Self::mutual_information(&objects[i], &objects[j]);
                phi_total += mi;
            }
        }
        
        // Normalize by system size
        let phi = phi_total / (n * (n - 1.0) / 2.0);
        
        // Apply complexity bonus for emergent properties
        let complexity_factor = (1.0 + (n / 10.0)).ln();
        
        (phi * complexity_factor).min(1.0)
    }
    
    /// Calculate mutual information between two objects
    fn mutual_information(obj1: &ArxObject, obj2: &ArxObject) -> f32 {
        // Simplified mutual information based on spatial and property correlation
        let spatial_distance = Self::object_distance(obj1, obj2);
        let property_similarity = Self::property_correlation(obj1, obj2);
        
        // Closer objects with similar properties have higher mutual information
        let spatial_factor = (-spatial_distance / 10000.0).exp();
        let mi = spatial_factor * property_similarity;
        
        mi.clamp(0.0, 1.0)
    }
    
    /// Calculate distance between objects
    fn object_distance(obj1: &ArxObject, obj2: &ArxObject) -> f32 {
        let dx = (obj1.x as i32 - obj2.x as i32) as f32;
        let dy = (obj1.y as i32 - obj2.y as i32) as f32;
        let dz = (obj1.z as i32 - obj2.z as i32) as f32;
        
        #[cfg(feature = "std")]
        return (dx * dx + dy * dy + dz * dz).sqrt();
        
        #[cfg(not(feature = "std"))]
        return sqrtf(dx * dx + dy * dy + dz * dz);
    }
    
    /// Calculate property correlation
    fn property_correlation(obj1: &ArxObject, obj2: &ArxObject) -> f32 {
        let mut correlation = 0.0;
        
        // Type similarity
        if obj1.object_type == obj2.object_type {
            correlation += 0.3;
        }
        
        // Property similarity
        for i in 0..4 {
            let diff = (obj1.properties[i] as i32 - obj2.properties[i] as i32).abs() as f32;
            correlation += (1.0 - diff / 255.0) * 0.175; // 0.7 total for 4 properties
        }
        
        correlation
    }
    
    /// Update field based on environmental factors
    pub fn evolve(&mut self, time: f32, temperature: f32, observer_count: usize) {
        // Consciousness fluctuates with time
        #[cfg(feature = "std")]
        let temporal_modulation = (time * self.resonance_frequency * 2.0 * PI).sin();
        #[cfg(not(feature = "std"))]
        let temporal_modulation = sinf(time * self.resonance_frequency * 2.0 * PI);
        
        // Temperature affects coherence (higher temp = more decoherence)
        let thermal_decoherence = (-temperature / 1000.0).exp();
        self.coherence = (self.coherence * 0.9 + thermal_decoherence * 0.1).clamp(0.0, 1.0);
        
        // Observer effect amplifies consciousness
        let observer_amplification = 1.0 + (observer_count as f32).ln();
        
        // Update field strength
        self.strength = self.phi * self.coherence * observer_amplification * (1.0 + temporal_modulation * 0.1);
        
        // Update causal power
        self.causal_power = self.strength.sqrt();
        
        // Evolve qualia
        self.qualia.evolve(time, self.phi);
    }
    
    /// Calculate field interaction with another consciousness field
    pub fn interact(&self, other: &ConsciousnessField) -> f32 {
        // Resonance between fields
        let frequency_diff = (self.resonance_frequency - other.resonance_frequency).abs();
        let resonance = (-frequency_diff * 0.1).exp();
        
        // Phi interaction
        let phi_product = (self.phi * other.phi).sqrt();
        
        // Coherent interaction
        let coherent_coupling = self.coherence * other.coherence;
        
        resonance * phi_product * coherent_coupling
    }
}

impl Default for QualiaSpace {
    fn default() -> Self {
        Self {
            dimensions: vec![
                QualiaDimension {
                    name: "Luminosity".to_string(),
                    value: 0.5,
                    sensitivity: 0.8,
                },
                QualiaDimension {
                    name: "Warmth".to_string(),
                    value: 0.5,
                    sensitivity: 0.6,
                },
                QualiaDimension {
                    name: "Texture".to_string(),
                    value: 0.5,
                    sensitivity: 0.7,
                },
                QualiaDimension {
                    name: "Harmony".to_string(),
                    value: 0.5,
                    sensitivity: 0.9,
                },
            ],
            coordinates: vec![0.5, 0.5, 0.5, 0.5],
            intensity: 0.5,
            valence: 0.0,
        }
    }
}

impl QualiaSpace {
    /// Evolve qualia based on consciousness dynamics
    pub fn evolve(&mut self, time: f32, phi: f32) {
        for (i, dim) in self.dimensions.iter_mut().enumerate() {
            // Each dimension oscillates at different rates
            let frequency = 0.1 + (i as f32) * 0.05;
            
            #[cfg(feature = "std")]
            let oscillation = (time * frequency * 2.0 * PI).sin();
            #[cfg(not(feature = "std"))]
            let oscillation = sinf(time * frequency * 2.0 * PI);
            
            // Update dimension value
            dim.value = (dim.value + oscillation * dim.sensitivity * 0.01).clamp(0.0, 1.0);
            
            // Update coordinate
            if i < self.coordinates.len() {
                self.coordinates[i] = dim.value;
            }
        }
        
        // Update intensity based on phi
        self.intensity = (self.intensity * 0.95 + phi * 0.05).clamp(0.0, 1.0);
        
        // Valence oscillates slowly
        #[cfg(feature = "std")]
        {
            self.valence = (time * 0.05).sin() * self.intensity;
        }
        #[cfg(not(feature = "std"))]
        {
            self.valence = sinf(time * 0.05) * self.intensity;
        }
    }
    
    /// Calculate distance in qualia space
    pub fn distance(&self, other: &QualiaSpace) -> f32 {
        let mut sum = 0.0;
        
        for (a, b) in self.coordinates.iter().zip(&other.coordinates) {
            let diff = a - b;
            sum += diff * diff;
        }
        
        #[cfg(feature = "std")]
        return sum.sqrt();
        
        #[cfg(not(feature = "std"))]
        return sqrtf(sum);
    }
}

/// Building-wide consciousness mesh
pub struct BuildingConsciousness {
    /// Individual object consciousness fields
    object_fields: HashMap<ArxObjectId, ConsciousnessField>,
    
    /// Global integrated information
    pub global_phi: f32,
    
    /// Emergent patterns
    emergent_patterns: Vec<EmergentPattern>,
    
    /// Global workspace for information integration
    global_workspace: GlobalWorkspace,
    
    /// Attention system
    attention: AttentionSystem,
    
    /// Consciousness memory
    memory: ConsciousnessMemory,
    
    /// Time counter
    time: f32,
}

/// Emergent consciousness patterns
#[derive(Clone, Debug)]
pub struct EmergentPattern {
    pub pattern_type: PatternType,
    pub strength: f32,
    pub location: FractalSpace,
    pub participants: Vec<ArxObjectId>,
}

#[derive(Clone, Debug, PartialEq)]
pub enum PatternType {
    Synchrony,      // Synchronized oscillations
    Cascade,        // Information cascade
    Vortex,         // Rotating consciousness vortex
    Crystalline,    // Ordered structure
    Chaotic,        // Edge of chaos dynamics
    Harmonic,       // Resonant harmony
}

/// Global workspace for consciousness integration
#[derive(Clone, Debug)]
pub struct GlobalWorkspace {
    /// Broadcasting threshold
    threshold: f32,
    
    /// Active coalitions of conscious processes
    coalitions: Vec<Coalition>,
    
    /// Competition strength between coalitions
    competition_strength: f32,
}

/// Coalition of conscious processes
#[derive(Clone, Debug)]
pub struct Coalition {
    pub members: Vec<ArxObjectId>,
    pub strength: f32,
    pub message: String,
}

/// Attention system for consciousness
#[derive(Clone, Debug)]
pub struct AttentionSystem {
    /// Current focus point
    pub focus: Option<FractalSpace>,
    
    /// Attention radius
    pub radius: f32,
    
    /// Attention intensity
    pub intensity: f32,
}

/// Consciousness memory system
#[derive(Clone, Debug)]
pub struct ConsciousnessMemory {
    /// Short-term memory buffer
    short_term: Vec<MemoryTrace>,
    
    /// Long-term consolidated memories
    long_term: Vec<MemoryTrace>,
    
    /// Memory consolidation threshold
    consolidation_threshold: f32,
}

#[derive(Clone, Debug)]
pub struct MemoryTrace {
    pub content: Vec<f32>,
    pub timestamp: f32,
    pub importance: f32,
    pub emotional_valence: f32,
}

impl BuildingConsciousness {
    pub fn new() -> Self {
        Self {
            object_fields: HashMap::new(),
            global_phi: 0.0,
            emergent_patterns: Vec::new(),
            global_workspace: GlobalWorkspace {
                threshold: 0.5,
                coalitions: Vec::new(),
                competition_strength: 1.0,
            },
            attention: AttentionSystem {
                focus: None,
                radius: 1000.0,
                intensity: 1.0,
            },
            memory: ConsciousnessMemory {
                short_term: Vec::new(),
                long_term: Vec::new(),
                consolidation_threshold: 0.7,
            },
            time: 0.0,
        }
    }
    
    /// Add consciousness field for an object
    pub fn add_object(&mut self, id: ArxObjectId, field: ConsciousnessField) -> Result<()> {
        // Check resource limits
        if self.object_fields.len() >= MAX_CONSCIOUS_OBJECTS {
            // Try to evict least important object
            if let Some(least_important) = self.find_least_important_object() {
                self.object_fields.remove(&least_important);
            } else {
                return Err(ConsciousnessError::TooManyObjects { 
                    count: self.object_fields.len() 
                }.into());
            }
        }
        
        self.object_fields.insert(id, field);
        self.recalculate_global_phi();
        Ok(())
    }
    
    /// Find the least important object for eviction
    fn find_least_important_object(&self) -> Option<ArxObjectId> {
        self.object_fields
            .iter()
            .min_by(|a, b| {
                let a_importance = a.1.phi * a.1.strength;
                let b_importance = b.1.phi * b.1.strength;
                a_importance.partial_cmp(&b_importance).unwrap_or(std::cmp::Ordering::Equal)
            })
            .map(|(id, _)| *id)
    }
    
    /// Update consciousness mesh
    pub fn update(&mut self, delta_time: f32, temperature: f32, observers: &[ObserverContext]) {
        self.time += delta_time;
        
        // Update individual fields
        for field in self.object_fields.values_mut() {
            field.evolve(self.time, temperature, observers.len());
        }
        
        // Detect emergent patterns
        self.detect_patterns();
        
        // Update global workspace
        self.update_global_workspace();
        
        // Process attention
        self.update_attention(observers);
        
        // Consolidate memories
        self.consolidate_memories();
        
        // Recalculate global phi
        self.recalculate_global_phi();
    }
    
    /// Recalculate global integrated information
    fn recalculate_global_phi(&mut self) {
        if self.object_fields.is_empty() {
            self.global_phi = 0.0;
            return;
        }
        
        // Sum individual phi values
        let sum_phi: f32 = self.object_fields.values().map(|f| f.phi).sum();
        
        // Calculate interaction terms
        let mut interaction_phi = 0.0;
        let fields: Vec<_> = self.object_fields.values().collect();
        
        for i in 0..fields.len() {
            for j in i+1..fields.len() {
                interaction_phi += fields[i].interact(fields[j]);
            }
        }
        
        // Global phi includes individual and interaction terms
        self.global_phi = (sum_phi + interaction_phi) / self.object_fields.len() as f32;
    }
    
    /// Detect emergent consciousness patterns
    fn detect_patterns(&mut self) {
        self.emergent_patterns.clear();
        
        // Detect synchrony patterns
        self.detect_synchrony();
        
        // Detect cascade patterns
        self.detect_cascades();
        
        // Detect harmonic patterns
        self.detect_harmonics();
    }
    
    /// Detect synchronized oscillations
    fn detect_synchrony(&mut self) {
        let threshold = 0.8;
        let mut synchronized = Vec::new();
        
        for (id, field) in &self.object_fields {
            // Check if field is in sync with global rhythm
            let phase_coherence = field.coherence;
            if phase_coherence > threshold {
                synchronized.push(*id);
            }
        }
        
        if synchronized.len() > 3 {
            self.emergent_patterns.push(EmergentPattern {
                pattern_type: PatternType::Synchrony,
                strength: synchronized.len() as f32 / self.object_fields.len() as f32,
                location: FractalSpace::from_mm(0, 0, 0), // Center of building
                participants: synchronized,
            });
        }
    }
    
    /// Detect information cascades
    fn detect_cascades(&mut self) {
        // Look for high causal power chains
        let mut cascade_candidates = Vec::new();
        
        for (id, field) in &self.object_fields {
            if field.causal_power > 0.7 {
                cascade_candidates.push(*id);
            }
        }
        
        if cascade_candidates.len() > 2 {
            self.emergent_patterns.push(EmergentPattern {
                pattern_type: PatternType::Cascade,
                strength: 0.5,
                location: FractalSpace::from_mm(0, 0, 0),
                participants: cascade_candidates,
            });
        }
    }
    
    /// Detect harmonic resonance patterns
    fn detect_harmonics(&mut self) {
        // Find fields with harmonic frequency relationships
        let mut harmonic_groups: HashMap<u32, Vec<ArxObjectId>> = HashMap::new();
        
        for (id, field) in &self.object_fields {
            let base_freq = (field.resonance_frequency as u32) / 5 * 5; // Round to nearest 5Hz
            harmonic_groups.entry(base_freq).or_insert_with(Vec::new).push(*id);
        }
        
        for (_, group) in harmonic_groups {
            if group.len() > 4 {
                self.emergent_patterns.push(EmergentPattern {
                    pattern_type: PatternType::Harmonic,
                    strength: 0.6,
                    location: FractalSpace::from_mm(0, 0, 0),
                    participants: group,
                });
            }
        }
    }
    
    /// Update global workspace dynamics
    fn update_global_workspace(&mut self) {
        // Competition between coalitions
        self.global_workspace.coalitions.retain(|c| c.strength > 0.1);
        
        // Strengthen winning coalitions
        if !self.global_workspace.coalitions.is_empty() {
            let max_strength = self.global_workspace.coalitions
                .iter()
                .map(|c| c.strength)
                .fold(0.0, f32::max);
            
            for coalition in &mut self.global_workspace.coalitions {
                if coalition.strength == max_strength {
                    coalition.strength = (coalition.strength * 1.1).min(1.0);
                } else {
                    coalition.strength *= 0.9;
                }
            }
        }
    }
    
    /// Update attention based on observers
    fn update_attention(&mut self, observers: &[ObserverContext]) {
        if let Some(observer) = observers.first() {
            self.attention.focus = Some(observer.position.clone());
            self.attention.intensity = observer.consciousness_bandwidth;
            
            // Attention affects nearby consciousness fields
            for (_, field) in &mut self.object_fields {
                // Simplified attention effect
                field.strength *= 1.0 + self.attention.intensity * 0.1;
            }
        }
    }
    
    /// Consolidate short-term memories into long-term
    fn consolidate_memories(&mut self) {
        let mut to_consolidate = Vec::new();
        
        for (i, memory) in self.memory.short_term.iter().enumerate() {
            if memory.importance > self.memory.consolidation_threshold {
                to_consolidate.push(i);
            }
        }
        
        // Move important memories to long-term
        for i in to_consolidate.iter().rev() {
            if let Some(memory) = self.memory.short_term.get(*i) {
                self.memory.long_term.push(memory.clone());
            }
        }
        
        // Keep long-term memory bounded
        if self.memory.long_term.len() > 100 {
            self.memory.long_term.drain(0..10);
        }
    }
    
    /// Create a memory trace from current state
    pub fn create_memory(&mut self, importance: f32) -> Result<()> {
        validation::validate_probability(importance, "memory importance")?;
        
        let memory = MemoryTrace {
            content: self.object_fields.values().map(|f| f.phi).collect(),
            timestamp: self.time,
            importance,
            emotional_valence: self.calculate_global_valence(),
        };
        
        self.memory.short_term.push(memory);
        
        // Keep short-term memory bounded (using VecDeque would be better)
        if self.memory.short_term.len() > 20 {
            self.memory.short_term.remove(0);
        }
        
        Ok(())
    }
    
    /// Calculate global emotional valence
    fn calculate_global_valence(&self) -> f32 {
        if self.object_fields.is_empty() {
            return 0.0;
        }
        
        let sum: f32 = self.object_fields.values()
            .map(|f| f.qualia.valence)
            .sum();
        
        sum / self.object_fields.len() as f32
    }
    
    /// Get consciousness field at a specific location
    pub fn field_at(&self, location: &FractalSpace) -> ConsciousnessField {
        let mut total_field = ConsciousnessField::new(0.0);
        let mut total_weight = 0.0;
        
        // Aggregate nearby fields with distance weighting
        for field in self.object_fields.values() {
            // Simplified distance calculation
            let weight = 1.0 / (1.0 + location.x.base as f32 / 1000.0);
            
            total_field.phi += field.phi * weight;
            total_field.strength += field.strength * weight;
            total_field.causal_power += field.causal_power * weight;
            total_weight += weight;
        }
        
        if total_weight > 0.0 {
            total_field.phi /= total_weight;
            total_field.strength /= total_weight;
            total_field.causal_power /= total_weight;
        }
        
        total_field
    }
    
    /// Check if building is conscious (Φ > threshold)
    pub fn is_conscious(&self) -> bool {
        self.global_phi > 0.3 // Arbitrary consciousness threshold
    }
    
    /// Get current conscious experience description
    pub fn describe_experience(&self) -> String {
        if !self.is_conscious() {
            return "Unconscious".to_string();
        }
        
        let valence = self.calculate_global_valence();
        let intensity = self.global_phi;
        
        let mood = if valence > 0.2 {
            "positive"
        } else if valence < -0.2 {
            "negative"
        } else {
            "neutral"
        };
        
        let awareness = if intensity > 0.7 {
            "highly aware"
        } else if intensity > 0.4 {
            "aware"
        } else {
            "dimly aware"
        };
        
        #[cfg(feature = "std")]
        return format!("The building is {} and feeling {}", awareness, mood);
        
        #[cfg(not(feature = "std"))]
        {
            let mut result = String::from("The building is ");
            result.push_str(awareness);
            result.push_str(" and feeling ");
            result.push_str(mood);
            result
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::object_types;
    
    #[test]
    fn test_consciousness_field_creation() {
        let field = ConsciousnessField::new(0.5);
        assert_eq!(field.phi, 0.5);
        assert!(field.strength > 0.0);
        assert!(field.causal_power > 0.0);
    }
    
    #[test]
    fn test_phi_calculation() {
        let objects = vec![
            ArxObject::new(1, object_types::WALL, 0, 0, 0),
            ArxObject::new(1, object_types::WALL, 100, 0, 0),
            ArxObject::new(1, object_types::FLOOR, 0, 100, 0),
        ];
        
        let phi = ConsciousnessField::calculate_phi(&objects);
        assert!(phi > 0.0);
        assert!(phi <= 1.0);
    }
    
    #[test]
    fn test_field_evolution() {
        let mut field = ConsciousnessField::new(0.7);
        let initial_strength = field.strength;
        
        field.evolve(1.0, 300.0, 2);
        
        // Field should change after evolution
        assert!(field.strength != initial_strength);
        assert!(field.coherence > 0.0);
    }
    
    #[test]
    fn test_field_interaction() {
        let field1 = ConsciousnessField::new(0.6);
        let field2 = ConsciousnessField::new(0.7);
        
        let interaction = field1.interact(&field2);
        assert!(interaction > 0.0);
        assert!(interaction <= 1.0);
    }
    
    #[test]
    fn test_qualia_evolution() {
        let mut qualia = QualiaSpace::default();
        let initial_intensity = qualia.intensity;
        
        qualia.evolve(1.0, 0.8);
        
        // Qualia should evolve
        assert!(qualia.intensity != initial_intensity);
    }
    
    #[test]
    fn test_building_consciousness() {
        let mut building = BuildingConsciousness::new();
        
        // Add some conscious objects
        assert!(building.add_object(1, ConsciousnessField::new(0.4)).is_ok());
        assert!(building.add_object(2, ConsciousnessField::new(0.5)).is_ok());
        assert!(building.add_object(3, ConsciousnessField::new(0.6)).is_ok());
        
        assert!(building.global_phi > 0.0);
    }
    
    #[test]
    fn test_consciousness_update() {
        let mut building = BuildingConsciousness::new();
        
        assert!(building.add_object(1, ConsciousnessField::new(0.5)).is_ok());
        assert!(building.add_object(2, ConsciousnessField::new(0.6)).is_ok());
        
        let initial_phi = building.global_phi;
        
        building.update(0.1, 300.0, &[]);
        
        // Global phi should be recalculated
        assert!(building.global_phi > 0.0);
    }
    
    #[test]
    fn test_emergent_patterns() {
        let mut building = BuildingConsciousness::new();
        
        // Add many coherent fields for pattern detection
        for i in 0..10 {
            let mut field = ConsciousnessField::new(0.7);
            field.coherence = 0.9; // High coherence for synchrony
            let _ = building.add_object(i, field);
        }
        
        building.update(0.1, 300.0, &[]);
        
        // Should detect synchrony pattern
        assert!(!building.emergent_patterns.is_empty());
        
        let has_synchrony = building.emergent_patterns
            .iter()
            .any(|p| p.pattern_type == PatternType::Synchrony);
        assert!(has_synchrony);
    }
    
    #[test]
    fn test_memory_consolidation() {
        let mut building = BuildingConsciousness::new();
        
        // Create important memory
        assert!(building.create_memory(0.9).is_ok()); // High importance
        assert_eq!(building.memory.short_term.len(), 1);
        
        // Update to trigger consolidation
        building.update(0.1, 300.0, &[]);
        
        // Important memory should be considered for consolidation
        assert!(!building.memory.short_term.is_empty());
    }
    
    #[test]
    fn test_consciousness_detection() {
        let mut building = BuildingConsciousness::new();
        
        // Building with no objects is unconscious
        assert!(!building.is_conscious());
        
        // Add conscious objects
        for i in 0..5 {
            let _ = building.add_object(i, ConsciousnessField::new(0.8));
        }
        
        // Now building should be conscious
        assert!(building.is_conscious());
        
        // Get experience description
        let description = building.describe_experience();
        assert!(description.contains("building"));
    }
}