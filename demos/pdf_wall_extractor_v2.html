<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arxos - PDF Wall Extractor v2</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src='https://unpkg.com/tesseract.js@4.0.0/dist/tesseract.min.js'></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        /* Left Sidebar */
        .sidebar {
            width: 320px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #444;
        }
        
        .sidebar h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #fff;
            font-weight: 500;
        }
        
        .sidebar h3 {
            font-size: 14px;
            margin: 20px 0 10px 0;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Upload Zone */
        #upload-zone {
            border: 2px dashed #4a9eff;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
            background: rgba(74, 158, 255, 0.05);
        }
        
        #upload-zone:hover {
            background: rgba(74, 158, 255, 0.1);
            border-color: #6bb3ff;
        }
        
        #upload-zone.dragover {
            background: rgba(74, 158, 255, 0.2);
            border-color: #8cc5ff;
            transform: scale(1.02);
        }
        
        #file-input {
            display: none;
        }
        
        /* Controls */
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #bbb;
        }
        
        .slider {
            width: 100%;
            margin: 5px 0;
        }
        
        .slider-value {
            display: inline-block;
            float: right;
            color: #4a9eff;
            font-weight: 500;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        button:hover:not(:disabled) {
            background: #6bb3ff;
            transform: translateY(-1px);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }
        
        button.secondary {
            background: #444;
        }
        
        button.secondary:hover:not(:disabled) {
            background: #555;
        }
        
        button.danger {
            background: #ff4444;
        }
        
        button.danger:hover:not(:disabled) {
            background: #ff6666;
        }
        
        /* Stats Display */
        .stats {
            background: #333;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
            font-size: 13px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .stat-label {
            color: #999;
        }
        
        .stat-value {
            color: #4a9eff;
            font-weight: 500;
        }
        
        /* Main View */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
        }
        
        /* Toolbar */
        .toolbar {
            background: #2a2a2a;
            padding: 10px 20px;
            border-bottom: 1px solid #444;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .toolbar button {
            width: auto;
            padding: 6px 12px;
            margin: 0;
            font-size: 13px;
        }
        
        .toolbar .spacer {
            flex: 1;
        }
        
        .toolbar .info {
            color: #999;
            font-size: 13px;
        }
        
        /* Viewport */
        .viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0a0a0a;
        }
        
        .canvas-container {
            position: absolute;
            transform-origin: 0 0;
            cursor: grab;
        }
        
        .canvas-container:active {
            cursor: grabbing;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #pdf-canvas {
            opacity: 0.7;
        }
        
        #overlay-canvas {
            pointer-events: none;
        }
        
        /* Wall Edit Mode */
        .wall-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #4a9eff;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: move;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }
        
        .wall-handle:hover {
            background: #6bb3ff;
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        /* Status Messages */
        .status-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 2000;
            display: none;
        }
        
        .status-message.processing {
            background: #4a9eff;
            display: block;
        }
        
        .status-message.success {
            background: #4CAF50;
            display: block;
        }
        
        .status-message.error {
            background: #ff4444;
            display: block;
        }
        
        /* Mode Indicator */
        .mode-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            z-index: 1000;
        }
        
        .mode-indicator.detect {
            background: #4a9eff;
        }
        
        .mode-indicator.edit {
            background: #ff9f40;
        }
        
        .mode-indicator.draw {
            background: #4CAF50;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <h2>PDF Wall Extractor v2</h2>
            
            <!-- Upload -->
            <div id="upload-zone">
                <div style="font-size: 24px; margin-bottom: 10px;">üìÑ</div>
                <div style="font-size: 14px; margin-bottom: 5px;">Drop PDF here</div>
                <div style="font-size: 12px; color: #888;">or click to browse</div>
                <input type="file" id="file-input" accept=".pdf">
            </div>
            
            <!-- Detection Controls -->
            <h3>Detection Settings</h3>
            <div class="control-group">
                <label>
                    Edge Threshold
                    <span class="slider-value" id="threshold-value">50</span>
                </label>
                <input type="range" id="threshold-slider" class="slider" min="10" max="100" value="50">
            </div>
            
            <div class="control-group">
                <label>
                    Min Wall Length (px)
                    <span class="slider-value" id="min-length-value">30</span>
                </label>
                <input type="range" id="min-length-slider" class="slider" min="10" max="100" value="30">
            </div>
            
            <div class="control-group">
                <label>
                    Wall Thickness (px)
                    <span class="slider-value" id="thickness-value">3-15</span>
                </label>
                <input type="range" id="thickness-min-slider" class="slider" min="1" max="10" value="3">
                <input type="range" id="thickness-max-slider" class="slider" min="5" max="30" value="15">
            </div>
            
            <button id="detect-btn" onclick="wallExtractor.detectWalls()">üîç Detect Walls</button>
            <button id="clear-btn" class="secondary" onclick="wallExtractor.clearWalls()">üóëÔ∏è Clear All</button>
            
            <!-- Edit Controls -->
            <h3>Edit Mode</h3>
            <button id="select-mode-btn" onclick="wallExtractor.setMode('select')">‚úã Select/Move</button>
            <button id="draw-mode-btn" onclick="wallExtractor.setMode('draw')">‚úèÔ∏è Draw Wall</button>
            <button id="delete-mode-btn" class="danger" onclick="wallExtractor.setMode('delete')">‚ùå Delete</button>
            
            <!-- Statistics -->
            <div class="stats">
                <div class="stat-row">
                    <span class="stat-label">Detected Walls:</span>
                    <span class="stat-value" id="wall-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Selected:</span>
                    <span class="stat-value" id="selected-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Confidence Avg:</span>
                    <span class="stat-value" id="confidence-avg">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Processing Time:</span>
                    <span class="stat-value" id="process-time">0ms</span>
                </div>
            </div>
            
            <!-- Export -->
            <h3>Export</h3>
            <button id="export-json-btn" onclick="wallExtractor.exportJSON()">üíæ Export JSON</button>
            <button id="upload-backend-btn" onclick="wallExtractor.uploadToBackend()">‚òÅÔ∏è Upload to Backend</button>
        </div>
        
        <!-- Main View -->
        <div class="main">
            <!-- Toolbar -->
            <div class="toolbar">
                <button onclick="wallExtractor.zoomIn()">‚ûï</button>
                <button onclick="wallExtractor.zoomOut()">‚ûñ</button>
                <button onclick="wallExtractor.fitToScreen()">‚¨ú Fit</button>
                <button onclick="wallExtractor.resetView()">üîÑ Reset</button>
                <div class="spacer"></div>
                <span class="info">
                    Page <span id="page-num">1</span> of <span id="page-total">1</span>
                </span>
                <button id="prev-page" onclick="wallExtractor.prevPage()">‚óÄ</button>
                <button id="next-page" onclick="wallExtractor.nextPage()">‚ñ∂</button>
            </div>
            
            <!-- Viewport -->
            <div class="viewport" id="viewport">
                <div class="canvas-container" id="canvas-container">
                    <canvas id="pdf-canvas"></canvas>
                    <canvas id="overlay-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Status Message -->
    <div class="status-message" id="status-message"></div>
    
    <!-- Mode Indicator -->
    <div class="mode-indicator detect" id="mode-indicator">Detection Mode</div>
    
    <script>
        // PDF.js configuration
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        class WallExtractor {
            constructor() {
                // PDF Management
                this.pdfDoc = null;
                this.pageNum = 1;
                this.scale = 1.5;
                
                // Canvas Setup
                this.pdfCanvas = document.getElementById('pdf-canvas');
                this.pdfCtx = this.pdfCanvas.getContext('2d');
                this.overlayCanvas = document.getElementById('overlay-canvas');
                this.overlayCtx = this.overlayCanvas.getContext('2d');
                
                // Wall Data Structure
                this.walls = [];
                this.selectedWalls = new Set();
                this.nextWallId = 1;
                
                // Interaction State
                this.mode = 'detect'; // detect, select, draw, delete
                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = null;
                this.drawingWall = null;
                
                // View Transform
                this.viewScale = 1;
                this.viewOffset = { x: 0, y: 0 };
                
                // Initialize
                this.setupEventListeners();
                this.updateStats();
            }
            
            setupEventListeners() {
                // File Upload
                const uploadZone = document.getElementById('upload-zone');
                const fileInput = document.getElementById('file-input');
                
                uploadZone.addEventListener('click', () => fileInput.click());
                uploadZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadZone.classList.add('dragover');
                });
                uploadZone.addEventListener('dragleave', () => {
                    uploadZone.classList.remove('dragover');
                });
                uploadZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadZone.classList.remove('dragover');
                    const file = e.dataTransfer.files[0];
                    if (file && file.type === 'application/pdf') {
                        this.loadPDF(file);
                    }
                });
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) this.loadPDF(file);
                });
                
                // Viewport Interaction
                const viewport = document.getElementById('viewport');
                viewport.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                viewport.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                viewport.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                viewport.addEventListener('wheel', (e) => this.handleWheel(e));
                
                // Sliders
                document.getElementById('threshold-slider').addEventListener('input', (e) => {
                    document.getElementById('threshold-value').textContent = e.target.value;
                });
                document.getElementById('min-length-slider').addEventListener('input', (e) => {
                    document.getElementById('min-length-value').textContent = e.target.value;
                });
                document.getElementById('thickness-min-slider').addEventListener('input', () => {
                    this.updateThicknessDisplay();
                });
                document.getElementById('thickness-max-slider').addEventListener('input', () => {
                    this.updateThicknessDisplay();
                });
                
                // Keyboard
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
            }
            
            updateThicknessDisplay() {
                const min = document.getElementById('thickness-min-slider').value;
                const max = document.getElementById('thickness-max-slider').value;
                document.getElementById('thickness-value').textContent = `${min}-${max}`;
            }
            
            async loadPDF(file) {
                this.showStatus('Loading PDF...', 'processing');
                
                const arrayBuffer = await file.arrayBuffer();
                this.pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                document.getElementById('page-total').textContent = this.pdfDoc.numPages;
                
                await this.renderPage();
                this.fitToScreen();
                
                this.showStatus('PDF loaded successfully', 'success');
            }
            
            async renderPage() {
                if (!this.pdfDoc) return;
                
                const page = await this.pdfDoc.getPage(this.pageNum);
                const viewport = page.getViewport({ scale: this.scale });
                
                // Setup canvases
                this.pdfCanvas.width = viewport.width;
                this.pdfCanvas.height = viewport.height;
                this.overlayCanvas.width = viewport.width;
                this.overlayCanvas.height = viewport.height;
                
                // Render PDF
                await page.render({
                    canvasContext: this.pdfCtx,
                    viewport: viewport
                }).promise;
                
                document.getElementById('page-num').textContent = this.pageNum;
                
                // Clear walls when changing pages
                this.walls = [];
                this.renderOverlay();
            }
            
            async detectWalls() {
                if (!this.pdfDoc) {
                    this.showStatus('Please load a PDF first', 'error');
                    return;
                }
                
                const startTime = performance.now();
                this.showStatus('Detecting walls...', 'processing');
                
                // Get canvas image data
                const imageData = this.pdfCtx.getImageData(0, 0, this.pdfCanvas.width, this.pdfCanvas.height);
                
                // Process image to find walls
                const detectedWalls = this.processImage(imageData);
                
                // Convert to wall objects
                this.walls = detectedWalls.map(w => ({
                    id: this.nextWallId++,
                    x1: w.x1,
                    y1: w.y1,
                    x2: w.x2,
                    y2: w.y2,
                    thickness: w.thickness || 5,
                    confidence: w.confidence || 0.7,
                    type: 'detected',
                    selected: false,
                    modified: false
                }));
                
                const elapsed = performance.now() - startTime;
                document.getElementById('process-time').textContent = `${elapsed.toFixed(0)}ms`;
                
                this.updateStats();
                this.renderOverlay();
                
                this.showStatus(`Detected ${this.walls.length} walls`, 'success');
            }
            
            processImage(imageData) {
                const width = imageData.width;
                const height = imageData.height;
                const data = imageData.data;
                
                // Convert to grayscale
                const gray = new Uint8ClampedArray(width * height);
                for (let i = 0; i < data.length; i += 4) {
                    gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                }
                
                // Simple edge detection using Sobel
                const edges = this.sobelEdgeDetection(gray, width, height);
                
                // Find lines using simplified Hough transform
                const threshold = parseInt(document.getElementById('threshold-slider').value);
                const minLength = parseInt(document.getElementById('min-length-slider').value);
                
                return this.findLines(edges, width, height, threshold, minLength);
            }
            
            sobelEdgeDetection(gray, width, height) {
                const edges = new Uint8ClampedArray(width * height);
                const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
                const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let gx = 0, gy = 0;
                        
                        for (let j = -1; j <= 1; j++) {
                            for (let i = -1; i <= 1; i++) {
                                const idx = (y + j) * width + (x + i);
                                const kernelIdx = (j + 1) * 3 + (i + 1);
                                gx += gray[idx] * sobelX[kernelIdx];
                                gy += gray[idx] * sobelY[kernelIdx];
                            }
                        }
                        
                        edges[y * width + x] = Math.min(255, Math.sqrt(gx * gx + gy * gy));
                    }
                }
                
                return edges;
            }
            
            findLines(edges, width, height, threshold, minLength) {
                const lines = [];
                const visited = new Set();
                
                // Scan for horizontal lines
                for (let y = 0; y < height; y += 2) {
                    let lineStart = null;
                    
                    for (let x = 0; x < width; x++) {
                        const idx = y * width + x;
                        const isEdge = edges[idx] > threshold;
                        
                        if (isEdge && !lineStart) {
                            lineStart = x;
                        } else if (!isEdge && lineStart !== null) {
                            const length = x - lineStart;
                            if (length >= minLength) {
                                lines.push({
                                    x1: lineStart,
                                    y1: y,
                                    x2: x,
                                    y2: y,
                                    confidence: this.calculateLineConfidence(edges, lineStart, y, x, y, width)
                                });
                            }
                            lineStart = null;
                        }
                    }
                }
                
                // Scan for vertical lines
                for (let x = 0; x < width; x += 2) {
                    let lineStart = null;
                    
                    for (let y = 0; y < height; y++) {
                        const idx = y * width + x;
                        const isEdge = edges[idx] > threshold;
                        
                        if (isEdge && !lineStart) {
                            lineStart = y;
                        } else if (!isEdge && lineStart !== null) {
                            const length = y - lineStart;
                            if (length >= minLength) {
                                lines.push({
                                    x1: x,
                                    y1: lineStart,
                                    x2: x,
                                    y2: y,
                                    confidence: this.calculateLineConfidence(edges, x, lineStart, x, y, width)
                                });
                            }
                            lineStart = null;
                        }
                    }
                }
                
                // Merge nearby parallel lines
                return this.mergeNearbyLines(lines);
            }
            
            calculateLineConfidence(edges, x1, y1, x2, y2, width) {
                // Sample points along the line to calculate confidence
                const steps = 10;
                let totalStrength = 0;
                
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = Math.round(x1 + (x2 - x1) * t);
                    const y = Math.round(y1 + (y2 - y1) * t);
                    const idx = y * width + x;
                    totalStrength += edges[idx] / 255;
                }
                
                return totalStrength / (steps + 1);
            }
            
            mergeNearbyLines(lines) {
                const merged = [];
                const used = new Set();
                
                for (let i = 0; i < lines.length; i++) {
                    if (used.has(i)) continue;
                    
                    const line1 = lines[i];
                    let mergedLine = { ...line1 };
                    
                    for (let j = i + 1; j < lines.length; j++) {
                        if (used.has(j)) continue;
                        
                        const line2 = lines[j];
                        
                        // Check if lines are parallel and close
                        if (this.areLinesParallelAndClose(mergedLine, line2)) {
                            // Extend the merged line
                            mergedLine = this.extendLine(mergedLine, line2);
                            mergedLine.confidence = Math.max(mergedLine.confidence, line2.confidence);
                            used.add(j);
                        }
                    }
                    
                    merged.push(mergedLine);
                    used.add(i);
                }
                
                return merged;
            }
            
            areLinesParallelAndClose(line1, line2) {
                const threshold = 10; // pixels
                
                // Check if both horizontal
                if (Math.abs(line1.y1 - line1.y2) < 2 && Math.abs(line2.y1 - line2.y2) < 2) {
                    return Math.abs(line1.y1 - line2.y1) < threshold;
                }
                
                // Check if both vertical
                if (Math.abs(line1.x1 - line1.x2) < 2 && Math.abs(line2.x1 - line2.x2) < 2) {
                    return Math.abs(line1.x1 - line2.x1) < threshold;
                }
                
                return false;
            }
            
            extendLine(line1, line2) {
                // Combine two parallel lines into one longer line
                const isHorizontal = Math.abs(line1.y1 - line1.y2) < 2;
                
                if (isHorizontal) {
                    return {
                        x1: Math.min(line1.x1, line1.x2, line2.x1, line2.x2),
                        y1: (line1.y1 + line2.y1) / 2,
                        x2: Math.max(line1.x1, line1.x2, line2.x1, line2.x2),
                        y2: (line1.y2 + line2.y2) / 2,
                        confidence: Math.max(line1.confidence, line2.confidence)
                    };
                } else {
                    return {
                        x1: (line1.x1 + line2.x1) / 2,
                        y1: Math.min(line1.y1, line1.y2, line2.y1, line2.y2),
                        x2: (line1.x2 + line2.x2) / 2,
                        y2: Math.max(line1.y1, line1.y2, line2.y1, line2.y2),
                        confidence: Math.max(line1.confidence, line2.confidence)
                    };
                }
            }
            
            renderOverlay() {
                this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
                
                // Draw walls
                this.walls.forEach(wall => {
                    this.overlayCtx.strokeStyle = wall.selected ? '#ff9f40' : 
                                                 wall.type === 'user' ? '#4CAF50' :
                                                 `rgba(74, 158, 255, ${wall.confidence})`;
                    this.overlayCtx.lineWidth = wall.selected ? 3 : 2;
                    
                    this.overlayCtx.beginPath();
                    this.overlayCtx.moveTo(wall.x1, wall.y1);
                    this.overlayCtx.lineTo(wall.x2, wall.y2);
                    this.overlayCtx.stroke();
                    
                    // Draw endpoints for selected walls
                    if (wall.selected) {
                        this.overlayCtx.fillStyle = '#ff9f40';
                        this.overlayCtx.beginPath();
                        this.overlayCtx.arc(wall.x1, wall.y1, 4, 0, Math.PI * 2);
                        this.overlayCtx.fill();
                        this.overlayCtx.beginPath();
                        this.overlayCtx.arc(wall.x2, wall.y2, 4, 0, Math.PI * 2);
                        this.overlayCtx.fill();
                    }
                });
                
                // Draw current drawing wall
                if (this.drawingWall) {
                    this.overlayCtx.strokeStyle = '#4CAF50';
                    this.overlayCtx.lineWidth = 2;
                    this.overlayCtx.setLineDash([5, 5]);
                    this.overlayCtx.beginPath();
                    this.overlayCtx.moveTo(this.drawingWall.x1, this.drawingWall.y1);
                    this.overlayCtx.lineTo(this.drawingWall.x2, this.drawingWall.y2);
                    this.overlayCtx.stroke();
                    this.overlayCtx.setLineDash([]);
                }
            }
            
            handleMouseDown(e) {
                const rect = this.overlayCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.viewScale - this.viewOffset.x;
                const y = (e.clientY - rect.top) / this.viewScale - this.viewOffset.y;
                
                if (e.shiftKey || e.button === 1) {
                    // Pan mode
                    this.isPanning = true;
                    this.dragStart = { x: e.clientX, y: e.clientY };
                    return;
                }
                
                switch (this.mode) {
                    case 'select':
                        this.handleSelectMouseDown(x, y, e);
                        break;
                    case 'draw':
                        this.drawingWall = { x1: x, y1: y, x2: x, y2: y };
                        break;
                    case 'delete':
                        this.handleDeleteClick(x, y);
                        break;
                }
            }
            
            handleMouseMove(e) {
                const rect = this.overlayCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.viewScale - this.viewOffset.x;
                const y = (e.clientY - rect.top) / this.viewScale - this.viewOffset.y;
                
                if (this.isPanning && this.dragStart) {
                    const dx = e.clientX - this.dragStart.x;
                    const dy = e.clientY - this.dragStart.y;
                    this.viewOffset.x += dx / this.viewScale;
                    this.viewOffset.y += dy / this.viewScale;
                    this.dragStart = { x: e.clientX, y: e.clientY };
                    this.updateTransform();
                    return;
                }
                
                if (this.drawingWall) {
                    this.drawingWall.x2 = x;
                    this.drawingWall.y2 = y;
                    this.renderOverlay();
                }
                
                if (this.isDragging && this.selectedWalls.size > 0) {
                    const dx = x - this.dragStart.x;
                    const dy = y - this.dragStart.y;
                    
                    this.selectedWalls.forEach(id => {
                        const wall = this.walls.find(w => w.id === id);
                        if (wall) {
                            wall.x1 += dx;
                            wall.y1 += dy;
                            wall.x2 += dx;
                            wall.y2 += dy;
                            wall.modified = true;
                        }
                    });
                    
                    this.dragStart = { x, y };
                    this.renderOverlay();
                }
            }
            
            handleMouseUp(e) {
                if (this.isPanning) {
                    this.isPanning = false;
                    this.dragStart = null;
                    return;
                }
                
                if (this.drawingWall) {
                    const length = Math.sqrt(
                        Math.pow(this.drawingWall.x2 - this.drawingWall.x1, 2) +
                        Math.pow(this.drawingWall.y2 - this.drawingWall.y1, 2)
                    );
                    
                    if (length > 20) {
                        this.walls.push({
                            id: this.nextWallId++,
                            x1: this.drawingWall.x1,
                            y1: this.drawingWall.y1,
                            x2: this.drawingWall.x2,
                            y2: this.drawingWall.y2,
                            thickness: 5,
                            confidence: 1.0,
                            type: 'user',
                            selected: false,
                            modified: false
                        });
                        this.updateStats();
                    }
                    
                    this.drawingWall = null;
                    this.renderOverlay();
                }
                
                this.isDragging = false;
                this.dragStart = null;
            }
            
            handleWheel(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                this.viewScale *= delta;
                this.viewScale = Math.max(0.1, Math.min(5, this.viewScale));
                this.updateTransform();
            }
            
            handleKeyDown(e) {
                switch (e.key) {
                    case 'Delete':
                    case 'Backspace':
                        if (this.selectedWalls.size > 0) {
                            this.walls = this.walls.filter(w => !this.selectedWalls.has(w.id));
                            this.selectedWalls.clear();
                            this.updateStats();
                            this.renderOverlay();
                        }
                        break;
                    case 'a':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            this.walls.forEach(w => {
                                w.selected = true;
                                this.selectedWalls.add(w.id);
                            });
                            this.renderOverlay();
                        }
                        break;
                    case 'Escape':
                        this.selectedWalls.clear();
                        this.walls.forEach(w => w.selected = false);
                        this.drawingWall = null;
                        this.renderOverlay();
                        break;
                }
            }
            
            handleSelectMouseDown(x, y, e) {
                // Find wall near click
                const wall = this.findWallAt(x, y);
                
                if (wall) {
                    if (!e.ctrlKey && !e.metaKey) {
                        // Clear other selections
                        this.selectedWalls.clear();
                        this.walls.forEach(w => w.selected = false);
                    }
                    
                    wall.selected = !wall.selected;
                    if (wall.selected) {
                        this.selectedWalls.add(wall.id);
                    } else {
                        this.selectedWalls.delete(wall.id);
                    }
                    
                    this.isDragging = true;
                    this.dragStart = { x, y };
                } else {
                    // Clear selection
                    this.selectedWalls.clear();
                    this.walls.forEach(w => w.selected = false);
                }
                
                this.updateStats();
                this.renderOverlay();
            }
            
            handleDeleteClick(x, y) {
                const wall = this.findWallAt(x, y);
                if (wall) {
                    this.walls = this.walls.filter(w => w.id !== wall.id);
                    this.updateStats();
                    this.renderOverlay();
                }
            }
            
            findWallAt(x, y) {
                const threshold = 10;
                
                return this.walls.find(wall => {
                    // Calculate distance from point to line segment
                    const dist = this.pointToLineDistance(x, y, wall.x1, wall.y1, wall.x2, wall.y2);
                    return dist < threshold;
                });
            }
            
            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            setMode(mode) {
                this.mode = mode;
                const indicator = document.getElementById('mode-indicator');
                
                switch (mode) {
                    case 'select':
                        indicator.textContent = 'Select Mode';
                        indicator.className = 'mode-indicator edit';
                        break;
                    case 'draw':
                        indicator.textContent = 'Draw Mode';
                        indicator.className = 'mode-indicator draw';
                        break;
                    case 'delete':
                        indicator.textContent = 'Delete Mode';
                        indicator.className = 'mode-indicator error';
                        break;
                    default:
                        indicator.textContent = 'Detection Mode';
                        indicator.className = 'mode-indicator detect';
                }
            }
            
            clearWalls() {
                this.walls = [];
                this.selectedWalls.clear();
                this.updateStats();
                this.renderOverlay();
            }
            
            updateStats() {
                document.getElementById('wall-count').textContent = this.walls.length;
                document.getElementById('selected-count').textContent = this.selectedWalls.size;
                
                if (this.walls.length > 0) {
                    const avgConfidence = this.walls.reduce((sum, w) => sum + w.confidence, 0) / this.walls.length;
                    document.getElementById('confidence-avg').textContent = `${(avgConfidence * 100).toFixed(0)}%`;
                } else {
                    document.getElementById('confidence-avg').textContent = '0%';
                }
            }
            
            updateTransform() {
                const container = document.getElementById('canvas-container');
                container.style.transform = `scale(${this.viewScale}) translate(${this.viewOffset.x}px, ${this.viewOffset.y}px)`;
            }
            
            zoomIn() {
                this.viewScale *= 1.2;
                this.viewScale = Math.min(5, this.viewScale);
                this.updateTransform();
            }
            
            zoomOut() {
                this.viewScale *= 0.8;
                this.viewScale = Math.max(0.1, this.viewScale);
                this.updateTransform();
            }
            
            fitToScreen() {
                const viewport = document.getElementById('viewport');
                const vw = viewport.clientWidth;
                const vh = viewport.clientHeight;
                const cw = this.pdfCanvas.width;
                const ch = this.pdfCanvas.height;
                
                this.viewScale = Math.min(vw / cw, vh / ch) * 0.9;
                this.viewOffset = { x: 0, y: 0 };
                this.updateTransform();
            }
            
            resetView() {
                this.viewScale = 1;
                this.viewOffset = { x: 0, y: 0 };
                this.updateTransform();
            }
            
            async prevPage() {
                if (this.pageNum > 1) {
                    this.pageNum--;
                    await this.renderPage();
                }
            }
            
            async nextPage() {
                if (this.pdfDoc && this.pageNum < this.pdfDoc.numPages) {
                    this.pageNum++;
                    await this.renderPage();
                }
            }
            
            showStatus(message, type = 'info') {
                const status = document.getElementById('status-message');
                status.textContent = message;
                status.className = `status-message ${type}`;
                
                if (type !== 'processing') {
                    setTimeout(() => {
                        status.className = 'status-message';
                    }, 3000);
                }
            }
            
            exportJSON() {
                const data = {
                    walls: this.walls.map(w => ({
                        x1: w.x1,
                        y1: w.y1,
                        x2: w.x2,
                        y2: w.y2,
                        thickness: w.thickness,
                        confidence: w.confidence,
                        type: w.type
                    })),
                    metadata: {
                        pageNum: this.pageNum,
                        scale: this.scale,
                        canvasWidth: this.pdfCanvas.width,
                        canvasHeight: this.pdfCanvas.height,
                        timestamp: new Date().toISOString()
                    }
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `walls_page${this.pageNum}_${Date.now()}.json`;
                a.click();
                
                this.showStatus('Exported to JSON', 'success');
            }
            
            async uploadToBackend() {
                if (this.walls.length === 0) {
                    this.showStatus('No walls to upload', 'error');
                    return;
                }
                
                this.showStatus('Uploading to backend...', 'processing');
                
                // Convert walls to ArxObject format
                const arxObjects = this.walls.map(wall => {
                    // Calculate wall center and dimensions
                    const centerX = (wall.x1 + wall.x2) / 2;
                    const centerY = (wall.y1 + wall.y2) / 2;
                    const length = Math.sqrt(Math.pow(wall.x2 - wall.x1, 2) + Math.pow(wall.y2 - wall.y1, 2));
                    const angle = Math.atan2(wall.y2 - wall.y1, wall.x2 - wall.x1);
                    
                    return {
                        type: 'wall',
                        x: centerX,
                        y: centerY,
                        length: length,
                        thickness: wall.thickness,
                        rotation: angle * 180 / Math.PI,
                        confidence: wall.confidence,
                        source: wall.type
                    };
                });
                
                const payload = {
                    building_name: 'Test Building',
                    floor: this.pageNum,
                    objects: arxObjects,
                    metadata: {
                        canvas_width: this.pdfCanvas.width,
                        canvas_height: this.pdfCanvas.height,
                        pdf_scale: this.scale
                    }
                };
                
                try {
                    const response = await fetch('http://localhost:8080/api/buildings/upload', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        this.showStatus(`Uploaded ${arxObjects.length} walls successfully`, 'success');
                    } else {
                        throw new Error(`Upload failed: ${response.statusText}`);
                    }
                } catch (error) {
                    console.error('Upload error:', error);
                    this.showStatus('Upload failed - check console', 'error');
                }
            }
        }
        
        // Initialize
        const wallExtractor = new WallExtractor();
    </script>
</body>
</html>