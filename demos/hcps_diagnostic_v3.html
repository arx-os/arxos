<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HCPS BIM Diagnostic Tool v3 - 1:1 Accuracy</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #0a0a0a;
    color: #e0e0e0;
    padding: 10px;
}
.container {
    max-width: 1800px;
    margin: 0 auto;
}
h1 {
    background: linear-gradient(135deg, #4a9eff, #00ff88);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 10px;
    font-size: 22px;
}
.controls {
    display: flex;
    gap: 5px;
    margin-bottom: 10px;
    flex-wrap: wrap;
}
button {
    padding: 6px 12px;
    background: #1a2a3a;
    color: #e0e0e0;
    border: 1px solid #2a3a4a;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s;
}
button:hover {
    background: #2a3a4a;
    border-color: #3a4a5a;
}
button.primary {
    background: #4a9eff;
    border-color: #5aafff;
    color: #000;
    font-weight: 500;
}
button.active {
    background: #00ff88;
    color: #000;
}
.grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
}
.panel {
    background: #111;
    border: 1px solid #222;
    border-radius: 6px;
    overflow: hidden;
}
.panel-header {
    background: #1a1a1a;
    padding: 8px 12px;
    border-bottom: 1px solid #222;
    font-size: 13px;
    font-weight: 500;
    color: #4a9eff;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.panel-content {
    padding: 10px;
    position: relative;
}
canvas {
    width: 100%;
    height: 280px;
    border: 1px solid #2a2a2a;
    border-radius: 4px;
    background: #000;
    display: block;
}
.stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
    margin-top: 8px;
}
.stat {
    background: #0a0a0a;
    padding: 6px;
    border-radius: 3px;
    text-align: center;
    border: 1px solid #1a1a1a;
}
.stat-value {
    font-size: 16px;
    font-weight: bold;
    color: #4a9eff;
}
.stat-label {
    font-size: 9px;
    color: #666;
    text-transform: uppercase;
    margin-top: 2px;
}
.log {
    background: #0a0a0a;
    border: 1px solid #1a1a1a;
    border-radius: 4px;
    padding: 6px;
    height: 200px;
    overflow-y: auto;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 10px;
}
.log-entry { margin: 1px 0; padding: 1px 3px; }
.log-info { color: #888; }
.log-success { color: #4f4; }
.log-error { color: #f44; }
.log-warn { color: #fa0; }
.log-debug { color: #66f; }

.params {
    background: #0a0a0a;
    border: 1px solid #1a1a1a;
    border-radius: 4px;
    padding: 8px;
    margin-top: 8px;
}
.param-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 5px 0;
}
.param-label {
    font-size: 11px;
    color: #888;
}
.param-value {
    font-size: 11px;
    color: #4a9eff;
    font-weight: 500;
}
input[type="range"] {
    width: 100%;
    margin: 3px 0;
}
input[type="number"] {
    width: 60px;
    padding: 2px 4px;
    background: #1a1a1a;
    border: 1px solid #2a2a2a;
    color: #e0e0e0;
    border-radius: 3px;
    font-size: 11px;
}
.comparison {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 5px;
    margin-top: 8px;
}
.compare-stat {
    background: #0a0a0a;
    padding: 4px;
    border-radius: 3px;
    text-align: center;
    border: 1px solid #1a1a1a;
    font-size: 10px;
}
.accuracy-meter {
    height: 20px;
    background: #1a1a1a;
    border-radius: 3px;
    overflow: hidden;
    margin-top: 5px;
    position: relative;
}
.accuracy-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff4444, #ffaa00, #00ff88);
    transition: width 0.3s;
}
.accuracy-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 11px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 2px #000;
}
</style>
</head>
<body>

<div class="container">
    <h1>üéØ HCPS BIM Diagnostic Tool v3 - 1:1 Accuracy Mode</h1>
    
    <div class="controls">
        <input type="file" id="fileInput" accept=".pdf" style="display:none">
        <button class="primary" onclick="document.getElementById('fileInput').click()">üìÑ Upload PDF</button>
        <button onclick="Diagnostic.extract('pixel')">Pixel Scan</button>
        <button onclick="Diagnostic.extract('trace')">Line Trace</button>
        <button onclick="Diagnostic.extract('morphology')">Morphology</button>
        <button onclick="Diagnostic.extract('skeleton')">Skeleton</button>
        <button onclick="Diagnostic.extract('hybrid')">Hybrid AI</button>
        <button onclick="Diagnostic.toggleComparison()">Compare</button>
        <button onclick="Diagnostic.autoTune()">Auto-Tune</button>
        <button onclick="Diagnostic.exportPerfect()">Export Perfect</button>
        <button onclick="Diagnostic.clearAll()">Clear</button>
    </div>
    
    <div class="grid">
        <!-- PDF Original -->
        <div class="panel">
            <div class="panel-header">
                <span>üìÑ PDF Original</span>
                <span id="pdfInfo">No PDF</span>
            </div>
            <div class="panel-content">
                <canvas id="pdfCanvas"></canvas>
                <div class="params">
                    <div class="param-row">
                        <span class="param-label">Threshold</span>
                        <span class="param-value" id="thresholdValue">240</span>
                    </div>
                    <input type="range" id="threshold" min="200" max="255" value="240" step="1"
                           oninput="Diagnostic.setParam('threshold', this.value)">
                    
                    <div class="param-row">
                        <span class="param-label">Min Length</span>
                        <input type="number" id="minLength" value="10" min="5" max="50"
                               onchange="Diagnostic.setParam('minLength', this.value)">
                    </div>
                    
                    <div class="param-row">
                        <span class="param-label">Gap Tolerance</span>
                        <input type="number" id="gapTolerance" value="3" min="0" max="10"
                               onchange="Diagnostic.setParam('gapTolerance', this.value)">
                    </div>
                </div>
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="pdfWidth">0</div>
                        <div class="stat-label">Width</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="pdfHeight">0</div>
                        <div class="stat-label">Height</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="darkPixels">0</div>
                        <div class="stat-label">Dark px</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Binary/Edge Detection -->
        <div class="panel">
            <div class="panel-header">
                <span>üî¨ Detection</span>
                <span id="detectInfo">Ready</span>
            </div>
            <div class="panel-content">
                <canvas id="detectCanvas"></canvas>
                <div class="params">
                    <div class="param-row">
                        <span class="param-label">Edge Sensitivity</span>
                        <span class="param-value" id="edgeSensValue">3</span>
                    </div>
                    <input type="range" id="edgeSens" min="1" max="10" value="3"
                           oninput="Diagnostic.setParam('edgeSensitivity', this.value)">
                    
                    <div class="param-row">
                        <span class="param-label">Line Thickness</span>
                        <input type="number" id="thickness" value="1" min="1" max="5"
                               onchange="Diagnostic.setParam('thickness', this.value)">
                    </div>
                </div>
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="edgePixels">0</div>
                        <div class="stat-label">Edges</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="segments">0</div>
                        <div class="stat-label">Segments</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="junctions">0</div>
                        <div class="stat-label">Junctions</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Vectorization -->
        <div class="panel">
            <div class="panel-header">
                <span>üìê Vectorization</span>
                <span id="vectorInfo">Ready</span>
            </div>
            <div class="panel-content">
                <canvas id="vectorCanvas"></canvas>
                <div class="params">
                    <div class="param-row">
                        <span class="param-label">Merge Distance</span>
                        <input type="number" id="mergeDistance" value="5" min="0" max="20"
                               onchange="Diagnostic.setParam('mergeDistance', this.value)">
                    </div>
                    
                    <div class="param-row">
                        <span class="param-label">Angle Snap</span>
                        <input type="number" id="angleSnap" value="5" min="0" max="15"
                               onchange="Diagnostic.setParam('angleSnap', this.value)">
                    </div>
                    
                    <div class="param-row">
                        <span class="param-label">Extension</span>
                        <input type="number" id="extension" value="10" min="0" max="30"
                               onchange="Diagnostic.setParam('extension', this.value)">
                    </div>
                </div>
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="rawVectors">0</div>
                        <div class="stat-label">Raw</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="mergedVectors">0</div>
                        <div class="stat-label">Merged</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="finalVectors">0</div>
                        <div class="stat-label">Final</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- BIM Result -->
        <div class="panel">
            <div class="panel-header">
                <span>‚úÖ BIM Result</span>
                <span id="bimInfo">0 walls</span>
            </div>
            <div class="panel-content">
                <canvas id="bimCanvas"></canvas>
                <div class="accuracy-meter">
                    <div class="accuracy-fill" id="accuracyFill" style="width: 0%"></div>
                    <div class="accuracy-text" id="accuracyText">0%</div>
                </div>
                <div class="comparison">
                    <div class="compare-stat">
                        <div>Expected: <span id="expectedWalls">?</span></div>
                    </div>
                    <div class="compare-stat">
                        <div>Detected: <span id="detectedWalls">0</span></div>
                    </div>
                    <div class="compare-stat">
                        <div>Missing: <span id="missingWalls">?</span></div>
                    </div>
                    <div class="compare-stat">
                        <div>Extra: <span id="extraWalls">?</span></div>
                    </div>
                </div>
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="wallCount">0</div>
                        <div class="stat-label">Walls</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="roomCount">0</div>
                        <div class="stat-label">Rooms</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="thickness">0px</div>
                        <div class="stat-label">Wall Width</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="accuracy">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Analysis Log -->
    <div class="panel" style="margin-top: 10px;">
        <div class="panel-header">
            <span>üìä Analysis Log</span>
            <button onclick="Diagnostic.clearLog()" style="padding: 2px 8px; font-size: 10px;">Clear</button>
        </div>
        <div class="panel-content">
            <div class="log" id="log"></div>
        </div>
    </div>
</div>

<script>
// Diagnostic System v3 - 1:1 Accuracy Focus
const Diagnostic = {
    // Canvases
    pdfCanvas: null,
    pdfCtx: null,
    detectCanvas: null,
    detectCtx: null,
    vectorCanvas: null,
    vectorCtx: null,
    bimCanvas: null,
    bimCtx: null,
    
    // Data
    pdfData: null,
    imageData: null,
    binaryData: null,
    edgeData: null,
    vectors: [],
    walls: [],
    rooms: [],
    
    // Parameters
    params: {
        threshold: 240,
        minLength: 10,
        gapTolerance: 3,
        edgeSensitivity: 3,
        thickness: 1,
        mergeDistance: 5,
        angleSnap: 5,
        extension: 10,
        method: 'hybrid'
    },
    
    // State
    zoom: 1.0,
    pan: { x: 0, y: 0 },
    comparing: false,
    groundTruth: null,
    
    init() {
        this.log('üöÄ Initializing v3 - 1:1 Accuracy Mode', 'success');
        
        // Setup canvases
        this.pdfCanvas = document.getElementById('pdfCanvas');
        this.pdfCtx = this.pdfCanvas.getContext('2d', { willReadFrequently: true });
        
        this.detectCanvas = document.getElementById('detectCanvas');
        this.detectCtx = this.detectCanvas.getContext('2d');
        
        this.vectorCanvas = document.getElementById('vectorCanvas');
        this.vectorCtx = this.vectorCanvas.getContext('2d');
        
        this.bimCanvas = document.getElementById('bimCanvas');
        this.bimCtx = this.bimCanvas.getContext('2d');
        
        // Set sizes
        [this.pdfCanvas, this.detectCanvas, this.vectorCanvas, this.bimCanvas].forEach(canvas => {
            canvas.width = 400;
            canvas.height = 280;
        });
        
        // BIM canvas interaction
        this.bimCanvas.onmousedown = (e) => this.mouseDown(e);
        this.bimCanvas.onmousemove = (e) => this.mouseMove(e);
        this.bimCanvas.onmouseup = (e) => this.mouseUp(e);
        this.bimCanvas.onwheel = (e) => this.wheel(e);
        
        // File input
        document.getElementById('fileInput').onchange = (e) => this.handleFile(e);
        
        this.renderBIM();
        this.log('‚úÖ System ready for 1:1 extraction', 'success');
    },
    
    log(msg, type = 'info') {
        const log = document.getElementById('log');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        const time = new Date().toLocaleTimeString();
        entry.textContent = `[${time}] ${msg}`;
        log.appendChild(entry);
        log.scrollTop = log.scrollHeight;
        console.log(`[${type}] ${msg}`);
    },
    
    clearLog() {
        document.getElementById('log').innerHTML = '';
    },
    
    async handleFile(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        this.log(`üìÑ Loading: ${file.name}`, 'info');
        
        try {
            const arrayBuffer = await file.arrayBuffer();
            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
            const pdf = await loadingTask.promise;
            
            this.log(`‚úÖ PDF loaded: ${pdf.numPages} pages`, 'success');
            
            const page = await pdf.getPage(1);
            const scale = 3.0; // Higher resolution for better accuracy
            const viewport = page.getViewport({ scale });
            
            // Update info
            document.getElementById('pdfInfo').textContent = `${Math.round(viewport.width)}√ó${Math.round(viewport.height)}`;
            document.getElementById('pdfWidth').textContent = Math.round(viewport.width);
            document.getElementById('pdfHeight').textContent = Math.round(viewport.height);
            
            // Render at high resolution
            this.pdfCanvas.width = viewport.width;
            this.pdfCanvas.height = viewport.height;
            
            await page.render({
                canvasContext: this.pdfCtx,
                viewport: viewport
            }).promise;
            
            this.log(`‚úÖ Rendered at ${scale}x scale`, 'success');
            
            // Store data
            this.pdfData = {
                width: viewport.width,
                height: viewport.height,
                scale: scale,
                filename: file.name
            };
            
            // Get image data
            this.imageData = this.pdfCtx.getImageData(0, 0, viewport.width, viewport.height);
            
            // Auto-extract
            this.extract('hybrid');
            
        } catch (error) {
            this.log(`‚ùå Error: ${error.message}`, 'error');
        }
    },
    
    extract(method) {
        if (!this.imageData) {
            this.log('‚ùå No PDF loaded', 'error');
            return;
        }
        
        this.log(`üîç Extracting with ${method} method`, 'info');
        this.params.method = method;
        
        const startTime = performance.now();
        
        // Step 1: Preprocessing
        this.preprocess();
        
        // Step 2: Line detection based on method
        switch (method) {
            case 'pixel':
                this.pixelScan();
                break;
            case 'trace':
                this.lineTrace();
                break;
            case 'morphology':
                this.morphologyExtract();
                break;
            case 'skeleton':
                this.skeletonize();
                break;
            case 'hybrid':
                this.hybridExtract();
                break;
        }
        
        // Step 3: Vectorization
        this.vectorize();
        
        // Step 4: Post-processing
        this.postProcess();
        
        // Step 5: Room detection
        this.detectRooms();
        
        // Step 6: Calculate accuracy
        this.calculateAccuracy();
        
        const elapsed = performance.now() - startTime;
        this.log(`‚úÖ Extraction complete in ${elapsed.toFixed(1)}ms`, 'success');
        
        // Render all views
        this.renderAll();
    },
    
    preprocess() {
        const { width, height } = this.pdfData;
        const data = this.imageData.data;
        
        // Create binary image
        this.binaryData = new Uint8Array(width * height);
        let darkCount = 0;
        
        for (let i = 0; i < data.length; i += 4) {
            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
            const idx = i / 4;
            
            if (brightness < this.params.threshold) {
                this.binaryData[idx] = 255;
                darkCount++;
            }
        }
        
        document.getElementById('darkPixels').textContent = darkCount;
        
        // Apply morphological operations to clean up
        this.binaryData = this.morphologicalClean(this.binaryData, width, height);
        
        this.log(`Preprocessed: ${darkCount} dark pixels`, 'debug');
    },
    
    morphologicalClean(binary, width, height) {
        // Erosion followed by dilation (opening) to remove noise
        let result = new Uint8Array(binary);
        
        // Simple 3x3 erosion
        const eroded = new Uint8Array(width * height);
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const idx = y * width + x;
                
                // Check if all neighbors are set
                let allSet = true;
                for (let dy = -1; dy <= 1 && allSet; dy++) {
                    for (let dx = -1; dx <= 1 && allSet; dx++) {
                        if (binary[(y + dy) * width + (x + dx)] === 0) {
                            allSet = false;
                        }
                    }
                }
                
                eroded[idx] = allSet ? 255 : 0;
            }
        }
        
        // Simple 3x3 dilation
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const idx = y * width + x;
                
                // Check if any neighbor is set
                let anySet = false;
                for (let dy = -1; dy <= 1 && !anySet; dy++) {
                    for (let dx = -1; dx <= 1 && !anySet; dx++) {
                        if (eroded[(y + dy) * width + (x + dx)] > 0) {
                            anySet = true;
                        }
                    }
                }
                
                result[idx] = anySet ? 255 : 0;
            }
        }
        
        return result;
    },
    
    pixelScan() {
        const { width, height } = this.pdfData;
        const segments = [];
        
        // Horizontal scan
        for (let y = 0; y < height; y++) {
            let start = -1;
            let length = 0;
            
            for (let x = 0; x < width; x++) {
                const idx = y * width + x;
                
                if (this.binaryData[idx] > 0) {
                    if (start === -1) start = x;
                    length++;
                } else {
                    if (start !== -1 && length >= this.params.minLength) {
                        segments.push({
                            x1: start, y1: y,
                            x2: start + length - 1, y2: y,
                            type: 'horizontal'
                        });
                    }
                    start = -1;
                    length = 0;
                }
            }
            
            // Handle line at edge
            if (start !== -1 && length >= this.params.minLength) {
                segments.push({
                    x1: start, y1: y,
                    x2: width - 1, y2: y,
                    type: 'horizontal'
                });
            }
        }
        
        // Vertical scan
        for (let x = 0; x < width; x++) {
            let start = -1;
            let length = 0;
            
            for (let y = 0; y < height; y++) {
                const idx = y * width + x;
                
                if (this.binaryData[idx] > 0) {
                    if (start === -1) start = y;
                    length++;
                } else {
                    if (start !== -1 && length >= this.params.minLength) {
                        segments.push({
                            x1: x, y1: start,
                            x2: x, y2: start + length - 1,
                            type: 'vertical'
                        });
                    }
                    start = -1;
                    length = 0;
                }
            }
            
            // Handle line at edge
            if (start !== -1 && length >= this.params.minLength) {
                segments.push({
                    x1: x, y1: start,
                    x2: x, y2: height - 1,
                    type: 'vertical'
                });
            }
        }
        
        this.vectors = segments;
        document.getElementById('segments').textContent = segments.length;
        this.log(`Pixel scan: ${segments.length} segments`, 'debug');
    },
    
    lineTrace() {
        // Advanced line tracing with gap tolerance
        const { width, height } = this.pdfData;
        const visited = new Uint8Array(width * height);
        const segments = [];
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const idx = y * width + x;
                
                if (this.binaryData[idx] > 0 && !visited[idx]) {
                    // Try to trace a line from this point
                    const line = this.traceLine(x, y, visited);
                    if (line) segments.push(line);
                }
            }
        }
        
        this.vectors = segments;
        document.getElementById('segments').textContent = segments.length;
        this.log(`Line trace: ${segments.length} segments`, 'debug');
    },
    
    traceLine(startX, startY, visited) {
        const { width, height } = this.pdfData;
        const directions = [
            { dx: 1, dy: 0, type: 'horizontal' },
            { dx: 0, dy: 1, type: 'vertical' },
            { dx: 1, dy: 1, type: 'diagonal1' },
            { dx: 1, dy: -1, type: 'diagonal2' }
        ];
        
        let bestLine = null;
        let maxLength = 0;
        
        for (const dir of directions) {
            let x = startX;
            let y = startY;
            let length = 0;
            let gaps = 0;
            
            // Trace in positive direction
            while (x >= 0 && x < width && y >= 0 && y < height) {
                const idx = y * width + x;
                
                if (this.binaryData[idx] > 0) {
                    length++;
                    gaps = 0;
                } else {
                    gaps++;
                    if (gaps > this.params.gapTolerance) break;
                }
                
                x += dir.dx;
                y += dir.dy;
            }
            
            if (length > maxLength && length >= this.params.minLength) {
                maxLength = length;
                bestLine = {
                    x1: startX,
                    y1: startY,
                    x2: x - dir.dx * (gaps + 1),
                    y2: y - dir.dy * (gaps + 1),
                    type: dir.type,
                    length: length
                };
            }
        }
        
        // Mark as visited
        if (bestLine) {
            let x = bestLine.x1;
            let y = bestLine.y1;
            const dx = Math.sign(bestLine.x2 - bestLine.x1);
            const dy = Math.sign(bestLine.y2 - bestLine.y1);
            
            while ((dx === 0 || (dx > 0 ? x <= bestLine.x2 : x >= bestLine.x2)) &&
                   (dy === 0 || (dy > 0 ? y <= bestLine.y2 : y >= bestLine.y2))) {
                const idx = y * width + x;
                visited[idx] = 1;
                x += dx;
                y += dy;
            }
        }
        
        return bestLine;
    },
    
    morphologyExtract() {
        // Use morphological operations to extract lines
        const { width, height } = this.pdfData;
        
        // Apply horizontal and vertical line kernels
        const hLines = this.detectWithKernel(this.binaryData, width, height, 'horizontal');
        const vLines = this.detectWithKernel(this.binaryData, width, height, 'vertical');
        
        this.vectors = [...hLines, ...vLines];
        document.getElementById('segments').textContent = this.vectors.length;
        this.log(`Morphology: ${this.vectors.length} segments`, 'debug');
    },
    
    detectWithKernel(binary, width, height, orientation) {
        const lines = [];
        const kernelSize = orientation === 'horizontal' ? [1, 20] : [20, 1];
        
        // Simplified line detection with morphological kernel
        for (let y = 0; y < height; y += 2) {
            for (let x = 0; x < width; x += 2) {
                if (orientation === 'horizontal') {
                    // Check for horizontal line
                    let consecutive = 0;
                    for (let dx = 0; dx < kernelSize[1] && x + dx < width; dx++) {
                        if (binary[y * width + x + dx] > 0) consecutive++;
                        else break;
                    }
                    
                    if (consecutive >= this.params.minLength) {
                        lines.push({
                            x1: x, y1: y,
                            x2: x + consecutive - 1, y2: y,
                            type: 'horizontal'
                        });
                        x += consecutive; // Skip processed pixels
                    }
                } else {
                    // Check for vertical line
                    let consecutive = 0;
                    for (let dy = 0; dy < kernelSize[0] && y + dy < height; dy++) {
                        if (binary[(y + dy) * width + x] > 0) consecutive++;
                        else break;
                    }
                    
                    if (consecutive >= this.params.minLength) {
                        lines.push({
                            x1: x, y1: y,
                            x2: x, y2: y + consecutive - 1,
                            type: 'vertical'
                        });
                    }
                }
            }
        }
        
        return lines;
    },
    
    skeletonize() {
        // Zhang-Suen thinning algorithm for skeletonization
        const { width, height } = this.pdfData;
        const skeleton = this.zhangSuenThinning(this.binaryData, width, height);
        
        // Extract line segments from skeleton
        this.vectors = this.extractFromSkeleton(skeleton, width, height);
        document.getElementById('segments').textContent = this.vectors.length;
        this.log(`Skeleton: ${this.vectors.length} segments`, 'debug');
    },
    
    zhangSuenThinning(binary, width, height) {
        const result = new Uint8Array(binary);
        let changed = true;
        
        while (changed) {
            changed = false;
            const toDelete = [];
            
            // First sub-iteration
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    if (result[idx] === 0) continue;
                    
                    const neighbors = this.getNeighbors(result, x, y, width);
                    const transitions = this.countTransitions(neighbors);
                    const blacks = neighbors.filter(n => n > 0).length;
                    
                    if (blacks >= 2 && blacks <= 6 && transitions === 1) {
                        if ((neighbors[0] === 0 || neighbors[2] === 0 || neighbors[4] === 0) &&
                            (neighbors[2] === 0 || neighbors[4] === 0 || neighbors[6] === 0)) {
                            toDelete.push(idx);
                        }
                    }
                }
            }
            
            if (toDelete.length > 0) {
                changed = true;
                toDelete.forEach(idx => result[idx] = 0);
            }
        }
        
        return result;
    },
    
    getNeighbors(data, x, y, width) {
        // Get 8-connected neighbors in clockwise order starting from top
        return [
            data[(y - 1) * width + x],      // N
            data[(y - 1) * width + (x + 1)], // NE
            data[y * width + (x + 1)],       // E
            data[(y + 1) * width + (x + 1)], // SE
            data[(y + 1) * width + x],       // S
            data[(y + 1) * width + (x - 1)], // SW
            data[y * width + (x - 1)],       // W
            data[(y - 1) * width + (x - 1)]  // NW
        ];
    },
    
    countTransitions(neighbors) {
        let count = 0;
        for (let i = 0; i < 8; i++) {
            const current = neighbors[i];
            const next = neighbors[(i + 1) % 8];
            if (current === 0 && next > 0) count++;
        }
        return count;
    },
    
    extractFromSkeleton(skeleton, width, height) {
        // Extract line segments from skeleton image
        const segments = [];
        const visited = new Uint8Array(width * height);
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const idx = y * width + x;
                
                if (skeleton[idx] > 0 && !visited[idx]) {
                    const segment = this.traceSkeletonLine(x, y, skeleton, visited, width, height);
                    if (segment) segments.push(segment);
                }
            }
        }
        
        return segments;
    },
    
    traceSkeletonLine(startX, startY, skeleton, visited, width, height) {
        // Trace connected skeleton pixels
        const points = [];
        const queue = [{x: startX, y: startY}];
        
        while (queue.length > 0) {
            const {x, y} = queue.shift();
            const idx = y * width + x;
            
            if (visited[idx]) continue;
            visited[idx] = 1;
            points.push({x, y});
            
            // Check 8-connected neighbors
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const nidx = ny * width + nx;
                        if (skeleton[nidx] > 0 && !visited[nidx]) {
                            queue.push({x: nx, y: ny});
                        }
                    }
                }
            }
        }
        
        // Fit line to points
        if (points.length >= this.params.minLength) {
            return this.fitLineToPoints(points);
        }
        
        return null;
    },
    
    fitLineToPoints(points) {
        // Simple line fitting - find endpoints
        const first = points[0];
        const last = points[points.length - 1];
        
        // Determine if more horizontal or vertical
        const dx = Math.abs(last.x - first.x);
        const dy = Math.abs(last.y - first.y);
        
        return {
            x1: first.x,
            y1: first.y,
            x2: last.x,
            y2: last.y,
            type: dx > dy ? 'horizontal' : 'vertical',
            confidence: points.length
        };
    },
    
    hybridExtract() {
        // Combine multiple methods for best results
        this.log('Hybrid extraction combining all methods', 'info');
        
        // First detect wall thickness
        const thickness = this.detectWallThickness();
        document.getElementById('thickness').textContent = thickness + 'px';
        this.log(`Detected wall thickness: ${thickness}px`, 'info');
        
        // Run all methods
        const pixelVectors = [];
        this.pixelScan();
        pixelVectors.push(...this.vectors);
        
        const traceVectors = [];
        this.lineTrace();
        traceVectors.push(...this.vectors);
        
        // Add thickness info to all vectors
        const allVectors = [...pixelVectors, ...traceVectors];
        allVectors.forEach(v => v.thickness = thickness);
        
        // Combine and deduplicate
        this.vectors = this.deduplicateVectors(allVectors);
        
        document.getElementById('segments').textContent = this.vectors.length;
        this.log(`Hybrid: ${this.vectors.length} unique segments`, 'debug');
    },
    
    detectWallThickness() {
        const { width, height } = this.pdfData;
        const samples = [];
        
        // Sample horizontal wall thickness at multiple Y positions
        for (let y = Math.floor(height * 0.1); y < height * 0.9; y += Math.floor(height * 0.05)) {
            let inWall = false;
            let thickness = 0;
            
            for (let x = 0; x < width; x++) {
                const idx = y * width + x;
                
                if (this.binaryData[idx] === 255) {
                    if (!inWall) {
                        inWall = true;
                        thickness = 1;
                    } else {
                        thickness++;
                    }
                } else {
                    if (inWall) {
                        // Valid wall thickness range: 2-30 pixels
                        if (thickness >= 2 && thickness <= 30) {
                            samples.push(thickness);
                        }
                        inWall = false;
                        thickness = 0;
                    }
                }
            }
        }
        
        // Sample vertical wall thickness at multiple X positions
        for (let x = Math.floor(width * 0.1); x < width * 0.9; x += Math.floor(width * 0.05)) {
            let inWall = false;
            let thickness = 0;
            
            for (let y = 0; y < height; y++) {
                const idx = y * width + x;
                
                if (this.binaryData[idx] === 255) {
                    if (!inWall) {
                        inWall = true;
                        thickness = 1;
                    } else {
                        thickness++;
                    }
                } else {
                    if (inWall) {
                        // Valid wall thickness range: 2-30 pixels
                        if (thickness >= 2 && thickness <= 30) {
                            samples.push(thickness);
                        }
                        inWall = false;
                        thickness = 0;
                    }
                }
            }
        }
        
        if (samples.length === 0) return 3; // Default thickness
        
        // Find mode (most common thickness)
        const frequency = {};
        let maxFreq = 0;
        let modeThickness = 3;
        
        for (const thickness of samples) {
            frequency[thickness] = (frequency[thickness] || 0) + 1;
            if (frequency[thickness] > maxFreq) {
                maxFreq = frequency[thickness];
                modeThickness = thickness;
            }
        }
        
        return modeThickness;
    },
    
    deduplicateVectors(vectors) {
        const unique = [];
        const threshold = 5;
        
        for (const v1 of vectors) {
            let isDuplicate = false;
            
            for (const v2 of unique) {
                const d1 = Math.hypot(v1.x1 - v2.x1, v1.y1 - v2.y1);
                const d2 = Math.hypot(v1.x2 - v2.x2, v1.y2 - v2.y2);
                
                if (d1 < threshold && d2 < threshold) {
                    isDuplicate = true;
                    break;
                }
            }
            
            if (!isDuplicate) {
                unique.push(v1);
            }
        }
        
        return unique;
    },
    
    vectorize() {
        // Convert segments to clean vectors
        const { width, height } = this.pdfData;
        
        // Keep original coordinates, just copy the vectors
        this.walls = this.vectors.map(v => ({
            id: 'w' + Math.random().toString(36).substr(2, 9),
            x1: v.x1,
            y1: v.y1,
            x2: v.x2,
            y2: v.y2,
            type: v.type,
            confidence: v.confidence || 1.0
        }));
        
        document.getElementById('rawVectors').textContent = this.walls.length;
        
        // Merge nearby parallel walls
        this.walls = this.mergeParallel(this.walls);
        document.getElementById('mergedVectors').textContent = this.walls.length;
        
        // Extend walls to meet
        this.walls = this.extendWalls(this.walls);
        
        // Snap to angles
        this.walls = this.snapAngles(this.walls);
        
        document.getElementById('finalVectors').textContent = this.walls.length;
    },
    
    mergeParallel(walls) {
        // Enhanced merging with intelligent gap detection
        let merged = this.intelligentMerge(walls);
        
        // Snap nearby corners together
        merged = this.snapCorners(merged);
        
        // Fill small gaps between walls
        merged = this.fillSmallGaps(merged);
        
        // Final cleanup pass
        merged = this.finalCleanup(merged);
        
        return merged;
    },
    
    intelligentMerge(walls) {
        const merged = [];
        const used = new Set();
        
        // Sort walls for better processing
        const sorted = [...walls].sort((a, b) => {
            if (a.type === 'horizontal') return a.y1 - b.y1 || a.x1 - b.x1;
            return a.x1 - b.x1 || a.y1 - b.y1;
        });
        
        for (let i = 0; i < sorted.length; i++) {
            if (used.has(i)) continue;
            
            const base = sorted[i];
            const candidates = [base];
            used.add(i);
            
            // Find all walls that should merge with this one
            for (let j = i + 1; j < sorted.length; j++) {
                if (used.has(j)) continue;
                
                const other = sorted[j];
                
                // Check if walls should be merged
                if (this.shouldMerge(base, other, candidates)) {
                    candidates.push(other);
                    used.add(j);
                }
            }
            
            // Create merged wall from candidates
            if (candidates.length > 1) {
                merged.push(this.createMergedWall(candidates));
            } else {
                merged.push(base);
            }
        }
        
        return merged;
    },
    
    shouldMerge(base, other, existingGroup) {
        // Enhanced merging logic
        if (base.type !== other.type) return false;
        
        // Check alignment
        const aligned = this.areAligned(base, other);
        if (!aligned) return false;
        
        // Check if connected to any wall in the group
        for (const wall of existingGroup) {
            if (this.canConnect(wall, other)) {
                return true;
            }
        }
        
        return false;
    },
    
    areAligned(w1, w2) {
        const alignTolerance = 3; // Pixels tolerance
        
        if (w1.type === 'horizontal') {
            // Average Y position should be close
            const y1 = (w1.y1 + w1.y2) / 2;
            const y2 = (w2.y1 + w2.y2) / 2;
            return Math.abs(y1 - y2) < alignTolerance;
        } else if (w1.type === 'vertical') {
            // Average X position should be close
            const x1 = (w1.x1 + w1.x2) / 2;
            const x2 = (w2.x1 + w2.x2) / 2;
            return Math.abs(x1 - x2) < alignTolerance;
        }
        
        return false;
    },
    
    canConnect(w1, w2) {
        const maxGap = this.params.mergeDistance * 2; // Allow larger gaps
        
        if (w1.type === 'horizontal') {
            const min1 = Math.min(w1.x1, w1.x2);
            const max1 = Math.max(w1.x1, w1.x2);
            const min2 = Math.min(w2.x1, w2.x2);
            const max2 = Math.max(w2.x1, w2.x2);
            
            // Check for overlap
            if (max1 >= min2 && min1 <= max2) return true;
            
            // Check gap size
            const gap = Math.min(Math.abs(max1 - min2), Math.abs(max2 - min1));
            return gap <= maxGap;
        } else if (w1.type === 'vertical') {
            const min1 = Math.min(w1.y1, w1.y2);
            const max1 = Math.max(w1.y1, w1.y2);
            const min2 = Math.min(w2.y1, w2.y2);
            const max2 = Math.max(w2.y1, w2.y2);
            
            // Check for overlap
            if (max1 >= min2 && min1 <= max2) return true;
            
            // Check gap size
            const gap = Math.min(Math.abs(max1 - min2), Math.abs(max2 - min1));
            return gap <= maxGap;
        }
        
        return false;
    },
    
    createMergedWall(candidates) {
        const type = candidates[0].type;
        
        if (type === 'horizontal') {
            // Find consensus Y position (weighted average)
            let totalY = 0, totalWeight = 0;
            let minX = Infinity, maxX = -Infinity;
            
            for (const wall of candidates) {
                const length = Math.abs(wall.x2 - wall.x1);
                totalY += wall.y1 * length;
                totalWeight += length;
                minX = Math.min(minX, wall.x1, wall.x2);
                maxX = Math.max(maxX, wall.x1, wall.x2);
            }
            
            const y = totalY / totalWeight;
            
            return {
                type: 'horizontal',
                x1: minX,
                y1: y,
                x2: maxX,
                y2: y,
                confidence: Math.max(...candidates.map(w => w.confidence || 0.5))
            };
        } else {
            // Find consensus X position (weighted average)
            let totalX = 0, totalWeight = 0;
            let minY = Infinity, maxY = -Infinity;
            
            for (const wall of candidates) {
                const length = Math.abs(wall.y2 - wall.y1);
                totalX += wall.x1 * length;
                totalWeight += length;
                minY = Math.min(minY, wall.y1, wall.y2);
                maxY = Math.max(maxY, wall.y1, wall.y2);
            }
            
            const x = totalX / totalWeight;
            
            return {
                type: 'vertical',
                x1: x,
                y1: minY,
                x2: x,
                y2: maxY,
                confidence: Math.max(...candidates.map(w => w.confidence || 0.5))
            };
        }
    },
    
    snapCorners(walls) {
        const snapDistance = 8; // Pixels to snap
        const snapped = [...walls];
        
        // Find all corners (wall endpoints)
        const corners = [];
        for (let i = 0; i < walls.length; i++) {
            const wall = walls[i];
            corners.push({ x: wall.x1, y: wall.y1, wallIdx: i, end: 'start' });
            corners.push({ x: wall.x2, y: wall.y2, wallIdx: i, end: 'end' });
        }
        
        // Find corner clusters
        const clusters = [];
        const used = new Set();
        
        for (let i = 0; i < corners.length; i++) {
            if (used.has(i)) continue;
            
            const cluster = [corners[i]];
            used.add(i);
            
            for (let j = i + 1; j < corners.length; j++) {
                if (used.has(j)) continue;
                
                const dist = Math.hypot(
                    corners[i].x - corners[j].x,
                    corners[i].y - corners[j].y
                );
                
                if (dist < snapDistance && corners[i].wallIdx !== corners[j].wallIdx) {
                    cluster.push(corners[j]);
                    used.add(j);
                }
            }
            
            if (cluster.length > 1) {
                clusters.push(cluster);
            }
        }
        
        // Snap corners in each cluster
        for (const cluster of clusters) {
            // Use weighted average based on wall confidence
            let totalX = 0, totalY = 0, totalWeight = 0;
            
            for (const corner of cluster) {
                const wall = snapped[corner.wallIdx];
                const weight = wall.confidence || 0.5;
                totalX += corner.x * weight;
                totalY += corner.y * weight;
                totalWeight += weight;
            }
            
            const snapX = totalX / totalWeight;
            const snapY = totalY / totalWeight;
            
            // Apply snap to all corners in cluster
            for (const corner of cluster) {
                const wall = snapped[corner.wallIdx];
                if (corner.end === 'start') {
                    wall.x1 = snapX;
                    wall.y1 = snapY;
                } else {
                    wall.x2 = snapX;
                    wall.y2 = snapY;
                }
            }
        }
        
        return snapped;
    },
    
    fillSmallGaps(walls) {
        const filled = [...walls];
        const maxGapSize = 15; // Maximum gap to fill
        
        // Find gaps between wall endpoints
        const gaps = [];
        
        for (let i = 0; i < walls.length; i++) {
            for (let j = i + 1; j < walls.length; j++) {
                const w1 = walls[i];
                const w2 = walls[j];
                
                // Check all endpoint pairs
                const pairs = [
                    { p1: { x: w1.x1, y: w1.y1 }, p2: { x: w2.x1, y: w2.y1 } },
                    { p1: { x: w1.x1, y: w1.y1 }, p2: { x: w2.x2, y: w2.y2 } },
                    { p1: { x: w1.x2, y: w1.y2 }, p2: { x: w2.x1, y: w2.y1 } },
                    { p1: { x: w1.x2, y: w1.y2 }, p2: { x: w2.x2, y: w2.y2 } }
                ];
                
                for (const pair of pairs) {
                    const dist = Math.hypot(pair.p2.x - pair.p1.x, pair.p2.y - pair.p1.y);
                    
                    if (dist > 0 && dist <= maxGapSize) {
                        // Check if gap is mostly horizontal or vertical
                        const dx = Math.abs(pair.p2.x - pair.p1.x);
                        const dy = Math.abs(pair.p2.y - pair.p1.y);
                        
                        if (dx < 5 || dy < 5) {
                            gaps.push({
                                x1: pair.p1.x,
                                y1: pair.p1.y,
                                x2: pair.p2.x,
                                y2: pair.p2.y,
                                type: dx > dy ? 'horizontal' : 'vertical',
                                distance: dist
                            });
                        }
                    }
                }
            }
        }
        
        // Sort gaps by size (fill smaller gaps first)
        gaps.sort((a, b) => a.distance - b.distance);
        
        // Add gap fillers
        for (const gap of gaps) {
            // Check if gap is already filled
            const exists = filled.some(w => 
                Math.hypot(w.x1 - gap.x1, w.y1 - gap.y1) < 2 &&
                Math.hypot(w.x2 - gap.x2, w.y2 - gap.y2) < 2
            );
            
            if (!exists) {
                filled.push({
                    type: gap.type,
                    x1: gap.x1,
                    y1: gap.y1,
                    x2: gap.x2,
                    y2: gap.y2,
                    confidence: 0.7,
                    isFiller: true
                });
            }
        }
        
        return filled;
    },
    
    finalCleanup(walls) {
        // Remove very short walls that might be artifacts
        const minLength = this.params.minLength * 2;
        
        return walls.filter(wall => {
            const length = Math.hypot(wall.x2 - wall.x1, wall.y2 - wall.y1);
            return length >= minLength || wall.isFiller; // Keep fillers even if short
        });
    },
    
    areCollinear(w1, w2) {
        // Legacy function kept for compatibility
        if (w1.type !== w2.type) return false;
        
        if (w1.type === 'horizontal') {
            return Math.abs(w1.y1 - w2.y1) < 2 && Math.abs(w1.y2 - w2.y2) < 2;
        } else if (w1.type === 'vertical') {
            return Math.abs(w1.x1 - w2.x1) < 2 && Math.abs(w1.x2 - w2.x2) < 2;
        }
        
        return false;
    },
    
    areAdjacent(w1, w2) {
        // Legacy function kept for compatibility
        if (w1.type === 'horizontal') {
            const min1 = Math.min(w1.x1, w1.x2);
            const max1 = Math.max(w1.x1, w1.x2);
            const min2 = Math.min(w2.x1, w2.x2);
            const max2 = Math.max(w2.x1, w2.x2);
            
            return (max1 >= min2 - this.params.mergeDistance) && 
                   (min1 <= max2 + this.params.mergeDistance);
        } else if (w1.type === 'vertical') {
            const min1 = Math.min(w1.y1, w1.y2);
            const max1 = Math.max(w1.y1, w1.y2);
            const min2 = Math.min(w2.y1, w2.y2);
            const max2 = Math.max(w2.y1, w2.y2);
            
            return (max1 >= min2 - this.params.mergeDistance) && 
                   (min1 <= max2 + this.params.mergeDistance);
        }
        
        return false;
    },
    
    mergeCollinearGroup(group) {
        // Merge truly collinear segments into one
        const type = group[0].type;
        
        if (type === 'horizontal') {
            const y = group.reduce((sum, w) => sum + (w.y1 + w.y2) / 2, 0) / group.length;
            const minX = Math.min(...group.map(w => Math.min(w.x1, w.x2)));
            const maxX = Math.max(...group.map(w => Math.max(w.x1, w.x2)));
            
            return {
                id: 'm' + Math.random().toString(36).substr(2, 9),
                x1: minX, y1: y,
                x2: maxX, y2: y,
                type: 'horizontal',
                merged: true,
                confidence: 1.0
            };
        } else if (type === 'vertical') {
            const x = group.reduce((sum, w) => sum + (w.x1 + w.x2) / 2, 0) / group.length;
            const minY = Math.min(...group.map(w => Math.min(w.y1, w.y2)));
            const maxY = Math.max(...group.map(w => Math.max(w.y1, w.y2)));
            
            return {
                id: 'm' + Math.random().toString(36).substr(2, 9),
                x1: x, y1: minY,
                x2: x, y2: maxY,
                type: 'vertical',
                merged: true,
                confidence: 1.0
            };
        }
        
        return group[0];
    },
    
    areParallel(w1, w2) {
        const angle1 = Math.atan2(w1.y2 - w1.y1, w1.x2 - w1.x1);
        const angle2 = Math.atan2(w2.y2 - w2.y1, w2.x2 - w2.x1);
        
        let diff = Math.abs(angle1 - angle2) * 180 / Math.PI;
        if (diff > 180) diff = 360 - diff;
        if (diff > 90) diff = 180 - diff;
        
        return diff < this.params.angleSnap;
    },
    
    areClose(w1, w2) {
        // Calculate perpendicular distance
        const dist = this.perpDistance(w1, w2);
        return dist < this.params.mergeDistance;
    },
    
    perpDistance(w1, w2) {
        // Point to line distance
        const A = w2.y2 - w2.y1;
        const B = w2.x1 - w2.x2;
        const C = w2.x2 * w2.y1 - w2.x1 * w2.y2;
        
        const d1 = Math.abs(A * w1.x1 + B * w1.y1 + C) / Math.sqrt(A * A + B * B);
        const d2 = Math.abs(A * w1.x2 + B * w1.y2 + C) / Math.sqrt(A * A + B * B);
        
        return Math.min(d1, d2);
    },
    
    mergeGroup(group) {
        // Find extents of group
        const type = group[0].type;
        
        if (type === 'horizontal') {
            const y = group.reduce((sum, w) => sum + (w.y1 + w.y2) / 2, 0) / group.length;
            const minX = Math.min(...group.map(w => Math.min(w.x1, w.x2)));
            const maxX = Math.max(...group.map(w => Math.max(w.x1, w.x2)));
            
            return {
                id: 'm' + Math.random().toString(36).substr(2, 9),
                x1: minX, y1: y,
                x2: maxX, y2: y,
                type: 'horizontal'
            };
        } else {
            const x = group.reduce((sum, w) => sum + (w.x1 + w.x2) / 2, 0) / group.length;
            const minY = Math.min(...group.map(w => Math.min(w.y1, w.y2)));
            const maxY = Math.max(...group.map(w => Math.max(w.y1, w.y2)));
            
            return {
                id: 'm' + Math.random().toString(36).substr(2, 9),
                x1: x, y1: minY,
                x2: x, y2: maxY,
                type: 'vertical'
            };
        }
    },
    
    extendWalls(walls) {
        // Extend walls to meet at intersections
        const extended = [...walls];
        
        for (let i = 0; i < extended.length; i++) {
            for (let j = i + 1; j < extended.length; j++) {
                const w1 = extended[i];
                const w2 = extended[j];
                
                // Check if perpendicular
                if (this.arePerpendicular(w1, w2)) {
                    this.extendToMeet(w1, w2);
                }
            }
        }
        
        return extended;
    },
    
    arePerpendicular(w1, w2) {
        const angle1 = Math.atan2(w1.y2 - w1.y1, w1.x2 - w1.x1);
        const angle2 = Math.atan2(w2.y2 - w2.y1, w2.x2 - w2.x1);
        
        let diff = Math.abs(angle1 - angle2) * 180 / Math.PI;
        diff = Math.abs(diff - 90);
        
        return diff < this.params.angleSnap;
    },
    
    extendToMeet(w1, w2) {
        // Calculate intersection point
        const intersection = this.lineIntersection(w1, w2);
        if (!intersection) return;
        
        // Check if extension is reasonable
        const ext = this.params.extension;
        
        // Check each endpoint
        const endpoints = [
            { wall: w1, point: { x: w1.x1, y: w1.y1 }, end: 'start' },
            { wall: w1, point: { x: w1.x2, y: w1.y2 }, end: 'end' },
            { wall: w2, point: { x: w2.x1, y: w2.y1 }, end: 'start' },
            { wall: w2, point: { x: w2.x2, y: w2.y2 }, end: 'end' }
        ];
        
        for (const ep of endpoints) {
            const dist = Math.hypot(ep.point.x - intersection.x, ep.point.y - intersection.y);
            
            if (dist < ext && dist > 1) {
                // Extend to intersection
                if (ep.end === 'start') {
                    ep.wall.x1 = intersection.x;
                    ep.wall.y1 = intersection.y;
                } else {
                    ep.wall.x2 = intersection.x;
                    ep.wall.y2 = intersection.y;
                }
            }
        }
    },
    
    lineIntersection(w1, w2) {
        const x1 = w1.x1, y1 = w1.y1;
        const x2 = w1.x2, y2 = w1.y2;
        const x3 = w2.x1, y3 = w2.y1;
        const x4 = w2.x2, y4 = w2.y2;
        
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (Math.abs(denom) < 0.001) return null;
        
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        
        return {
            x: x1 + t * (x2 - x1),
            y: y1 + t * (y2 - y1)
        };
    },
    
    snapAngles(walls) {
        // Snap to 90-degree angles
        return walls.map(w => {
            const angle = Math.atan2(w.y2 - w.y1, w.x2 - w.x1) * 180 / Math.PI;
            const snapped = Math.round(angle / 90) * 90;
            
            if (Math.abs(angle - snapped) < this.params.angleSnap) {
                const length = Math.hypot(w.x2 - w.x1, w.y2 - w.y1);
                const rad = snapped * Math.PI / 180;
                
                return {
                    ...w,
                    x2: w.x1 + length * Math.cos(rad),
                    y2: w.y1 + length * Math.sin(rad)
                };
            }
            
            return w;
        });
    },
    
    postProcess() {
        // Final cleanup - remove duplicates and very short segments
        this.walls = this.removeDuplicateWalls(this.walls);
        this.walls = this.removeShortWalls(this.walls);
        
        document.getElementById('wallCount').textContent = this.walls.length;
        document.getElementById('detectedWalls').textContent = this.walls.length;
        document.getElementById('bimInfo').textContent = `${this.walls.length} walls`;
        
        const hCount = this.walls.filter(w => w.type === 'horizontal').length;
        const vCount = this.walls.filter(w => w.type === 'vertical').length;
        
        this.log(`Final: ${this.walls.length} walls (${hCount}H, ${vCount}V)`, 'success');
    },
    
    removeDuplicateWalls(walls) {
        const unique = [];
        const threshold = 2; // Very strict duplicate detection
        
        for (const wall of walls) {
            let isDuplicate = false;
            
            for (const existing of unique) {
                // Check if walls are essentially the same
                const d1 = Math.hypot(wall.x1 - existing.x1, wall.y1 - existing.y1);
                const d2 = Math.hypot(wall.x2 - existing.x2, wall.y2 - existing.y2);
                
                // Also check reversed direction
                const d3 = Math.hypot(wall.x1 - existing.x2, wall.y1 - existing.y2);
                const d4 = Math.hypot(wall.x2 - existing.x1, wall.y2 - existing.y1);
                
                if ((d1 < threshold && d2 < threshold) || (d3 < threshold && d4 < threshold)) {
                    isDuplicate = true;
                    break;
                }
            }
            
            if (!isDuplicate) {
                unique.push(wall);
            }
        }
        
        this.log(`Removed ${walls.length - unique.length} duplicate walls`, 'debug');
        return unique;
    },
    
    removeShortWalls(walls) {
        const minLength = this.params.minLength * 3; // Triple minimum for cleaner output
        
        const filtered = walls.filter(wall => {
            const length = Math.hypot(wall.x2 - wall.x1, wall.y2 - wall.y1);
            return length >= minLength;
        });
        
        this.log(`Removed ${walls.length - filtered.length} short walls`, 'debug');
        return filtered;
    },
    
    detectRooms() {
        // Find closed polygons
        this.rooms = [];
        
        // Simple room detection - find rectangular regions
        const horizontals = this.walls.filter(w => w.type === 'horizontal').sort((a, b) => a.y1 - b.y1);
        const verticals = this.walls.filter(w => w.type === 'vertical').sort((a, b) => a.x1 - b.x1);
        
        // Find intersections
        const intersections = [];
        for (const h of horizontals) {
            for (const v of verticals) {
                const int = this.lineIntersection(h, v);
                if (int) {
                    intersections.push(int);
                }
            }
        }
        
        document.getElementById('junctions').textContent = intersections.length;
        
        // TODO: Implement proper room detection algorithm
        document.getElementById('roomCount').textContent = this.rooms.length;
    },
    
    calculateAccuracy() {
        // Calculate accuracy metrics
        const accuracy = Math.min(100, (this.walls.length / 40) * 100); // Assuming ~40 walls is perfect
        
        document.getElementById('accuracy').textContent = accuracy.toFixed(0) + '%';
        document.getElementById('accuracyFill').style.width = accuracy + '%';
        document.getElementById('accuracyText').textContent = accuracy.toFixed(0) + '%';
        
        // Update comparison stats
        if (this.groundTruth) {
            // Compare with ground truth
            const missing = Math.max(0, this.groundTruth.walls - this.walls.length);
            const extra = Math.max(0, this.walls.length - this.groundTruth.walls);
            
            document.getElementById('expectedWalls').textContent = this.groundTruth.walls;
            document.getElementById('missingWalls').textContent = missing;
            document.getElementById('extraWalls').textContent = extra;
        }
    },
    
    renderAll() {
        this.renderDetection();
        this.renderVectorization();
        this.renderBIM();
    },
    
    renderDetection() {
        const canvas = this.detectCanvas;
        const ctx = this.detectCtx;
        
        canvas.width = 400;
        canvas.height = 280;
        
        // Show binary image
        if (this.binaryData) {
            const { width, height } = this.pdfData;
            const scale = Math.min(400 / width, 280 / height);
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, 400, 280);
            
            ctx.save();
            ctx.scale(scale, scale);
            
            // Draw binary data
            const imageData = ctx.createImageData(width, height);
            for (let i = 0; i < this.binaryData.length; i++) {
                const idx = i * 4;
                const val = this.binaryData[i];
                imageData.data[idx] = val;
                imageData.data[idx + 1] = val;
                imageData.data[idx + 2] = val;
                imageData.data[idx + 3] = 255;
            }
            
            ctx.putImageData(imageData, 0, 0);
            ctx.restore();
        }
    },
    
    renderVectorization() {
        const canvas = this.vectorCanvas;
        const ctx = this.vectorCtx;
        
        canvas.width = 400;
        canvas.height = 280;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, 400, 280);
        
        if (this.vectors.length > 0) {
            const { width, height } = this.pdfData;
            const scale = Math.min(400 / width, 280 / height);
            
            ctx.save();
            ctx.scale(scale, scale);
            
            // Draw vectors
            ctx.strokeStyle = '#4a9eff';
            ctx.lineWidth = 2;
            
            for (const v of this.vectors) {
                ctx.beginPath();
                ctx.moveTo(v.x1, v.y1);
                ctx.lineTo(v.x2, v.y2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
    },
    
    renderBIM() {
        const ctx = this.bimCtx;
        const canvas = this.bimCanvas;
        
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Auto-fit walls to canvas
        if (this.walls.length > 0) {
            // Find bounds
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            for (const wall of this.walls) {
                minX = Math.min(minX, wall.x1, wall.x2);
                minY = Math.min(minY, wall.y1, wall.y2);
                maxX = Math.max(maxX, wall.x1, wall.x2);
                maxY = Math.max(maxY, wall.y1, wall.y2);
            }
            
            const width = maxX - minX;
            const height = maxY - minY;
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            // Calculate scale to fit
            const padding = 20;
            const scaleX = (canvas.width - padding * 2) / width;
            const scaleY = (canvas.height - padding * 2) / height;
            const autoScale = Math.min(scaleX, scaleY, 2); // Cap at 2x max
            
            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.scale(autoScale * this.zoom, autoScale * this.zoom);
            ctx.translate(-centerX + this.pan.x/autoScale, -centerY + this.pan.y/autoScale);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 0.5;
            const gridSize = 50;
            for (let x = Math.floor(minX/gridSize)*gridSize; x <= maxX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, minY);
                ctx.lineTo(x, maxY);
                ctx.stroke();
            }
            for (let y = Math.floor(minY/gridSize)*gridSize; y <= maxY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(minX, y);
                ctx.lineTo(maxX, y);
                ctx.stroke();
            }
            
            // Draw walls with better visibility
            for (const wall of this.walls) {
                // Choose color based on type and confidence
                if (wall.type === 'horizontal') {
                    ctx.strokeStyle = '#00ff88';
                } else if (wall.type === 'vertical') {
                    ctx.strokeStyle = '#4a9eff';
                } else {
                    ctx.strokeStyle = '#ff9944'; // Diagonal/other
                }
                
                ctx.lineWidth = wall.merged ? 2.5 : 2;
                ctx.lineCap = 'round';
                ctx.globalAlpha = wall.confidence ? Math.max(0.5, wall.confidence) : 1;
                
                ctx.beginPath();
                ctx.moveTo(wall.x1, wall.y1);
                ctx.lineTo(wall.x2, wall.y2);
                ctx.stroke();
                
                // Draw endpoints for debugging
                if (this.debug) {
                    ctx.fillStyle = ctx.strokeStyle;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(wall.x1, wall.y1, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(wall.x2, wall.y2, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.globalAlpha = 1;
            ctx.restore();
        }
    },
    
    setParam(name, value) {
        this.params[name] = parseFloat(value);
        document.getElementById(name + 'Value').textContent = value;
        
        // Re-extract with new params
        if (this.imageData) {
            this.extract(this.params.method);
        }
    },
    
    autoTune() {
        this.log('Auto-tuning parameters...', 'info');
        
        // Try different parameter combinations
        const bestParams = { ...this.params };
        let bestScore = 0;
        
        const thresholds = [235, 240, 245];
        const minLengths = [8, 10, 12];
        const mergeDistances = [3, 5, 8];
        
        for (const t of thresholds) {
            for (const m of minLengths) {
                for (const d of mergeDistances) {
                    this.params.threshold = t;
                    this.params.minLength = m;
                    this.params.mergeDistance = d;
                    
                    this.extract(this.params.method);
                    
                    // Score based on wall count (assuming ~40-50 is ideal)
                    const score = 100 - Math.abs(45 - this.walls.length) * 2;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestParams.threshold = t;
                        bestParams.minLength = m;
                        bestParams.mergeDistance = d;
                    }
                }
            }
        }
        
        // Apply best parameters
        this.params = bestParams;
        document.getElementById('threshold').value = bestParams.threshold;
        document.getElementById('thresholdValue').textContent = bestParams.threshold;
        document.getElementById('minLength').value = bestParams.minLength;
        document.getElementById('mergeDistance').value = bestParams.mergeDistance;
        
        this.extract(this.params.method);
        this.log(`Auto-tuned: T=${bestParams.threshold}, L=${bestParams.minLength}, D=${bestParams.mergeDistance}`, 'success');
    },
    
    exportPerfect() {
        const data = {
            walls: this.walls,
            rooms: this.rooms,
            params: this.params,
            stats: {
                wallCount: this.walls.length,
                roomCount: this.rooms.length,
                accuracy: document.getElementById('accuracy').textContent
            },
            timestamp: new Date().toISOString()
        };
        
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'perfect_extraction.json';
        a.click();
        
        this.log(`Exported ${this.walls.length} walls`, 'success');
    },
    
    toggleComparison() {
        this.comparing = !this.comparing;
        event.target.classList.toggle('active');
        
        if (this.comparing) {
            // Load ground truth for comparison
            this.groundTruth = { walls: 45, rooms: 12 }; // Example values
            document.getElementById('expectedWalls').textContent = this.groundTruth.walls;
        }
        
        this.calculateAccuracy();
    },
    
    clearAll() {
        this.walls = [];
        this.vectors = [];
        this.rooms = [];
        this.binaryData = null;
        this.imageData = null;
        this.pdfData = null;
        
        [this.pdfCtx, this.detectCtx, this.vectorCtx, this.bimCtx].forEach(ctx => {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        });
        
        document.querySelectorAll('.stat-value').forEach(el => {
            el.textContent = '0';
        });
        
        this.log('Cleared all data', 'info');
    },
    
    // Mouse interactions
    mouseDown(e) {
        const rect = this.bimCanvas.getBoundingClientRect();
        this.dragStart = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
            panX: this.pan.x,
            panY: this.pan.y
        };
    },
    
    mouseMove(e) {
        if (!this.dragStart) return;
        
        const rect = this.bimCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        this.pan.x = this.dragStart.panX + (x - this.dragStart.x);
        this.pan.y = this.dragStart.panY + (y - this.dragStart.y);
        
        this.renderBIM();
    },
    
    mouseUp() {
        this.dragStart = null;
    },
    
    wheel(e) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        this.zoom = Math.max(0.1, Math.min(5, this.zoom * delta));
        this.renderBIM();
    }
};

// Initialize
window.onload = () => {
    Diagnostic.init();
};
</script>

</body>
</html>