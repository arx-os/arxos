# Rust 2021

Info
RFC	#3085
Release version	1.56.0
The Rust 2021 Edition contains several changes that bring new capabilities and more consistency to the language, and opens up room for expansion in the future. The following chapters dive into the details of each change, and they include guidance on migrating your existing code.

## Additions to the prelude

### Summary

The TryInto, TryFrom and FromIterator traits are now part of the prelude.
This might make calls to trait methods ambiguous which could make some code fail to compile.

### Details

The prelude of the standard library is the module containing everything that is automatically imported in every module. It contains commonly used items such as Option, Vec, drop, and Clone.

The Rust compiler prioritizes any manually imported items over those from the prelude, to make sure additions to the prelude will not break any existing code. For example, if you have a crate or module called example containing a pub struct Option;, then use example::*; will make Option unambiguously refer to the one from example; not the one from the standard library.

However, adding a trait to the prelude can break existing code in a subtle way. For example, a call to x.try_into() which comes from a MyTryInto trait might fail to compile if std's TryInto is also imported, because the call to try_into is now ambiguous and could come from either trait. This is the reason we haven't added TryInto to the prelude yet, since there is a lot of code that would break this way.

As a solution, Rust 2021 will use a new prelude. It's identical to the current one, except for three new additions:

std::convert::TryInto
std::convert::TryFrom
std::iter::FromIterator
The tracking issue can be found here.

### Migration

As a part of the 2021 edition a migration lint, rust_2021_prelude_collisions, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.

In order to migrate your code to be Rust 2021 Edition compatible, run:

cargo fix --edition
The lint detects cases where functions or methods are called that have the same name as the methods defined in one of the new prelude traits. In some cases, it may rewrite your calls in various ways to ensure that you continue to call the same function you did before.

If you'd like to migrate your code manually or better understand what cargo fix is doing, below we've outlined the situations where a migration is needed along with a counter example of when it's not needed.

### Migration needed

### Conflicting trait methods

When two traits that are in scope have the same method name, it is ambiguous which trait method should be used. For example:

trait MyTrait<A> {
  // This name is the same as the `from_iter` method on the `FromIterator` trait from `std`.  
  fn from_iter(x: Option<A>);
}

impl<T> MyTrait<()> for Vec<T> {
  fn from_iter(_: Option<()>) {}
}

fn main() {
  // Vec<T> implements both `std::iter::FromIterator` and `MyTrait` 
  // If both traits are in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `from_iter` method to call
  <Vec<i32>>::from_iter(None);
}
We can fix this by using fully qualified syntax:

fn main() {
  // Now it is clear which trait method we're referring to
  <Vec<i32> as MyTrait<()>>::from_iter(None);
}

## Inherent methods on dyn Trait objects

Some users invoke methods on a dyn Trait value where the method name overlaps with a new prelude trait:

mod submodule {
  pub trait MyTrait {
    // This has the same name as `TryInto::try_into`
    fn try_into(&self) -> Result<u32, ()>;
  }
}

// `MyTrait` isn't in scope here and can only be referred to through the path `submodule::MyTrait`
fn bar(f: Box<dyn submodule::MyTrait>) {
  // If `std::convert::TryInto` is in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `try_into` method to call
  f.try_into();
}
Unlike with static dispatch methods, calling a trait method on a trait object does not require that the trait be in scope. The code above works as long as there is no trait in scope with a conflicting method name. When the TryInto trait is in scope (which is the case in Rust 2021), this causes an ambiguity. Should the call be to MyTrait::try_into or std::convert::TryInto::try_into?

In these cases, we can fix this by adding an additional dereferences or otherwise clarify the type of the method receiver. This ensures that the dyn Trait method is chosen, versus the methods from the prelude trait. For example, turning f.try_into() above into (&*f).try_into() ensures that we're calling try_into on the dyn MyTrait which can only refer to the MyTrait::try_into method.

### No migration needed

### Inherent methods

Many types define their own inherent methods with the same name as a trait method. For instance, below the struct MyStruct implements from_iter which shares the same name with the method from the trait FromIterator found in the standard library:

use std::iter::IntoIterator;

struct MyStruct {
  data: Vec<u32>
}

impl MyStruct {
  // This has the same name as `std::iter::FromIterator::from_iter`
  fn from_iter(iter: impl IntoIterator<Item = u32>) -> Self {
    Self {
      data: iter.into_iter().collect()
    }
  }
}

impl std::iter::FromIterator<u32> for MyStruct {
    fn from_iter<I: IntoIterator<Item = u32>>(iter: I) -> Self {
      Self {
        data: iter.into_iter().collect()
      }
    }
}
Inherent methods always take precedent over trait methods so there's no need for any migration.

### Implementation Reference

The lint needs to take a couple of factors into account when determining whether or not introducing 2021 Edition to a codebase will cause a name resolution collision (thus breaking the code after changing edition). These factors include:

Is the call a fully-qualified call or does it use dot-call method syntax?
This will affect how the name is resolved due to auto-reference and auto-dereferencing on method call syntax. Manually dereferencing/referencing will allow specifying priority in the case of dot-call method syntax, while fully-qualified call requires specification of the type and the trait name in the method path (e.g. <Type as Trait>::method)
Is this an inherent method or a trait method?
Inherent methods that take self will take priority over TryInto::try_into as inherent methods take priority over trait methods, but inherent methods that take &self or &mut self won't take priority due to requiring a auto-reference (while TryInto::try_into does not, as it takes self)
Is the origin of this method from core/std? (As the traits can't have a collision with themselves)
Does the given type implement the trait it could have a collision against?
Is the method being called via dynamic dispatch? (i.e. is the self type dyn Trait)
If so, trait imports don't affect resolution, and no migration lint needs to occur

## Default Cargo feature resolver

### Summary

edition = "2021" implies resolver = "2" in Cargo.toml.

### Details

Since Rust 1.51.0, Cargo has opt-in support for a new feature resolver which can be activated with resolver = "2" in Cargo.toml.

Starting in Rust 2021, this will be the default. That is, writing edition = "2021" in Cargo.toml will imply resolver = "2".

The resolver is a global setting for a workspace, and the setting is ignored in dependencies. The setting is only honored for the top-level package of the workspace. If you are using a virtual workspace, you will still need to explicitly set the resolver field in the [workspace] definition if you want to opt-in to the new resolver.

The new feature resolver no longer merges all requested features for crates that are depended on in multiple ways. See the announcement of Rust 1.51 for details.

### Migration

There are no automated migration tools for updating for the new resolver. For most projects, there are usually few or no changes as a result of updating.

When updating with cargo fix --edition, Cargo will display a report if the new resolver will build dependencies with different features. It may look something like this:

note: Switching to Edition 2021 will enable the use of the version 2 feature resolver in Cargo. This may cause some dependencies to be built with fewer features enabled than previously. More information about the resolver changes may be found at https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html
When building the following dependencies, the given features will no longer be used:

  bstr v0.2.16: default, lazy_static, regex-automata, unicode
  libz-sys v1.1.3 (as host dependency): libc
This lets you know that certain dependencies will no longer be built with the given features.

### Build failures

There may be some circumstances where your project may not build correctly after the change. If a dependency declaration in one package assumes that certain features are enabled in another, and those features are now disabled, it may fail to compile.

For example, let's say we have a dependency like this:

# Cargo.toml

[dependencies]
bstr = { version = "0.2.16", default-features = false }
# ...
And somewhere in our dependency tree, another package has this:

# Another package's Cargo.toml

[build-dependencies]
bstr = "0.2.16"
In our package, we've been using the words_with_breaks method from bstr, which requires bstr's "unicode" feature to be enabled. This has historically worked because Cargo unified the features of bstr between the two packages. However, after updating to Rust 2021, the new resolver will build bstr twice, once with the default features (as a build dependency), and once with no features (as our normal dependency). Since bstr is now being built without the "unicode" feature, the words_with_breaks method doesn't exist, and the build will fail with an error that the method is missing.

The solution here is to ensure that the dependency is declared with the features you are actually using. For example:

[dependencies]
bstr = { version = "0.2.16", default-features = false, features = ["unicode"] }
In some cases, this may be a problem with a third-party dependency that you don't have direct control over. You can consider submitting a patch to that project to try to declare the correct set of features for the problematic dependency. Alternatively, you can add features to any dependency from within your own Cargo.toml file. For example, if the bstr example given above was declared in some third-party dependency, you can just copy the correct dependency declaration into your own project. The features will be unified, as long as they match the unification rules of the new resolver. Those are:

Features enabled on platform-specific dependencies for targets not currently being built are ignored.
Build-dependencies and proc-macros do not share features with normal dependencies.
Dev-dependencies do not activate features unless building a target that needs them (like tests or examples).
A real-world example is using diesel and diesel_migrations. These packages provide database support, and the database is selected using a feature, like this:

[dependencies]
diesel = { version = "1.4.7", features = ["postgres"] }
diesel_migrations = "1.4.0"
The problem is that diesel_migrations has an internal proc-macro which itself depends on diesel, and the proc-macro assumes its own copy of diesel has the same features enabled as the rest of the dependency graph. After updating to the new resolver, it fails to build because now there are two copies of diesel, and the one built for the proc-macro is missing the "postgres" feature.

A solution here is to add diesel as a build-dependency with the required features, for example:

[build-dependencies]
diesel = { version = "1.4.7", features = ["postgres"] }
This causes Cargo to add "postgres" as a feature for host dependencies (proc-macros and build-dependencies). Now, the diesel_migrations proc-macro will get the "postgres" feature enabled, and it will build correctly.

The 2.0 release of diesel (currently in development) does not have this problem as it has been restructured to not have this dependency requirement.

### Exploring features

The cargo tree command has had substantial improvements to help with the migration to the new resolver. cargo tree can be used to explore the dependency graph, and to see which features are being enabled, and importantly why they are being enabled.

One option is to use the --duplicates flag (-d for short), which will tell you when a package is being built multiple times. Taking the bstr example from earlier, we might see:

> cargo tree -d
bstr v0.2.16
└── foo v0.1.0 (/MyProjects/foo)

bstr v0.2.16
[build-dependencies]
└── bar v0.1.0
    └── foo v0.1.0 (/MyProjects/foo)

This output tells us that bstr is built twice, and shows the chain of dependencies that led to its inclusion in both cases.

You can print which features each package is using with the -f flag, like this:

cargo tree -f '{p} {f}'
This tells Cargo to change the "format" of the output, where it will print both the package and the enabled features.

You can also use the -e flag to tell it which "edges" to display. For example, cargo tree -e features will show in-between each dependency which features are being added by each dependency. This option becomes more useful with the -i flag which can be used to "invert" the tree. This allows you to see how features flow into a given dependency. For example, let's say the dependency graph is large, and we're not quite sure who is depending on bstr, the following command will show that:

> cargo tree -e features -i bstr
bstr v0.2.16
├── bstr feature "default"
│   [build-dependencies]
│   └── bar v0.1.0
│       └── bar feature "default"
│           └── foo v0.1.0 (/MyProjects/foo)
├── bstr feature "lazy_static"
│   └── bstr feature "unicode"
│       └── bstr feature "default" (*)
├── bstr feature "regex-automata"
│   └── bstr feature "unicode" (*)
├── bstr feature "std"
│   └── bstr feature "default" (*)
└── bstr feature "unicode" (*)
This snippet of output shows that the project foo depends on bar with the "default" feature. Then, bar depends on bstr as a build-dependency with the "default" feature. We can further see that bstr's "default" feature enables "unicode" (among other features).

### IntoIterator for arrays

### Summary

Arrays implement IntoIterator in all editions.
Calls to IntoIterator::into_iter are hidden in Rust 2015 and Rust 2018 when using method call syntax (i.e., array.into_iter()). So, array.into_iter() still resolves to (&array).into_iter() as it has before.
array.into_iter() changes meaning to be the call to IntoIterator::into_iter in Rust 2021.

### Details

Until Rust 1.53, only references to arrays implement IntoIterator. This means you can iterate over &[1, 2, 3] and &mut [1, 2, 3], but not over [1, 2, 3] directly.

for &e in &[1, 2, 3] {} // Ok :)

for e in [1, 2, 3] {} // Error :(
This has been a long-standing issue, but the solution is not as simple as it seems. Just adding the trait implementation would break existing code. array.into_iter() already compiles today because that implicitly calls (&array).into_iter() due to how method call syntax works. Adding the trait implementation would change the meaning.

Usually this type of breakage (adding a trait implementation) is categorized as 'minor' and acceptable. But in this case there is too much code that would be broken by it.

It has been suggested many times to "only implement IntoIterator for arrays in Rust 2021". However, this is simply not possible. You can't have a trait implementation exist in one edition and not in another, since editions can be mixed.

Instead, the trait implementation was added in all editions (starting in Rust 1.53.0) but with a small hack to avoid breakage until Rust 2021. In Rust 2015 and 2018 code, the compiler will still resolve array.into_iter() to (&array).into_iter() like before, as if the trait implementation does not exist. This only applies to the .into_iter() method call syntax. It does not affect any other syntax such as for e in [1, 2, 3], iter.zip([1, 2, 3]) or IntoIterator::into_iter([1, 2, 3]). Those will start to work in all editions.

While it's a shame that this required a small hack to avoid breakage, this solution keeps the difference between the editions to an absolute minimum.

### Migration

A lint, array_into_iter, gets triggered whenever there is some call to into_iter() that will change meaning in Rust 2021. The array_into_iter lint has already been a warning by default on all editions since the 1.41 release (with several enhancements made in 1.55). If your code is already warning free, then it should already be ready to go for Rust 2021!

You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by running:

cargo fix --edition
Because the difference between editions is small, the migration to Rust 2021 is fairly straight-forward.

For method calls of into_iter on arrays, the elements being implemented will change from references to owned values.

For example:

fn main() {
  let array = [1u8, 2, 3];
  for x in array.into_iter() {
    // x is a `&u8` in Rust 2015 and Rust 2018
    // x is a `u8` in Rust 2021
  }
}
The most straightforward way to migrate in Rust 2021, is by keeping the exact behavior from previous editions by calling iter() which also iterates over owned arrays by reference:

fn main() {
  let array = [1u8, 2, 3];
  for x in array.iter() { // <- This line changed
    // x is a `&u8` in all editions
  }
}

### Optional migration

If you are using fully qualified method syntax (i.e., IntoIterator::into_iter(array)) in a previous edition, this can be upgraded to method call syntax (i.e., array.into_iter()).

## Disjoint capture in closures

### Summary

|| a.x + 1 now captures only a.x instead of a.
This can cause things to be dropped at different times or affect whether closures implement traits like Send or Clone.
If possible changes are detected, cargo fix will insert statements like let _ = &a to force a closure to capture the entire variable.

### Details

Closures automatically capture anything that you refer to from within their body. For example, || a + 1 automatically captures a reference to a from the surrounding context.

In Rust 2018 and before, closures capture entire variables, even if the closure only uses one field. For example, || a.x + 1 captures a reference to a and not just a.x. Capturing a in its entirety prevents mutation or moves from other fields of a, so that code like this does not compile:

let a = SomeStruct::new();
drop(a.x); // Move out of one field of the struct
println!("{}", a.y); // Ok: Still use another field of the struct
let c = || println!("{}", a.y); // Error: Tries to capture all of `a`
c();
Starting in Rust 2021, closures captures are more precise. Typically they will only capture the fields they use (in some cases, they might capture more than just what they use, see the Rust reference for full details). Therefore, the above example will compile fine in Rust 2021.

Disjoint capture was proposed as part of RFC 2229 and the RFC contains details about the motivation.

### Migration

As a part of the 2021 edition a migration lint, rust_2021_incompatible_closure_captures, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.

In order to migrate your code to be Rust 2021 Edition compatible, run:

cargo fix --edition
Below is an examination of how to manually migrate code to use closure captures that are compatible with Rust 2021 should the automatic migration fail or you would like to better understand how the migration works.

Changing the variables captured by a closure can cause programs to change behavior or to stop compiling in two cases:

changes to drop order, or when destructors run (details);
changes to which traits a closure implements (details).
Whenever any of the scenarios below are detected, cargo fix will insert a "dummy let" into your closure to force it to capture the entire variable:

let x = (vec![22], vec![23]);
let c = move || {
    // "Dummy let" that forces `x` to be captured in its entirety
    let _ = &x;

    // Otherwise, only `x.0` would be captured here
    println!("{:?}", x.0);
};
This is a conservative analysis: in many cases, these dummy lets can be safely removed and your program will work fine.

### Wild Card Patterns

Closures now only capture data that needs to be read, which means the following closures will not capture x:

let x = 10;
let c = || {
    let _ = x; // no-op
};

let c = || match x {
    _ => println!("Hello World!")
};
The let _ = x statement here is a no-op, since the _ pattern completely ignores the right-hand side, and x is a reference to a place in memory (in this case, a variable).

This change by itself (capturing fewer values) doesn't trigger any suggestions, but it may do so in conjunction with the "drop order" change below.

Subtle: There are other similar expressions, such as the "dummy lets" let _ = &x that we insert, which are not no-ops. This is because the right-hand side (&x) is not a reference to a place in memory, but rather an expression that must first be evaluated (and whose result is then discarded).

### Drop Order

When a closure takes ownership of a value from a variable t, that value is then dropped when the closure is dropped, and not when the variable t goes out of scope:

{
    let t = (vec![0], vec![0]);

    {
        let c = || move_value(t); // t is moved here
    } // c is dropped, which drops the tuple `t` as well
} // t goes out of scope here
The above code will run the same in both Rust 2018 and Rust 2021. However, in cases where the closure only takes ownership of part of a variable, there can be differences:

{
    let t = (vec![0], vec![0]);

    {
        let c = || {
            // In Rust 2018, captures all of `t`.
            // In Rust 2021, captures only `t.0`
            move_value(t.0);
        };

        // In Rust 2018, `c` (and `t`) are both dropped when we
        // exit this block.
        //
        // In Rust 2021, `c` and `t.0` are both dropped when we
        // exit this block.
    }

// In Rust 2018, the value from `t` has been moved and is
// not dropped.
//
// In Rust 2021, the value from `t.0` has been moved, but `t.1`
// remains, so it will be dropped here.
}
In most cases, dropping values at different times just affects when memory is freed and is not important. However, some Drop impls (aka, destructors) have side-effects, and changing the drop order in those cases can alter the semantics of your program. In such cases, the compiler will suggest inserting a dummy let to force the entire variable to be captured.

### Trait implementations

Closures automatically implement the following traits based on what values they capture:

Clone: if all captured values are Clone.
Auto traits like Send, Sync, and UnwindSafe: if all captured values implement the given trait.
In Rust 2021, since different values are being captured, this can affect what traits a closure will implement. The migration lints test each closure to see whether it would have implemented a given trait before and whether it still implements it now; if they find that a trait used to be implemented but no longer is, then "dummy lets" are inserted.

For instance, a common way to allow passing around raw pointers between threads is to wrap them in a struct and then implement Send/Sync auto trait for the wrapper. The closure that is passed to thread::spawn uses the specific fields within the wrapper but the entire wrapper is captured regardless. Since the wrapper is Send/Sync, the code is considered safe and therefore compiles successfully.

With disjoint captures, only the specific field mentioned in the closure gets captured, which wasn't originally Send/Sync defeating the purpose of the wrapper.

use std::thread;

struct Ptr(*mut i32);
unsafe impl Send for Ptr {}


let mut x = 5;
let px = Ptr(&mut x as *mut i32);

let c = thread::spawn(move || {
    unsafe {
        *(px.0) += 10;
    }
}); // Closure captured px.0 which is not Send

## Panic macro consistency

### Summary

panic!(..) now always uses format_args!(..), just like println!().
panic!("{") is no longer accepted, without escaping the { as {{.
panic!(x) is no longer accepted if x is not a string literal.
Use std::panic::panic_any(x) to panic with a non-string payload.
Or use panic!("{}", x) to use x's Display implementation.
The same applies to assert!(expr, ..).

### Details

The panic!() macro is one of Rust's most well known macros. However, it has some subtle surprises that we can't just change due to backwards compatibility.

// Rust 2018
panic!("{}", 1); // Ok, panics with the message "1"
panic!("{}"); // Ok, panics with the message "{}"
The panic!() macro only uses string formatting when it's invoked with more than one argument. When invoked with a single argument, it doesn't even look at that argument.

// Rust 2018
let a = "{";
println!(a); // Error: First argument must be a format string literal
panic!(a); // Ok: The panic macro doesn't care
It even accepts non-strings such as panic!(123), which is uncommon and rarely useful since it produces a surprisingly unhelpful message: panicked at 'Box<Any>'.

This will especially be a problem once implicit format arguments are stabilized. That feature will make println!("hello {name}") a short-hand for println!("hello {}", name). However, panic!("hello {name}") would not work as expected, since panic!() doesn't process a single argument as format string.

To avoid that confusing situation, Rust 2021 features a more consistent panic!() macro. The new panic!() macro will no longer accept arbitrary expressions as the only argument. It will, just like println!(), always process the first argument as format string. Since panic!() will no longer accept arbitrary payloads, panic_any() will be the only way to panic with something other than a formatted string.

// Rust 2021
panic!("{}", 1); // Ok, panics with the message "1"
panic!("{}"); // Error, missing argument
panic!(a); // Error, must be a string literal
In addition, core::panic!() and std::panic!() will be identical in Rust 2021. Currently, there are some historical differences between those two, which can be noticeable when switching #![no_std] on or off.

### Migration

A lint, non_fmt_panics, gets triggered whenever there is some call to panic that uses some deprecated behavior that will error in Rust 2021. The non_fmt_panics lint has already been a warning by default on all editions since the 1.50 release (with several enhancements made in later releases). If your code is already warning free, then it should already be ready to go for Rust 2021!

You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by running:

cargo fix --edition
Should you choose or need to manually migrate, you'll need to update all panic invocations to either use the same formatting as println or use std::panic::panic_any to panic with non-string data.

For example, in the case of panic!(MyStruct), you'll need to convert to using std::panic::panic_any (note that this is a function not a macro): std::panic::panic_any(MyStruct).

In the case of panic messages that include curly braces but the wrong number of arguments (e.g., panic!("Some curlies: {}")), you can panic with the string literal by either using the same syntax as println! (i.e., panic!("{}", "Some curlies: {}")) or by escaping the curly braces (i.e., panic!("Some curlies: {{}}")).

### Reserved syntax

### Summary

any_identifier#, any_identifier"...", any_identifier'...', and 'any_identifier# are now reserved syntax, and no longer tokenize.
This is mostly relevant to macros. E.g. quote!{ #a#b } is no longer accepted.
It doesn't treat keywords specially, so e.g. match"..." {} is no longer accepted.
Insert whitespace between the identifier and the subsequent #, ", or ' to avoid errors.
Edition migrations will help you insert whitespace in such cases.

### Details

To make space for new syntax in the future, we've decided to reserve syntax for prefixed identifiers, literals, and lifetimes: prefix#identifier, prefix"string", prefix'c', prefix#123, and 'prefix#, where prefix can be any identifier. (Except those prefixes that already have a meaning, such as b'...' (byte chars) and r"..." (raw strings).)

This provides syntax we can expand into in the future without requiring an edition boundary. We may use this for temporary syntax until the next edition, or for permanent syntax if appropriate.

Without an edition, this would be a breaking change, since macros can currently accept syntax such as hello"world", which they will see as two separate tokens: hello and "world". The (automatic) fix is simple though: just insert a space: hello "world". Likewise, prefix#ident should become prefix #ident. Edition migrations will help with this fix.

Other than turning these into a tokenization error, the RFC does not attach a meaning to any prefix yet. Assigning meaning to specific prefixes is left to future proposals, which will now—thanks to reserving these prefixes—not be breaking changes.

Some new prefixes you might potentially see in the future (though we haven't committed to any of them yet):

k#keyword to allow writing keywords that don't exist yet in the current edition. For example, while async is not a keyword in edition 2015, this prefix would've allowed us to accept k#async in edition 2015 without having to wait for edition 2018 to reserve async as a keyword.

f"" as a short-hand for a format string. For example, f"hello {name}" as a short-hand for the equivalent format!() invocation.

## s"" for String literals.

### Migration

As a part of the 2021 edition a migration lint, rust_2021_prefixes_incompatible_syntax, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.

In order to migrate your code to be Rust 2021 Edition compatible, run:

cargo fix --edition
Should you want or need to manually migrate your code, migration is fairly straight-forward.

Let's say you have a macro that is defined like so:

macro_rules! my_macro {
    ($a:tt $b:tt) => {};
}
In Rust 2015 and 2018 it's legal for this macro to be called like so with no space between the first token tree and the second:

my_macro!(z"hey");
This z prefix is no longer allowed in Rust 2021, so in order to call this macro, you must add a space after the prefix like so:

my_macro!(z "hey");

## Raw lifetimes

### Summary

'r#ident_or_keyword is now allowed as a lifetime, which allows using keywords such as 'r#fn.

### Details

Raw lifetimes are introduced in the 2021 edition to support the ability to migrate to newer editions that introduce new keywords. This is analogous to raw identifiers which provide the same functionality for identifiers. For example, the 2024 edition introduced the gen keyword. Since lifetimes cannot be keywords, this would cause code that use a lifetime 'gen to fail to compile. Raw lifetimes allow the migration lint to modify those lifetimes to 'r#gen which do allow keywords.

In editions prior to 2021, raw lifetimes are parsed as separate tokens. For example 'r#foo is parsed as three tokens: 'r, #, and foo.

### Migration

As a part of the 2021 edition a migration lint, rust_2021_prefixes_incompatible_syntax, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.

In order to migrate your code to be Rust 2021 Edition compatible, run:

cargo fix --edition
Should you want or need to manually migrate your code, migration is fairly straight-forward.

Let's say you have a macro that is defined like so:

macro_rules! my_macro {
    ($a:tt $b:tt $c:tt) => {};
}
In Rust 2015 and 2018 it's legal for this macro to be called like so with no space between the tokens:

my_macro!('r#foo);
In the 2021 edition, this is now parsed as a single token. In order to call this macro, you must add a space before the identifier like so:

my_macro!('r# foo);

## Warnings promoted to errors

### Summary

Code that triggered the bare_trait_objects and ellipsis_inclusive_range_patterns lints will error in Rust 2021.

### Details

Two existing lints are becoming hard errors in Rust 2021, but these lints will remain warnings in older editions.

bare_trait_objects:

The use of the dyn keyword to identify trait objects will be mandatory in Rust 2021.

For example, the following code which does not include the dyn keyword in &MyTrait will produce an error instead of just a lint in Rust 2021:

## pub trait MyTrait {}

pub fn my_function(_trait_object: &MyTrait) { // should be `&dyn MyTrait`
  unimplemented!()
}
ellipsis_inclusive_range_patterns:

The deprecated ... syntax for inclusive range patterns (i.e., ranges where the end value is included in the range) is no longer accepted in Rust 2021. It has been superseded by ..=, which is consistent with expressions.

For example, the following code which uses ... in a pattern will produce an error instead of just a lint in Rust 2021:

pub fn less_or_eq_to_100(n: u8) -> bool {
  matches!(n, 0...100) // should be `0..=100`
}

## Migrations

If your Rust 2015 or 2018 code does not produce any warnings for bare_trait_objects or ellipsis_inclusive_range_patterns and you've not allowed these lints through the use of #![allow()] or some other mechanism, then there's no need to migrate.

To automatically migrate any crate that uses ... in patterns or does not use dyn with trait objects, you can run cargo fix --edition.

## Or patterns in macro-rules

### Summary

How patterns work in macro_rules macros changes slightly:
$_:pat in macro_rules now matches usage of | too: e.g. A | B.
The new $_:pat_param behaves like $_:pat did before; it does not match (top level) |.
$_:pat_param is available in all editions.

### Details

Starting in Rust 1.53.0, patterns are extended to support | nested anywhere in the pattern. This enables you to write Some(1 | 2) instead of Some(1) | Some(2). Since this was simply not allowed before, this is not a breaking change.

However, this change also affects macro_rules macros. Such macros can accept patterns using the :pat fragment specifier. Currently, :pat does not match top level |, since before Rust 1.53, not all patterns (at all nested levels) could contain a |. Macros that accept patterns like A | B, such as matches!() use something like $($_:pat)|+.

Because this would potentially break existing macros, the meaning of :pat did not change in Rust 1.53.0 to include |. Instead, that change happens in Rust 2021. In the new edition, the :pat fragment specifier will match A | B.

$_:pat fragments in Rust 2021 cannot be followed by an explicit |. Since there are times that one still wishes to match pattern fragments followed by a |, the fragment specified :pat_param has been added to retain the older behavior.

It's important to remember that editions are per crate, so the only relevant edition is the edition of the crate where the macro is defined. The edition of the crate where the macro is used does not change how the macro works.

### Migration

A lint, rust_2021_incompatible_or_patterns, gets triggered whenever there is a use $_:pat which will change meaning in Rust 2021.

You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by running:

cargo fix --edition
If you have a macro which relies on $_:pat not matching the top level use of | in patterns, you'll need to change each occurrence of $_:pat to $_:pat_param.

For example:

macro_rules! my_macro { 
    ($x:pat | $y:pat) => {
        // TODO: implementation
    } 
}

// This macro works in Rust 2018 since `$x:pat` does not match against `|`:
my_macro!(1 | 2);

// In Rust 2021 however, the `$_:pat` fragment matches `|` and is not allowed
// to be followed by a `|`. To make sure this macro still works in Rust 2021
// change the macro to the following:
macro_rules! my_macro { 
    ($x:pat_param | $y:pat) => { // <- this line is different
        // TODO: implementation
    } 
}

## C-string literals

### Summary

Literals of the form c"foo" or cr"foo" represent a string of type &core::ffi::CStr.

### Details

Starting with Rust 1.77, C-strings can be written using C-string literal syntax with the c or cr prefix.

Previously, it was challenging to properly produce a valid string literal that could interoperate with C APIs which terminate with a NUL byte. The cstr crate was a popular solution, but that required compiling a proc-macro which was quite expensive. Now, C-strings can be written directly using literal syntax notation, which will generate a value of type &core::ffi::CStr which is automatically terminated with a NUL byte.


assert_eq!(c"hello", CStr::from_bytes_with_nul(b"hello\0").unwrap());
assert_eq!(
    c"byte escapes \xff work",
    CStr::from_bytes_with_nul(b"byte escapes \xff work\0").unwrap()
);
assert_eq!(
    c"unicode escapes \u{00E6} work",
    CStr::from_bytes_with_nul(b"unicode escapes \xc3\xa6 work\0").unwrap()
);
assert_eq!(
    c"unicode characters αβγ encoded as UTF-8",
    CStr::from_bytes_with_nul(
        b"unicode characters \xce\xb1\xce\xb2\xce\xb3 encoded as UTF-8\0"
    )
    .unwrap()
);
assert_eq!(
    c"strings can continue \
        on multiple lines",
    CStr::from_bytes_with_nul(b"strings can continue on multiple lines\0").unwrap()
);
C-strings do not allow interior NUL bytes (such as with a \0 escape).

Similar to regular strings, C-strings also support "raw" syntax with the cr prefix. These raw C-strings do not process backslash escapes which can make it easier to write strings that contain backslashes. Double-quotes can be included by surrounding the quotes with the # character. Multiple # characters can be used to avoid ambiguity with internal "# sequences.

assert_eq!(cr"foo", c"foo");
// Number signs can be used to embed interior double quotes.
assert_eq!(cr#""foo""#, c"\"foo\"");
// This requires two #.
assert_eq!(cr##""foo"#"##, c"\"foo\"#");
// Escapes are not processed.
assert_eq!(cr"C:\foo", c"C:\\foo");
See The Reference for more details.

### Migration

Migration is only necessary for macros which may have been assuming a sequence of tokens that looks similar to c"…" or cr"…", which previous to the 2021 edition would tokenize as two separate tokens, but in 2021 appears as a single token.

As part of the syntax reservation for the 2021 edition, any macro input which may run into this issue should issue a warning from the rust_2021_prefixes_incompatible_syntax migration lint. See that chapter for more detail.
