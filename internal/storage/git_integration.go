package storage

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/joelpate/arxos/internal/common/logger"
)

// GitIntegration provides Git operations for ArxOS repositories
type GitIntegration struct {
	storage *FilesystemStorage
}

// NewGitIntegration creates a new Git integration
func NewGitIntegration(storage *FilesystemStorage) *GitIntegration {
	return &GitIntegration{
		storage: storage,
	}
}

// InitRepository initializes a Git repository for a building
func (gi *GitIntegration) InitRepository(ctx context.Context, buildingID string) error {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	// Check if already initialized
	gitPath := filepath.Join(repoPath, ".git")
	if _, err := os.Stat(gitPath); err == nil {
		return fmt.Errorf("repository already initialized")
	}

	// Initialize git repo
	cmd := exec.CommandContext(ctx, "git", "init")
	cmd.Dir = repoPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to init git: %s", output)
	}

	// Create .gitignore
	gitignore := `# ArxOS Building Repository
.DS_Store
*.tmp
*.backup
.arxos-cache/
node_modules/
*.log
`
	if err := os.WriteFile(filepath.Join(repoPath, ".gitignore"), []byte(gitignore), 0644); err != nil {
		return fmt.Errorf("failed to create .gitignore: %w", err)
	}

	// Create README
	readme := fmt.Sprintf(`# Building Repository: %s

This is an ArxOS building repository. Use the 'arx' CLI to interact with building data.

## Structure
- /floors/ - Floor plans and layouts
- /rooms/ - Room definitions and boundaries
- /systems/ - Building systems (HVAC, electrical, plumbing)
- /assets/ - Equipment and fixtures
- /docs/ - Building documentation

## Usage

    # View building status
    arx status /%s

    # Add a component
    arx add /%s/floor-01/room-101/electrical/outlet-01

    # Query components
    arx query /%s/systems/hvac/*

    # View changes
    git diff

Generated by ArxOS on %s
`, buildingID, buildingID, buildingID, buildingID, time.Now().Format(time.RFC3339))

	if err := os.WriteFile(filepath.Join(repoPath, "README.md"), []byte(readme), 0644); err != nil {
		return fmt.Errorf("failed to create README: %w", err)
	}

	// Initial commit
	if err := gi.Commit(ctx, buildingID, "Initial ArxOS building repository", "ArxOS System"); err != nil {
		return fmt.Errorf("failed to create initial commit: %w", err)
	}

	logger.Info("Initialized Git repository for building %s", buildingID)
	return nil
}

// Commit creates a Git commit for changes
func (gi *GitIntegration) Commit(ctx context.Context, buildingID, message, author string) error {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	// Add all changes
	cmd := exec.CommandContext(ctx, "git", "add", "-A")
	cmd.Dir = repoPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to add changes: %s", output)
	}

	// Set author if provided
	if author != "" {
		cmd = exec.CommandContext(ctx, "git", "config", "user.name", author)
		cmd.Dir = repoPath
		cmd.Run()

		cmd = exec.CommandContext(ctx, "git", "config", "user.email", fmt.Sprintf("%s@arxos.local", strings.ToLower(strings.ReplaceAll(author, " ", "."))))
		cmd.Dir = repoPath
		cmd.Run()
	}

	// Create commit
	cmd = exec.CommandContext(ctx, "git", "commit", "-m", message)
	cmd.Dir = repoPath
	if output, err := cmd.CombinedOutput(); err != nil {
		// Check if there are no changes
		if strings.Contains(string(output), "nothing to commit") {
			return nil
		}
		return fmt.Errorf("failed to commit: %s", output)
	}

	return nil
}

// Status returns the Git status of a building repository
func (gi *GitIntegration) Status(ctx context.Context, buildingID string) (string, error) {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	cmd := exec.CommandContext(ctx, "git", "status", "--porcelain")
	cmd.Dir = repoPath
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to get status: %s", output)
	}

	return string(output), nil
}

// Diff returns the diff of uncommitted changes
func (gi *GitIntegration) Diff(ctx context.Context, buildingID string, arxPath string) (string, error) {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	args := []string{"diff"}
	if arxPath != "" && arxPath != "/" {
		// Convert ArxOS path to relative filesystem path
		fsPath, err := gi.storage.ResolvePath(arxPath)
		if err != nil {
			return "", err
		}
		relPath, _ := filepath.Rel(repoPath, fsPath)
		args = append(args, relPath)
	}

	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = repoPath
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to get diff: %s", output)
	}

	return string(output), nil
}

// Log returns the commit history
func (gi *GitIntegration) Log(ctx context.Context, buildingID string, limit int) ([]CommitInfo, error) {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	args := []string{"log", "--pretty=format:%H|%an|%ae|%at|%s", fmt.Sprintf("-%d", limit)}
	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = repoPath
	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("failed to get log: %s", output)
	}

	var commits []CommitInfo
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if line == "" {
			continue
		}
		parts := strings.Split(line, "|")
		if len(parts) >= 5 {
			timestamp, _ := time.Parse("1136239445", parts[3])
			commits = append(commits, CommitInfo{
				Hash:      parts[0],
				Author:    parts[1],
				Email:     parts[2],
				Timestamp: timestamp,
				Message:   parts[4],
			})
		}
	}

	return commits, nil
}

// Branch creates or switches to a branch
func (gi *GitIntegration) Branch(ctx context.Context, buildingID, branchName string, create bool) error {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	args := []string{"checkout"}
	if create {
		args = append(args, "-b")
	}
	args = append(args, branchName)

	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = repoPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to branch: %s", output)
	}

	return nil
}

// Merge merges a branch
func (gi *GitIntegration) Merge(ctx context.Context, buildingID, sourceBranch, message string) error {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	args := []string{"merge", sourceBranch}
	if message != "" {
		args = append(args, "-m", message)
	}

	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = repoPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to merge: %s", output)
	}

	return nil
}

// Clone clones a building repository
func (gi *GitIntegration) Clone(ctx context.Context, sourceURL, buildingID string) error {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	// Ensure parent directory exists
	os.MkdirAll(filepath.Dir(repoPath), 0755)

	cmd := exec.CommandContext(ctx, "git", "clone", sourceURL, repoPath)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to clone: %s", output)
	}

	logger.Info("Cloned repository %s to %s", sourceURL, buildingID)
	return nil
}

// Push pushes changes to remote
func (gi *GitIntegration) Push(ctx context.Context, buildingID, remote, branch string) error {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	args := []string{"push"}
	if remote != "" {
		args = append(args, remote)
	}
	if branch != "" {
		args = append(args, branch)
	}

	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = repoPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to push: %s", output)
	}

	return nil
}

// Pull pulls changes from remote
func (gi *GitIntegration) Pull(ctx context.Context, buildingID, remote, branch string) error {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	args := []string{"pull"}
	if remote != "" {
		args = append(args, remote)
	}
	if branch != "" {
		args = append(args, branch)
	}

	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = repoPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to pull: %s", output)
	}

	return nil
}

// Tag creates a tag
func (gi *GitIntegration) Tag(ctx context.Context, buildingID, tagName, message string) error {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	args := []string{"tag"}
	if message != "" {
		args = append(args, "-a", tagName, "-m", message)
	} else {
		args = append(args, tagName)
	}

	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = repoPath
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to tag: %s", output)
	}

	return nil
}

// CommitInfo represents Git commit information
type CommitInfo struct {
	Hash      string
	Author    string
	Email     string
	Timestamp time.Time
	Message   string
}

// GetCurrentBranch returns the current branch name
func (gi *GitIntegration) GetCurrentBranch(ctx context.Context, buildingID string) (string, error) {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	cmd := exec.CommandContext(ctx, "git", "branch", "--show-current")
	cmd.Dir = repoPath
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to get current branch: %s", output)
	}

	return strings.TrimSpace(string(output)), nil
}

// ListBranches returns all branches
func (gi *GitIntegration) ListBranches(ctx context.Context, buildingID string) ([]string, error) {
	repoPath := filepath.Join(gi.storage.rootPath, "buildings", buildingID)

	cmd := exec.CommandContext(ctx, "git", "branch", "-a")
	cmd.Dir = repoPath
	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("failed to list branches: %s", output)
	}

	var branches []string
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line != "" {
			// Remove current branch marker
			line = strings.TrimPrefix(line, "* ")
			branches = append(branches, line)
		}
	}

	return branches, nil
}