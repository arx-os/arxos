class VersionControlManager{constructor(){this.baseUrl='/v1/version-control';this.eventListeners={'version_created':[],'branch_created':[],'merge_request_created':[],'conflict_resolved':[],'merge_executed':[],'annotation_added':[],'comment_added':[],'branch_graph_updated':[]};this.utils=window.sharedUtilities||new SharedUtilities();}
addEventListener(event,callback){if(!this.eventListeners[event])this.eventListeners[event]=[];this.eventListeners[event].push(callback);}
emit(event,data){if(this.eventListeners[event]){this.eventListeners[event].forEach(cb=>{try{cb(data);}catch(e){console.error(e);}});}}
async createVersion(floorData,floorId,buildingId,branchName,commitMessage,author,options={}){const res=await fetch(`${this.baseUrl}/version`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({floor_data:floorData,floor_id:floorId,building_id:buildingId,branch_name:branchName,commit_message:commitMessage,author:author,parent_version_id:options.parentVersionId,version_type:options.versionType||'minor'})});const result=await res.json();this.emit('version_created',result);return result;}
async getVersionHistory(buildingId,floorId,branchName=null){const url=branchName?`${this.baseUrl}/versions/${buildingId}/${floorId}?branch_name=${branchName}`:`${this.baseUrl}/versions/${buildingId}/${floorId}`;const res=await fetch(url);return await res.json();}
async getVersionData(versionId){const res=await fetch(`${this.baseUrl}/version/${versionId}`);return await res.json();}
async createBranch(branchName,floorId,buildingId,baseVersionId,createdBy,description=''){const res=await fetch(`${this.baseUrl}/branch`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({branch_name:branchName,floor_id:floorId,building_id:buildingId,base_version_id:baseVersionId,created_by:createdBy,description:description})});const result=await res.json();this.emit('branch_created',result);return result;}
async getBranches(buildingId,floorId){const res=await fetch(`${this.baseUrl}/branches/${buildingId}/${floorId}`);return await res.json();}
async createMergeRequest(sourceBranch,targetBranch,floorId,buildingId,createdBy,description=''){const res=await fetch(`${this.baseUrl}/merge-request`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({source_branch:sourceBranch,target_branch:targetBranch,floor_id:floorId,building_id:buildingId,created_by:createdBy,description:description})});const result=await res.json();this.emit('merge_request_created',result);return result;}
async resolveConflict(mergeId,conflictId,resolution,resolvedBy){const res=await fetch(`${this.baseUrl}/merge/${mergeId}/resolve-conflict`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({conflict_id:conflictId,resolution:resolution,resolved_by:resolvedBy})});const result=await res.json();this.emit('conflict_resolved',result);return result;}
async executeMerge(mergeId,executedBy){const res=await fetch(`${this.baseUrl}/merge/${mergeId}/execute`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({executed_by:executedBy})});const result=await res.json();this.emit('merge_executed',result);return result;}
async addAnnotation(versionId,floorId,buildingId,title,content,author,options={}){const res=await fetch(`${this.baseUrl}/annotation`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({version_id:versionId,floor_id:floorId,building_id:buildingId,title:title,content:content,author:author,object_id:options.objectId,position_x:options.positionX,position_y:options.positionY,annotation_type:options.annotationType||'note'})});const result=await res.json();this.emit('annotation_added',result);return result;}
async getAnnotations(versionId){const res=await fetch(`${this.baseUrl}/annotations/${versionId}`);return await res.json();}
async searchAnnotations(buildingId,floorId,query){const res=await fetch(`${this.baseUrl}/annotations/search/${buildingId}/${floorId}?query=${encodeURIComponent(query)}`);return await res.json();}
async addComment(parentId,parentType,content,author){const res=await fetch(`${this.baseUrl}/comment`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({parent_id:parentId,parent_type:parentType,content:content,author:author})});const result=await res.json();this.emit('comment_added',result);return result;}
async getComments(parentId,parentType){const res=await fetch(`${this.baseUrl}/comments/${parentId}?parent_type=${parentType}`);return await res.json();}
async getBranchGraph(buildingId,floorId){const res=await fetch(`${this.baseUrl}/branch-graph/${buildingId}/${floorId}`);const result=await res.json();this.emit('branch_graph_updated',result);return result;}
async exportVersionData(buildingId,floorId,options={}){const url=`${this.baseUrl}/export/${buildingId}/${floorId}?include_annotations=${options.includeAnnotations !== false}&include_comments=${options.includeComments !== false}`;const res=await fetch(url);return await res.json();}
renderBranchGraph(graphData,container){if(!container||!graphData.success)return;container.innerHTML='';const graph=graphData.graph;const timeline=document.createElement('div');timeline.className='branch-timeline';const branchVersions={};graph.versions.forEach(version=>{if(!branchVersions[version.branch]){branchVersions[version.branch]=[];}
branchVersions[version.branch].push(version);});Object.keys(branchVersions).forEach(branchName=>{const branchLane=document.createElement('div');branchLane.className='branch-lane';branchLane.innerHTML=`
                <div class="branch-header">${branchName}</div>
                <div class="version-timeline">
                    ${branchVersions[branchName].map(version => `<div class="version-node"data-version-id="${version.version_id}"><div class="version-number">${version.version_number}</div><div class="version-author">${version.author}</div><div class="version-date">${new Date(version.created_at).toLocaleDateString()}</div></div>`).join('')}
                </div>
            `;timeline.appendChild(branchLane);});container.appendChild(timeline);}
renderMergeConflicts(conflicts,container){if(!container)return;container.innerHTML='';const conflictsList=document.createElement('div');conflictsList.className='conflicts-list';conflicts.forEach(conflict=>{const conflictItem=document.createElement('div');conflictItem.className='conflict-item';conflictItem.innerHTML=`
                <div class="conflict-header">
                    <span class="conflict-type">${conflict.type}</span>
                    <span class="object-id">${conflict.object_id || 'N/A'}</span>
                </div>
                <div class="conflict-content">
                    <div class="source-value">
                        <strong>Source:</strong> ${JSON.stringify(conflict.source_value)}
                    </div>
                    <div class="target-value">
                        <strong>Target:</strong> ${JSON.stringify(conflict.target_value)}
                    </div>
                </div>
                <div class="conflict-resolution">
                    <select class="resolution-select" data-conflict-id="${conflict.conflict_id}">
                        <option value="">Choose resolution...</option>
                        <option value="source">Use Source</option>
                        <option value="target">Use Target</option>
                        <option value="manual">Manual Edit</option>
                    </select>
                </div>
            `;conflictsList.appendChild(conflictItem);});container.appendChild(conflictsList);}
renderAnnotations(annotations,container){if(!container)return;container.innerHTML='';const annotationsList=document.createElement('div');annotationsList.className='annotations-list';annotations.forEach(annotation=>{const annotationItem=document.createElement('div');annotationItem.className='annotation-item';annotationItem.innerHTML=`
                <div class="annotation-header">
                    <span class="annotation-title">${annotation.title}</span>
                    <span class="annotation-type">${annotation.annotation_type}</span>
                </div>
                <div class="annotation-content">${annotation.content}</div>
                <div class="annotation-meta">
                    <span class="annotation-author">${annotation.author}</span>
                    <span class="annotation-date">${new Date(annotation.created_at).toLocaleDateString()}</span>
                </div>
                <div class="annotation-actions">
                    <button class="btn-comment" data-annotation-id="${annotation.annotation_id}">Add Comment</button>
                </div>
            `;annotationsList.appendChild(annotationItem);});container.appendChild(annotationsList);}
renderComments(comments,container){if(!container)return;container.innerHTML='';const commentsList=document.createElement('div');commentsList.className='comments-list';comments.forEach(comment=>{const commentItem=document.createElement('div');commentItem.className='comment-item';commentItem.innerHTML=`
                <div class="comment-content">${comment.content}</div>
                <div class="comment-meta">
                    <span class="comment-author">${comment.author}</span>
                    <span class="comment-date">${new Date(comment.created_at).toLocaleDateString()}</span>
                </div>
            `;commentsList.appendChild(commentItem);});container.appendChild(commentsList);}
showConflictResolutionDialog(conflicts,onResolve){const dialog=document.createElement('div');dialog.className='conflict-resolution-dialog';dialog.innerHTML=`
            <div class="dialog-content">
                <h3>Resolve Merge Conflicts</h3>
                <div class="conflicts-container"></div>
                <div class="dialog-actions">
                    <button class="btn-cancel">Cancel</button>
                    <button class="btn-resolve">Resolve All</button>
                </div>
            </div>
        `;this.renderMergeConflicts(conflicts,dialog.querySelector('.conflicts-container'));dialog.querySelector('.btn-cancel').addEventListener('click',()=>{document.body.removeChild(dialog);});dialog.querySelector('.btn-resolve').addEventListener('click',()=>{const resolutions={};dialog.querySelectorAll('.resolution-select').forEach(select=>{if(select.value){resolutions[select.dataset.conflictId]=select.value;}});onResolve(resolutions);document.body.removeChild(dialog);});document.body.appendChild(dialog);}
downloadExport(data,filename){this.utils.downloadJSON(data,filename);}
formatVersionNumber(versionNumber){return versionNumber.replace(/_/g,' ').replace(/-/g,' ');}
getVersionTypeColor(versionType){const colors={'major':'#dc3545','minor':'#007bff','patch':'#28a745','branch':'#6c757d'};return colors[versionType]||'#6c757d';}}
window.versionControlManager=new VersionControlManager();if(typeof module!=='undefined'&&module.exports){module.exports=VersionControlManager;}