class ViewportManager{constructor(svgElement,options={}){this.svg=svgElement;this.container=svgElement.parentElement;this.currentZoom=options.initialZoom||1.0;this.panX=options.initialPanX||0;this.panY=options.initialPanY||0;this.minZoom=options.minZoom||0.1;this.maxZoom=options.maxZoom||5.0;this.zoomStep=options.zoomStep||0.1;this.wheelZoomSpeed=options.wheelZoomSpeed||0.001;this.wheelZoomSmooth=options.wheelZoomSmooth!==false;this.wheelZoomDuration=options.wheelZoomDuration||150;this.panEnabled=options.panEnabled!==false;this.panInertia=options.panInertia!==false;this.panInertiaDecay=options.panInertiaDecay||0.95;this.panInertiaDuration=options.panInertiaDuration||300;this.panBoundaries=options.panBoundaries||{enabled:true,padding:100,maxDistance:2000};this.zoomHistory=[];this.maxHistorySize=options.maxHistorySize||50;this.historyIndex=-1;this.isUpdating=false;this.updateQueue=[];this.lastUpdateTime=0;this.updateThrottle=options.updateThrottle||16;this.throttledUpdateManager=null;this.enableThrottledUpdates=options.enableThrottledUpdates!==false;this.isAnimating=false;this.targetZoom=null;this.targetPanX=null;this.targetPanY=null;this.eventHandlers=new Map();this.isPanning=false;this.panStartX=0;this.panStartY=0;this.panStartViewX=0;this.panStartViewY=0;this.panVelocityX=0;this.panVelocityY=0;this.panInertiaAnimation=null;this.hasShownPanIndicator=false;this.lastPanTime=null;this.scaleFactors={x:1.0,y:1.0};this.currentUnit='pixels';this.cullingEnabled=options.cullingEnabled!==false;this.cullingMargin=options.cullingMargin||100;this.cullingUpdateThrottle=options.cullingUpdateThrottle||50;this.lastCullingUpdate=0;this.visibleObjects=new Set();this.totalObjects=0;this.cullingStats={totalObjects:0,visibleObjects:0,culledObjects:0,cullingTime:0,lastUpdate:0};this.objectBoundsCache=new Map();this.boundsCacheExpiry=options.boundsCacheExpiry||5000;this.lastBoundsCacheCleanup=0;this.touchEnabled=options.touchEnabled!==false;this.touchZoomEnabled=options.touchZoomEnabled!==false;this.touchPanEnabled=options.touchPanEnabled!==false;this.touchGestureEnabled=options.touchGestureEnabled!==false;this.touchState={isTouching:false,touchCount:0,startTouches:[],currentTouches:[],startDistance:0,startCenter:{x:0,y:0},lastDistance:0,lastCenter:{x:0,y:0},startTime:0,lastMoveTime:0,velocity:{x:0,y:0},gestureType:null};this.touchConfig={pinchSensitivity:options.pinchSensitivity||0.01,panSensitivity:options.panSensitivity||1.0,tapThreshold:options.tapThreshold||10,tapTimeout:options.tapTimeout||300,doubleTapTimeout:options.doubleTapTimeout||300,swipeThreshold:options.swipeThreshold||50,swipeVelocity:options.swipeVelocity||0.3,longPressTimeout:options.longPressTimeout||500,touchInertia:options.touchInertia!==false,touchInertiaDecay:options.touchInertiaDecay||0.95};this.touchGestureHistory=[];this.maxGestureHistory=options.maxGestureHistory||10;this.initialize();}
initialize(){if(!this.svg||!this.container){console.error('ViewportManager: SVG element or container not found');return;}
this.container.classList.add('pan-enabled');this.connectToThrottledUpdateManager();this.updateViewport();this.setupEventListeners();this.saveZoomState();this.triggerEvent('initialized',{zoom:this.currentZoom,panX:this.panX,panY:this.panY});if(window.arxLogger){window.arxLogger.info('ViewportManager initialized',{component:'viewport_manager',version:'1.0.0'});}}
connectToThrottledUpdateManager(){if(!this.enableThrottledUpdates){if(window.arxLogger){window.arxLogger.info('ViewportManager: Throttled updates disabled',{component:'viewport_manager',feature:'throttled_updates',status:'disabled'});}
return;}
const checkThrottledUpdateManager=()=>{if(window.throttledUpdateManager){this.throttledUpdateManager=window.throttledUpdateManager;if(window.arxLogger){window.arxLogger.info('ViewportManager connected to ThrottledUpdateManager',{component:'viewport_manager',integration:'throttled_update_manager',status:'connected'});}
this.throttledUpdateManager.addEventListener('update',(data)=>{this.handleThrottledUpdate(data);});this.throttledUpdateManager.addEventListener('batchedUpdate',(data)=>{this.handleBatchedUpdate(data);});this.throttledUpdateManager.addEventListener('updateProcessed',(data)=>{this.handleUpdateProcessed(data);});}else{setTimeout(checkThrottledUpdateManager,100);}};checkThrottledUpdateManager();}
setupEventListeners(){this.container.addEventListener('wheel',this.handleWheel.bind(this),{passive:false});this.container.addEventListener('mousedown',this.handleMouseDown.bind(this));document.addEventListener('mousemove',this.handleMouseMove.bind(this));document.addEventListener('mouseup',this.handleMouseUp.bind(this));this.container.addEventListener('contextmenu',(e)=>{if(this.isPanning){e.preventDefault();}});if(this.touchEnabled){this.setupTouchEventListeners();}
document.addEventListener('keydown',this.handleKeyDown.bind(this));window.addEventListener('resize',this.handleResize.bind(this));}
setupTouchEventListeners(){this.container.addEventListener('touchstart',this.handleTouchStart.bind(this),{passive:false});this.container.addEventListener('touchmove',this.handleTouchMove.bind(this),{passive:false});this.container.addEventListener('touchend',this.handleTouchEnd.bind(this),{passive:false});this.container.addEventListener('touchcancel',this.handleTouchCancel.bind(this),{passive:false});this.container.addEventListener('touchstart',(e)=>{if(this.touchState.isTouching){e.preventDefault();}},{passive:false});this.container.addEventListener('touchmove',(e)=>{if(this.touchState.isTouching){e.preventDefault();}},{passive:false});}
handleTouchStart(event){event.preventDefault();const touches=Array.from(event.touches);this.touchState.touchCount=touches.length;this.touchState.startTouches=touches.map(touch=>({id:touch.identifier,x:touch.clientX,y:touch.clientY}));this.touchState.currentTouches=[...this.touchState.startTouches];this.touchState.startTime=performance.now();this.touchState.lastMoveTime=this.touchState.startTime;this.touchState.isTouching=true;this.touchState.gestureType=null;if(touches.length===2){this.touchState.startDistance=this.calculateTouchDistance(touches[0],touches[1]);this.touchState.startCenter=this.calculateTouchCenter(touches[0],touches[1]);this.touchState.lastDistance=this.touchState.startDistance;this.touchState.lastCenter={...this.touchState.startCenter};}
this.container.classList.add('touching');this.triggerEvent('touchStart',{touchCount:this.touchState.touchCount,touches:this.touchState.startTouches});}
handleTouchMove(event){event.preventDefault();if(!this.touchState.isTouching)return;const touches=Array.from(event.touches);this.touchState.currentTouches=touches.map(touch=>({id:touch.identifier,x:touch.clientX,y:touch.clientY}));const currentTime=performance.now();const timeDelta=currentTime-this.touchState.lastMoveTime;if(touches.length===1&&this.touchPanEnabled){this.handleSingleTouchMove(touches[0],timeDelta);}else if(touches.length===2&&this.touchZoomEnabled){this.handlePinchZoom(touches[0],touches[1],timeDelta);}
this.touchState.lastMoveTime=currentTime;this.triggerEvent('touchMove',{touchCount:touches.length,touches:this.touchState.currentTouches,gestureType:this.touchState.gestureType});}
handleTouchEnd(event){event.preventDefault();if(!this.touchState.isTouching)return;const currentTime=performance.now();const touchDuration=currentTime-this.touchState.startTime;this.determineTouchGesture(touchDuration);if(this.touchState.gestureType==='pan'&&this.touchConfig.touchInertia){this.startTouchInertia();}
this.saveZoomState();this.touchState.isTouching=false;this.touchState.touchCount=0;this.touchState.gestureType=null;this.container.classList.remove('touching');this.triggerEvent('touchEnd',{gestureType:this.touchState.gestureType,duration:touchDuration,velocity:this.touchState.velocity});}
handleTouchCancel(event){event.preventDefault();this.touchState.isTouching=false;this.touchState.touchCount=0;this.touchState.gestureType=null;this.container.classList.remove('touching');this.triggerEvent('touchCancel');}
handleSingleTouchMove(touch,timeDelta){const startTouch=this.touchState.startTouches[0];if(!startTouch)return;const deltaX=touch.clientX-startTouch.x;const deltaY=touch.clientY-startTouch.y;const distance=Math.sqrt(deltaX*deltaX+deltaY*deltaY);if(distance>this.touchConfig.tapThreshold){this.touchState.gestureType='pan';const panDeltaX=deltaX/this.currentZoom*this.touchConfig.panSensitivity;const panDeltaY=deltaY/this.currentZoom*this.touchConfig.panSensitivity;const newPanX=this.panX+panDeltaX;const newPanY=this.panY+panDeltaY;const constrainedPan=this.applyPanBoundaries(newPanX,newPanY);this.panX=constrainedPan.x;this.panY=constrainedPan.y;if(timeDelta>0){this.touchState.velocity.x=deltaX/timeDelta;this.touchState.velocity.y=deltaY/timeDelta;}
if(this.throttledUpdateManager){this.throttledUpdateManager.queueUpdate('touchPan',{panX:this.panX,panY:this.panY,deltaX:deltaX,deltaY:deltaY});}else{this.updateViewport();}
this.touchState.startTouches[0]={id:startTouch.id,x:touch.clientX,y:touch.clientY};}}
handlePinchZoom(touch1,touch2,timeDelta){const currentDistance=this.calculateTouchDistance(touch1,touch2);const currentCenter=this.calculateTouchCenter(touch1,touch2);const distanceRatio=currentDistance/this.touchState.startDistance;const zoomFactor=Math.pow(distanceRatio,this.touchConfig.pinchSensitivity);const rect=this.container.getBoundingClientRect();const centerX=currentCenter.x-rect.left;const centerY=currentCenter.y-rect.top;this.zoomAtPoint(zoomFactor,centerX,centerY,true);const centerDeltaX=currentCenter.x-this.touchState.startCenter.x;const centerDeltaY=currentCenter.y-this.touchState.startCenter.y;if(Math.abs(centerDeltaX)>5||Math.abs(centerDeltaY)>5){const panDeltaX=centerDeltaX/this.currentZoom*this.touchConfig.panSensitivity;const panDeltaY=centerDeltaY/this.currentZoom*this.touchConfig.panSensitivity;const newPanX=this.panX+panDeltaX;const newPanY=this.panY+panDeltaY;const constrainedPan=this.applyPanBoundaries(newPanX,newPanY);this.panX=constrainedPan.x;this.panY=constrainedPan.y;}
this.touchState.lastDistance=currentDistance;this.touchState.lastCenter={...currentCenter};this.touchState.gestureType='pinch';if(this.throttledUpdateManager){this.throttledUpdateManager.queueUpdate('touchZoom',{zoom:this.currentZoom,zoomFactor:zoomFactor,centerX:centerX,centerY:centerY});}else{this.updateViewport();}}
calculateTouchDistance(touch1,touch2){const dx=touch1.clientX-touch2.clientX;const dy=touch1.clientY-touch2.clientY;return Math.sqrt(dx*dx+dy*dy);}
calculateTouchCenter(touch1,touch2){return{x:(touch1.clientX+touch2.clientX)/2,y:(touch1.clientY+touch2.clientY)/2};}
determineTouchGesture(touchDuration){const startTouch=this.touchState.startTouches[0];const currentTouch=this.touchState.currentTouches[0];if(!startTouch||!currentTouch)return;const deltaX=currentTouch.x-startTouch.x;const deltaY=currentTouch.y-startTouch.y;const distance=Math.sqrt(deltaX*deltaX+deltaY*deltaY);if(distance<this.touchConfig.tapThreshold){if(touchDuration<this.touchConfig.tapTimeout){this.touchState.gestureType='tap';this.handleTapGesture();}else{this.touchState.gestureType='long-press';this.handleLongPressGesture();}}else if(distance>this.touchConfig.swipeThreshold){const velocity=distance/touchDuration;if(velocity>this.touchConfig.swipeVelocity){this.touchState.gestureType='swipe';this.handleSwipeGesture(deltaX,deltaY,velocity);}else{this.touchState.gestureType='pan';}}else{this.touchState.gestureType='pan';}
this.addToGestureHistory(this.touchState.gestureType);}
handleTapGesture(){const startTouch=this.touchState.startTouches[0];if(!startTouch)return;const lastGesture=this.touchGestureHistory[this.touchGestureHistory.length-1];if(lastGesture&&lastGesture.type==='tap'){const timeSinceLastTap=performance.now()-lastGesture.timestamp;if(timeSinceLastTap<this.touchConfig.doubleTapTimeout){this.touchState.gestureType='double-tap';this.handleDoubleTapGesture();return;}}
this.triggerEvent('tap',{x:startTouch.x,y:startTouch.y,timestamp:performance.now()});}
handleDoubleTapGesture(){const startTouch=this.touchState.startTouches[0];if(!startTouch)return;this.resetView();this.triggerEvent('doubleTap',{x:startTouch.x,y:startTouch.y,timestamp:performance.now()});}
handleLongPressGesture(){const startTouch=this.touchState.startTouches[0];if(!startTouch)return;this.triggerEvent('longPress',{x:startTouch.x,y:startTouch.y,timestamp:performance.now()});}
handleSwipeGesture(deltaX,deltaY,velocity){const startTouch=this.touchState.startTouches[0];if(!startTouch)return;const angle=Math.atan2(deltaY,deltaX)*180/Math.PI;let direction='unknown';if(angle>=-45&&angle<=45)direction='right';else if(angle>=45&&angle<=135)direction='down';else if(angle>=135||angle<=-135)direction='left';else direction='up';this.triggerEvent('swipe',{direction:direction,deltaX:deltaX,deltaY:deltaY,velocity:velocity,x:startTouch.x,y:startTouch.y,timestamp:performance.now()});}
startTouchInertia(){if(!this.touchConfig.touchInertia||(Math.abs(this.touchState.velocity.x)<0.1&&Math.abs(this.touchState.velocity.y)<0.1)){return;}
const startTime=performance.now();const startPanX=this.panX;const startPanY=this.panY;const startVelocityX=this.touchState.velocity.x/this.currentZoom;const startVelocityY=this.touchState.velocity.y/this.currentZoom;const animate=(currentTime)=>{const elapsed=currentTime-startTime;const progress=elapsed/this.panInertiaDuration;if(progress>=1){return;}
const decay=Math.pow(this.touchConfig.touchInertiaDecay,progress*10);const currentVelocityX=startVelocityX*decay;const currentVelocityY=startVelocityY*decay;const newPanX=startPanX+currentVelocityX*progress*10;const newPanY=startPanY+currentVelocityY*progress*10;const constrainedPan=this.applyPanBoundaries(newPanX,newPanY);this.panX=constrainedPan.x;this.panY=constrainedPan.y;if(this.throttledUpdateManager){this.throttledUpdateManager.queueUpdate('touchInertia',{panX:this.panX,panY:this.panY,velocityX:currentVelocityX,velocityY:currentVelocityY});}else{this.updateViewport();}
if(Math.abs(currentVelocityX)>0.1||Math.abs(currentVelocityY)>0.1){requestAnimationFrame(animate);}};requestAnimationFrame(animate);}
addToGestureHistory(gestureType){this.touchGestureHistory.push({type:gestureType,timestamp:performance.now()});if(this.touchGestureHistory.length>this.maxGestureHistory){this.touchGestureHistory.shift();}}
enableTouch(){this.touchEnabled=true;this.setupTouchEventListeners();}
disableTouch(){this.touchEnabled=false;}
getTouchConfig(){return{...this.touchConfig};}
updateTouchConfig(newConfig){Object.assign(this.touchConfig,newConfig);}
handleWheel(event){event.preventDefault();const isCtrlZoom=event.ctrlKey||event.metaKey;if(isCtrlZoom){this.handleZoomWheel(event);}else{this.handleScrollWheel(event);}}
handleZoomWheel(event){const delta=event.deltaY;const zoomSpeed=this.wheelZoomSpeed;const zoomFactor=1-(delta*zoomSpeed);const rect=this.container.getBoundingClientRect();const mouseX=event.clientX-rect.left;const mouseY=event.clientY-rect.top;this.zoomAtPoint(zoomFactor,mouseX,mouseY,this.wheelZoomSmooth);this.showZoomFeedback(event);}
handleScrollWheel(event){event.preventDefault();}
showZoomFeedback(event){this.container.classList.add('zooming');setTimeout(()=>{this.container.classList.remove('zooming');},200);if(this.currentZoom<=this.minZoom||this.currentZoom>=this.maxZoom){this.showZoomConstraint();}}
showZoomConstraint(){let constraintElement=document.getElementById('zoom-constraint');if(!constraintElement){constraintElement=document.createElement('div');constraintElement.id='zoom-constraint';constraintElement.className='zoom-constraint';this.container.appendChild(constraintElement);}
const message=this.currentZoom<=this.minZoom?`Min zoom: ${Math.round(this.minZoom * 100)}%`:`Max zoom: ${Math.round(this.maxZoom * 100)}%`;constraintElement.textContent=message;constraintElement.classList.add('show');setTimeout(()=>{constraintElement.classList.remove('show');},2000);}
isAtZoomConstraint(){return this.currentZoom<=this.minZoom||this.currentZoom>=this.maxZoom;}
getZoomConstraintMessage(){if(this.currentZoom<=this.minZoom){return`Min zoom: ${Math.round(this.minZoom * 100)}%`;}else if(this.currentZoom>=this.maxZoom){return`Max zoom: ${Math.round(this.maxZoom * 100)}%`;}
return null;}
applyZoomWithConstraints(newZoom,newPanX,newPanY,smooth=false){const wasAtConstraint=this.isAtZoomConstraint();if(smooth){this.applySmoothZoom(newZoom,newPanX,newPanY);}else{this.currentZoom=newZoom;this.panX=newPanX;this.panY=newPanY;this.queueViewportUpdate();}
const isAtConstraint=this.isAtZoomConstraint();if(isAtConstraint&&!wasAtConstraint){this.showZoomConstraint();}
this.updateZoomButtonStates();}
updateZoomButtonStates(){const zoomInBtn=document.getElementById('zoom-in');const zoomOutBtn=document.getElementById('zoom-out');if(zoomInBtn){zoomInBtn.disabled=this.currentZoom>=this.maxZoom;zoomInBtn.title=this.currentZoom>=this.maxZoom?`Max zoom: ${Math.round(this.maxZoom * 100)}%`:'Zoom In (Ctrl + +)';}
if(zoomOutBtn){zoomOutBtn.disabled=this.currentZoom<=this.minZoom;zoomOutBtn.title=this.currentZoom<=this.minZoom?`Min zoom: ${Math.round(this.minZoom * 100)}%`:'Zoom Out (Ctrl + -)';}}
handleMouseDown(event){if(event.button===1&&this.panEnabled){event.preventDefault();this.startPan(event);}}
startPan(event){this.isPanning=true;this.panStartX=event.clientX;this.panStartY=event.clientY;this.panStartViewX=this.panX;this.panStartViewY=this.panY;this.panVelocityX=0;this.panVelocityY=0;if(this.panInertiaAnimation){cancelAnimationFrame(this.panInertiaAnimation);this.panInertiaAnimation=null;}
this.container.classList.add('panning');this.container.style.cursor='grabbing';if(!this.hasShownPanIndicator){this.showPanModeIndicator();this.hasShownPanIndicator=true;}
this.triggerEvent('panStart',{x:this.panStartX,y:this.panStartY});}
handleMouseMove(event){if(!this.isPanning)return;const deltaX=event.clientX-this.panStartX;const deltaY=event.clientY-this.panStartY;const newPanX=this.panStartViewX+deltaX/this.currentZoom;const newPanY=this.panStartViewY+deltaY/this.currentZoom;const boundedPan=this.applyPanBoundaries(newPanX,newPanY);this.panX=boundedPan.x;this.panY=boundedPan.y;if(this.throttledUpdateManager){this.throttledUpdateManager.queueUpdate('pan',{panX:this.panX,panY:this.panY,deltaX:deltaX,deltaY:deltaY});}else{this.updateViewport();}
const currentTime=performance.now();if(this.lastPanTime){const timeDelta=currentTime-this.lastPanTime;if(timeDelta>0){this.panVelocityX=deltaX/timeDelta;this.panVelocityY=deltaY/timeDelta;}}
this.lastPanTime=currentTime;this.showPanModeIndicator();}
handleMouseUp(event){if(this.isPanning){this.endPan();}}
endPan(){this.isPanning=false;this.container.classList.remove('panning');this.container.style.cursor='';if(Math.abs(this.panVelocityX)>0.5||Math.abs(this.panVelocityY)>0.5){this.showPanVelocityIndicator();}
if(this.panInertia&&(Math.abs(this.panVelocityX)>0.1||Math.abs(this.panVelocityY)>0.1)){this.showPanInertiaIndicator();this.startPanInertia();}
this.saveZoomState();this.triggerEvent('panEnd',{x:this.panX,y:this.panY,velocityX:this.panVelocityX,velocityY:this.panVelocityY});}
applyPanBoundaries(panX,panY){if(!this.panBoundaries.enabled){return{x:panX,y:panY};}
const rect=this.container.getBoundingClientRect();const containerWidth=rect.width;const containerHeight=rect.height;const maxPanX=Math.max(0,(containerWidth*this.currentZoom-containerWidth)/2+this.panBoundaries.padding);const maxPanY=Math.max(0,(containerHeight*this.currentZoom-containerHeight)/2+this.panBoundaries.padding);const minPanX=-maxPanX;const minPanY=-maxPanY;const maxDistance=this.panBoundaries.maxDistance;const distanceFromCenter=Math.sqrt(panX*panX+panY*panY);if(distanceFromCenter>maxDistance){const scale=maxDistance/distanceFromCenter;panX*=scale;panY*=scale;}
const boundaryResistance=0.3;if(panX>maxPanX){const overflow=panX-maxPanX;panX=maxPanX+overflow*boundaryResistance;}else if(panX<minPanX){const overflow=minPanX-panX;panX=minPanX-overflow*boundaryResistance;}
if(panY>maxPanY){const overflow=panY-maxPanY;panY=maxPanY+overflow*boundaryResistance;}else if(panY<minPanY){const overflow=minPanY-panY;panY=minPanY-overflow*boundaryResistance;}
return{x:panX,y:panY};}
startPanInertia(){const startTime=performance.now();const startPanX=this.panX;const startPanY=this.panY;const startVelocityX=this.panVelocityX;const startVelocityY=this.panVelocityY;const animate=(currentTime)=>{const elapsed=currentTime-startTime;const progress=elapsed/this.panInertiaDuration;if(progress>=1){this.panInertiaAnimation=null;return;}
const decay=Math.pow(this.panInertiaDecay,progress*10);const currentVelocityX=startVelocityX*decay;const currentVelocityY=startVelocityY*decay;const newPanX=startPanX+currentVelocityX*progress*10;const newPanY=startPanY+currentVelocityY*progress*10;const constrainedPan=this.applyPanBoundaries(newPanX,newPanY);this.panX=constrainedPan.x;this.panY=constrainedPan.y;this.queueViewportUpdate();if(Math.abs(currentVelocityX)>0.1||Math.abs(currentVelocityY)>0.1){this.panInertiaAnimation=requestAnimationFrame(animate);}else{this.panInertiaAnimation=null;}};this.panInertiaAnimation=requestAnimationFrame(animate);}
stopPanInertia(){if(this.panInertiaAnimation){cancelAnimationFrame(this.panInertiaAnimation);this.panInertiaAnimation=null;}
this.panVelocityX=0;this.panVelocityY=0;}
showPanBoundaryFeedback(){let feedbackElement=document.getElementById('pan-boundary-feedback');if(!feedbackElement){feedbackElement=document.createElement('div');feedbackElement.id='pan-boundary-feedback';feedbackElement.className='pan-boundary-feedback';this.container.appendChild(feedbackElement);}
feedbackElement.classList.add('show');setTimeout(()=>{feedbackElement.classList.remove('show');},1000);}
showPanInertiaIndicator(){let indicatorElement=document.getElementById('pan-inertia-indicator');if(!indicatorElement){indicatorElement=document.createElement('div');indicatorElement.id='pan-inertia-indicator';indicatorElement.className='pan-inertia-indicator';this.container.appendChild(indicatorElement);}
indicatorElement.classList.add('show');setTimeout(()=>{indicatorElement.classList.remove('show');},1000);}
showPanVelocityIndicator(){let indicatorElement=document.getElementById('pan-velocity-indicator');if(!indicatorElement){indicatorElement=document.createElement('div');indicatorElement.id='pan-velocity-indicator';indicatorElement.className='pan-velocity-indicator';this.container.appendChild(indicatorElement);}
const velocityX=Math.round(this.panVelocityX*100)/100;const velocityY=Math.round(this.panVelocityY*100)/100;const speed=Math.sqrt(velocityX*velocityX+velocityY*velocityY);indicatorElement.textContent=`V: (${velocityX}, ${velocityY}) | S: ${speed.toFixed(2)}`;indicatorElement.classList.add('show');setTimeout(()=>{indicatorElement.classList.remove('show');},2000);}
showPanModeIndicator(){let indicatorElement=document.getElementById('pan-mode-indicator');if(!indicatorElement){indicatorElement=document.createElement('div');indicatorElement.id='pan-mode-indicator';indicatorElement.className='pan-mode-indicator';indicatorElement.textContent='Middle mouse to pan';this.container.appendChild(indicatorElement);}
indicatorElement.classList.add('show');setTimeout(()=>{indicatorElement.classList.remove('show');},3000);}
showPanBoundaryWarning(){let warningElement=document.getElementById('pan-boundary-warning');if(!warningElement){warningElement=document.createElement('div');warningElement.id='pan-boundary-warning';warningElement.className='pan-boundary-warning';warningElement.textContent='Pan boundary reached';this.container.appendChild(warningElement);}
warningElement.classList.add('show');setTimeout(()=>{warningElement.classList.remove('show');},1500);}
isAtPanBoundary(){if(!this.panBoundaries.enabled)return false;const rect=this.container.getBoundingClientRect();const containerWidth=rect.width;const containerHeight=rect.height;const maxPanX=Math.max(0,(containerWidth*this.currentZoom-containerWidth)/2+this.panBoundaries.padding);const maxPanY=Math.max(0,(containerHeight*this.currentZoom-containerHeight)/2+this.panBoundaries.padding);const minPanX=-maxPanX;const minPanY=-maxPanY;return this.panX>=maxPanX||this.panX<=minPanX||this.panY>=maxPanY||this.panY<=minPanY;}
enablePan(){this.panEnabled=true;this.container.classList.add('pan-enabled');this.triggerEvent('panEnabled');}
disablePan(){this.panEnabled=false;this.container.classList.remove('pan-enabled');if(this.isPanning){this.endPan();}
this.triggerEvent('panDisabled');}
togglePan(){if(this.panEnabled){this.disablePan();}else{this.enablePan();}}
isPanEnabled(){return this.panEnabled;}
setPanBoundaries(boundaries){this.panBoundaries={...this.panBoundaries,...boundaries};this.triggerEvent('panBoundariesChanged',this.panBoundaries);}
getPanBoundaries(){return{...this.panBoundaries};}
handleKeyDown(event){if(event.target.tagName==='INPUT'||event.target.tagName==='TEXTAREA'||event.target.contentEditable==='true'){return;}
if((event.ctrlKey||event.metaKey)&&(event.key==='+'||event.key==='=')){event.preventDefault();this.zoomIn();this.showKeyboardShortcutFeedback('Zoom In','Ctrl + +');}else if((event.ctrlKey||event.metaKey)&&event.key==='-'){event.preventDefault();this.zoomOut();this.showKeyboardShortcutFeedback('Zoom Out','Ctrl + -');}else if((event.ctrlKey||event.metaKey)&&event.key==='0'){event.preventDefault();this.resetView();this.showKeyboardShortcutFeedback('Reset View','Ctrl + 0');}else if((event.ctrlKey||event.metaKey)&&event.key==='f'){event.preventDefault();this.fitToView();this.showKeyboardShortcutFeedback('Fit to View','Ctrl + F');}
if((event.ctrlKey||event.metaKey)&&event.key==='z'&&!event.shiftKey){event.preventDefault();this.undoZoom();this.showKeyboardShortcutFeedback('Undo Zoom','Ctrl + Z');}else if((event.ctrlKey||event.metaKey)&&event.key==='z'&&event.shiftKey){event.preventDefault();this.redoZoom();this.showKeyboardShortcutFeedback('Redo Zoom','Ctrl + Shift + Z');}else if((event.ctrlKey||event.metaKey)&&event.key==='y'){event.preventDefault();this.redoZoom();this.showKeyboardShortcutFeedback('Redo Zoom','Ctrl + Y');}
if(event.key==='ArrowUp'||event.key==='ArrowDown'||event.key==='ArrowLeft'||event.key==='ArrowRight'){if(event.shiftKey){event.preventDefault();const panStep=50;let deltaX=0;let deltaY=0;switch(event.key){case'ArrowUp':deltaY=-panStep;break;case'ArrowDown':deltaY=panStep;break;case'ArrowLeft':deltaX=-panStep;break;case'ArrowRight':deltaX=panStep;break;}
this.panX+=deltaX;this.panY+=deltaY;this.queueViewportUpdate();this.saveZoomState();this.showKeyboardShortcutFeedback('Pan',`Shift + ${event.key}`);}}
if((event.ctrlKey||event.metaKey)&&event.key>='1'&&event.key<='9'){event.preventDefault();const zoomLevel=parseInt(event.key)/10;this.setZoom(zoomLevel);this.showKeyboardShortcutFeedback(`Zoom ${Math.round(zoomLevel * 100)}%`,`Ctrl + ${event.key}`);}
if(event.key==='p'&&!event.ctrlKey&&!event.metaKey){event.preventDefault();this.togglePan();const status=this.isPanEnabled()?'Enabled':'Disabled';this.showKeyboardShortcutFeedback(`Pan ${status}`,'P');}
if(event.key==='F1'||((event.ctrlKey||event.metaKey)&&event.key==='h')){event.preventDefault();this.toggleHelpOverlay();}
if(event.key==='Escape'){event.preventDefault();this.cancelOperations();}}
showKeyboardShortcutFeedback(action,shortcut){let feedbackElement=document.getElementById('keyboard-shortcut-feedback');if(!feedbackElement){feedbackElement=document.createElement('div');feedbackElement.id='keyboard-shortcut-feedback';feedbackElement.className='keyboard-shortcut-feedback';this.container.appendChild(feedbackElement);}
feedbackElement.innerHTML=`
            <div class="shortcut-action">${action}</div>
            <div class="shortcut-keys">${shortcut}</div>
        `;feedbackElement.classList.add('show');setTimeout(()=>{feedbackElement.classList.remove('show');},2000);}
toggleHelpOverlay(){let helpOverlay=document.getElementById('help-overlay');if(!helpOverlay){helpOverlay=this.createHelpOverlay();}
if(helpOverlay.classList.contains('show')){helpOverlay.classList.remove('show');}else{helpOverlay.classList.add('show');}}
createHelpOverlay(){const helpOverlay=document.createElement('div');helpOverlay.id='help-overlay';helpOverlay.className='help-overlay';const helpContent=document.createElement('div');helpContent.className='help-content';helpContent.innerHTML=`
            <div class="help-header">
                <h2>Keyboard Shortcuts</h2>
                <button class="help-close" onclick="this.closest('.help-overlay').classList.remove('show')">&times;</button>
            </div>
            <div class="help-grid">
                <div class="help-section">
                    <h3>Zoom Controls</h3>
                    <div class="space-y-1">
                        <div><kbd>Ctrl</kbd> + <kbd>+</kbd> Zoom In</div>
                        <div><kbd>Ctrl</kbd> + <kbd>-</kbd> Zoom Out</div>
                        <div><kbd>Ctrl</kbd> + <kbd>0</kbd> Reset View</div>
                        <div><kbd>Ctrl</kbd> + <kbd>F</kbd> Fit to View</div>
                        <div><kbd>Ctrl</kbd> + <kbd>1-9</kbd> Zoom Presets (10%-90%)</div>
                    </div>
                </div>
                <div class="help-section">
                    <h3>Pan Controls</h3>
                    <div class="space-y-1">
                        <div><kbd>Shift</kbd> + <kbd>↑↓←→</kbd> Pan View</div>
                        <div><kbd>P</kbd> Toggle Pan Mode</div>
                        <div><kbd>Middle Mouse</kbd> Drag to Pan</div>
                    </div>
                </div>
                <div class="help-section">
                    <h3>History</h3>
                    <div class="space-y-1">
                        <div><kbd>Ctrl</kbd> + <kbd>Z</kbd> Undo Zoom</div>
                        <div><kbd>Ctrl</kbd> + <kbd>Y</kbd> Redo Zoom</div>
                        <div><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd> Redo Zoom</div>
                    </div>
                </div>
                <div class="help-section">
                    <h3>General</h3>
                    <div class="space-y-1">
                        <div><kbd>F1</kbd> or <kbd>Ctrl</kbd> + <kbd>H</kbd> Show/Hide Help</div>
                        <div><kbd>Esc</kbd> Cancel Operations</div>
                    </div>
                </div>
            </div>
        `;helpOverlay.appendChild(helpContent);document.body.appendChild(helpOverlay);helpOverlay.addEventListener('click',(e)=>{if(e.target===helpOverlay){helpOverlay.classList.remove('show');}});return helpOverlay;}
cancelOperations(){this.stopPanInertia();if(this.isPanning){this.endPan();}
const helpOverlay=document.getElementById('help-overlay');if(helpOverlay&&helpOverlay.classList.contains('show')){helpOverlay.classList.remove('show');}
this.container.style.cursor='';this.container.classList.remove('panning');this.showKeyboardShortcutFeedback('Operations Cancelled','Esc');}
handleResize(){clearTimeout(this.resizeTimeout);this.resizeTimeout=setTimeout(()=>{this.updateViewport();},100);}
zoomIn(){this.zoomAtPoint(1+this.zoomStep);}
zoomOut(){this.zoomAtPoint(1-this.zoomStep);}
zoomAtPoint(zoomFactor,centerX=null,centerY=null,smooth=false){const newZoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.currentZoom*zoomFactor));if(Math.abs(newZoom-this.currentZoom)<0.001)return;const center=centerX!==null&&centerY!==null?this.screenToSVG(centerX,centerY):{x:this.container.clientWidth/2,y:this.container.clientHeight/2};const zoomRatio=newZoom/this.currentZoom;const newPanX=center.x-(center.x-this.panX)*zoomRatio;const newPanY=center.y-(center.y-this.panY)*zoomRatio;this.applyZoomWithConstraints(newZoom,newPanX,newPanY,smooth);if(this.throttledUpdateManager){this.throttledUpdateManager.queueUpdate('zoom',{zoom:this.currentZoom,zoomFactor:zoomFactor,centerX:center.x,centerY:center.y});}}
applyZoomWithConstraints(newZoom,newPanX,newPanY,smooth=false){const constrainedPan=this.applyPanBoundaries(newPanX,newPanY);this.currentZoom=newZoom;this.panX=constrainedPan.x;this.panY=constrainedPan.y;if(smooth){this.applySmoothZoom(newZoom,this.panX,this.panY);}else{if(this.throttledUpdateManager){this.throttledUpdateManager.queueUpdate('viewport',{zoom:this.currentZoom,panX:this.panX,panY:this.panY});}else{this.updateViewport();}}
this.saveZoomState();this.triggerEvent('zoomChanged',{zoom:this.currentZoom,panX:this.panX,panY:this.panY});}
applySmoothZoom(targetZoom,targetPanX,targetPanY){if(this.isAnimating)return;this.isAnimating=true;this.targetZoom=targetZoom;this.targetPanX=targetPanX;this.targetPanY=targetPanY;const startZoom=this.currentZoom;const startPanX=this.panX;const startPanY=this.panY;const startTime=performance.now();const duration=this.wheelZoomDuration;const animate=(currentTime)=>{if(!this.isAnimating)return;const elapsed=currentTime-startTime;const progress=Math.min(elapsed/duration,1);const easeProgress=this.easeInOutCubic(progress);this.currentZoom=startZoom+(targetZoom-startZoom)*easeProgress;this.panX=startPanX+(targetPanX-startPanX)*easeProgress;this.panY=startPanY+(targetPanY-startPanY)*easeProgress;if(this.throttledUpdateManager){this.throttledUpdateManager.queueUpdate('viewport',{zoom:this.currentZoom,panX:this.panX,panY:this.panY});}else{this.updateViewport();}
if(progress<1){requestAnimationFrame(animate);}else{this.isAnimating=false;this.targetZoom=null;this.targetPanX=null;this.targetPanY=null;}};requestAnimationFrame(animate);}
easeInOutCubic(t){return t<0.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;}
resetView(){this.currentZoom=1.0;this.panX=0;this.panY=0;this.updateViewport();this.saveZoomState();this.triggerEvent('viewReset');}
fitToView(){const objects=this.svg.querySelectorAll('[data-placed-symbol="true"], .bim-object');if(objects.length===0)return;let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;objects.forEach(obj=>{const bbox=obj.getBBox();minX=Math.min(minX,bbox.x);minY=Math.min(minY,bbox.y);maxX=Math.max(maxX,bbox.x+bbox.width);maxY=Math.max(maxY,bbox.y+bbox.height);});const padding=50;minX-=padding;minY-=padding;maxX+=padding;maxY+=padding;const containerRect=this.container.getBoundingClientRect();const scaleX=containerRect.width/(maxX-minX);const scaleY=containerRect.height/(maxY-minY);const scale=Math.min(scaleX,scaleY,this.maxZoom);const centerX=(minX+maxX)/2;const centerY=(minY+maxY)/2;this.currentZoom=scale;this.panX=containerRect.width/2-centerX*scale;this.panY=containerRect.height/2-centerY*scale;this.updateViewport();this.saveZoomState();this.triggerEvent('fitToView');}
screenToSVG(screenX,screenY){const pt=this.svg.createSVGPoint();pt.x=screenX;pt.y=screenY;const svgPoint=pt.matrixTransform(this.svg.getScreenCTM().inverse());return{x:svgPoint.x,y:svgPoint.y};}
svgToScreen(svgX,svgY){const pt=this.svg.createSVGPoint();pt.x=svgX;pt.y=svgY;const screenPoint=pt.matrixTransform(this.svg.getScreenCTM());return{x:screenPoint.x,y:screenPoint.y};}
getViewportTransform(){return{translateX:this.panX,translateY:this.panY,scale:this.currentZoom};}
updateViewport(){if(this.isUpdating)return;if(this.throttledUpdateManager){this.throttledUpdateManager.queueUpdate('viewport',{zoom:this.currentZoom,panX:this.panX,panY:this.panY});return;}
this.performViewportUpdate();}
performViewportUpdate(){this.isUpdating=true;try{const transform=`translate(${this.panX},${this.panY}) scale(${this.currentZoom})`;const viewport=this.svg.querySelector('#svg-viewport');if(viewport){viewport.setAttribute('transform',transform);}
this.updateZoomDisplay();this.updateZoomButtonStates();this.triggerEvent('viewportChanged',{zoom:this.currentZoom,panX:this.panX,panY:this.panY,transform:transform});}catch(error){console.error('Error updating viewport:',error);}finally{this.isUpdating=false;}}
updateZoomDisplay(){const zoomDisplay=document.getElementById('zoom-level');if(zoomDisplay){zoomDisplay.textContent=`${Math.round(this.currentZoom * 100)}%`;}}
saveZoomState(){const state={zoom:this.currentZoom,panX:this.panX,panY:this.panY,timestamp:Date.now()};this.zoomHistory=this.zoomHistory.slice(0,this.historyIndex+1);this.zoomHistory.push(state);this.historyIndex++;if(this.zoomHistory.length>this.maxHistorySize){this.zoomHistory.shift();this.historyIndex--;}}
undoZoom(){if(this.historyIndex>0){this.historyIndex--;const state=this.zoomHistory[this.historyIndex];this.restoreZoomState(state);}}
redoZoom(){if(this.historyIndex<this.zoomHistory.length-1){this.historyIndex++;const state=this.zoomHistory[this.historyIndex];this.restoreZoomState(state);}}
restoreZoomState(state){this.currentZoom=state.zoom;this.panX=state.panX;this.panY=state.panY;this.updateViewport();this.triggerEvent('zoomRestored',state);}
getZoom(){return this.currentZoom;}
setZoom(zoom){const newZoom=Math.max(this.minZoom,Math.min(this.maxZoom,zoom));if(newZoom!==this.currentZoom){this.currentZoom=newZoom;this.updateViewport();this.saveZoomState();}}
getPan(){return{x:this.panX,y:this.panY};}
setPan(x,y){this.panX=x;this.panY=y;this.updateViewport();this.triggerEvent('panChanged',{x:this.panX,y:this.panY});}
setScaleFactors(scaleX,scaleY,unit='pixels'){this.scaleFactors.x=scaleX;this.scaleFactors.y=scaleY;this.currentUnit=unit;this.triggerEvent('scaleFactorsChanged',{x:this.scaleFactors.x,y:this.scaleFactors.y,unit:this.currentUnit});if(window.arxLogger){window.arxLogger.info('ViewportManager: Scale factors updated',{component:'viewport_manager',scale_x:scaleX,scale_y:scaleY,unit:unit});}}
getScaleFactors(){return{x:this.scaleFactors.x,y:this.scaleFactors.y,unit:this.currentUnit};}
screenToRealWorld(screenX,screenY){const svgCoords=this.screenToSVG(screenX,screenY);return this.svgToRealWorld(svgCoords.x,svgCoords.y);}
realWorldToScreen(realWorldX,realWorldY){const svgCoords=this.realWorldToSVG(realWorldX,realWorldY);return this.svgToScreen(svgCoords.x,svgCoords.y);}
svgToRealWorld(svgX,svgY){return{x:svgX*this.scaleFactors.x,y:svgY*this.scaleFactors.y};}
realWorldToSVG(realWorldX,realWorldY){return{x:realWorldX/this.scaleFactors.x,y:realWorldY/this.scaleFactors.y};}
getRealWorldDistance(point1,point2){const dx=(point2.x-point1.x)*this.scaleFactors.x;const dy=(point2.y-point1.y)*this.scaleFactors.y;return Math.sqrt(dx*dx+dy*dy);}
getRealWorldArea(width,height){const realWidth=width*this.scaleFactors.x;const realHeight=height*this.scaleFactors.y;return realWidth*realHeight;}
isUniformScale(){const tolerance=0.01;return Math.abs(this.scaleFactors.x-this.scaleFactors.y)<tolerance;}
getScaleRatio(){if(this.isUniformScale()){const ratio=1/this.scaleFactors.x;return`1:${ratio.toFixed(2)}`;}else{const ratioX=1/this.scaleFactors.x;const ratioY=1/this.scaleFactors.y;return`X:1:${ratioX.toFixed(2)} Y:1:${ratioY.toFixed(2)}`;}}
addEventListener(event,handler){if(!this.eventHandlers.has(event)){this.eventHandlers.set(event,[]);}
this.eventHandlers.get(event).push(handler);}
removeEventListener(event,handler){if(this.eventHandlers.has(event)){const handlers=this.eventHandlers.get(event);const index=handlers.indexOf(handler);if(index>-1){handlers.splice(index,1);}}}
triggerEvent(event,data={}){if(this.eventHandlers.has(event)){this.eventHandlers.get(event).forEach(handler=>{try{handler(data);}catch(error){console.error(`Error in event handler for ${event}:`,error);}});}}
getViewportBounds(){const rect=this.container.getBoundingClientRect();const margin=this.cullingMargin;return{left:-this.panX/this.currentZoom-margin,top:-this.panY/this.currentZoom-margin,right:(-this.panX+rect.width)/this.currentZoom+margin,bottom:(-this.panY+rect.height)/this.currentZoom+margin,width:rect.width/this.currentZoom+(margin*2),height:rect.height/this.currentZoom+(margin*2)};}
getObjectBounds(object){const objectId=object.getAttribute('data-object-id')||object.id||object.dataset.placedSymbol;if(!objectId){return this.calculateObjectBounds(object);}
const cached=this.objectBoundsCache.get(objectId);if(cached&&Date.now()-cached.timestamp<this.boundsCacheExpiry){return cached.bounds;}
const bounds=this.calculateObjectBounds(object);this.objectBoundsCache.set(objectId,{bounds:bounds,timestamp:Date.now()});return bounds;}
calculateObjectBounds(object){try{const bbox=object.getBBox();const transform=object.transform.baseVal;let x=bbox.x;let y=bbox.y;let width=bbox.width;let height=bbox.height;if(transform.numberOfItems>0){const matrix=transform.consolidate().matrix;const points=[{x:bbox.x,y:bbox.y},{x:bbox.x+bbox.width,y:bbox.y},{x:bbox.x,y:bbox.y+bbox.height},{x:bbox.x+bbox.width,y:bbox.y+bbox.height}];const transformedPoints=points.map(point=>({x:matrix.a*point.x+matrix.c*point.y+matrix.e,y:matrix.b*point.x+matrix.d*point.y+matrix.f}));const minX=Math.min(...transformedPoints.map(p=>p.x));const maxX=Math.max(...transformedPoints.map(p=>p.x));const minY=Math.min(...transformedPoints.map(p=>p.y));const maxY=Math.max(...transformedPoints.map(p=>p.y));x=minX;y=minY;width=maxX-minX;height=maxY-minY;}
return{x,y,width,height};}catch(error){const rect=object.getBoundingClientRect();const svgPoint=this.svg.createSVGPoint();svgPoint.x=rect.left;svgPoint.y=rect.top;const transformed=svgPoint.matrixTransform(this.svg.getScreenCTM().inverse());return{x:transformed.x,y:transformed.y,width:rect.width/this.currentZoom,height:rect.height/this.currentZoom};}}
isObjectVisible(object){if(!this.cullingEnabled){return true;}
const viewportBounds=this.getViewportBounds();const objectBounds=this.getObjectBounds(object);return!(objectBounds.x+objectBounds.width<viewportBounds.left||objectBounds.x>viewportBounds.right||objectBounds.y+objectBounds.height<viewportBounds.top||objectBounds.y>viewportBounds.bottom);}
updateObjectVisibility(object){const isVisible=this.isObjectVisible(object);const wasVisible=!object.classList.contains('culled');if(isVisible!==wasVisible){if(isVisible){object.classList.remove('culled');object.style.display='';this.visibleObjects.add(object);}else{object.classList.add('culled');object.style.display='none';this.visibleObjects.delete(object);}}
return isVisible;}
performViewportCulling(){if(!this.cullingEnabled){return;}
const startTime=performance.now();const objects=this.svg.querySelectorAll('.placed-symbol, .bim-object, [data-placed-symbol="true"]');this.totalObjects=objects.length;this.visibleObjects.clear();let visibleCount=0;let culledCount=0;objects.forEach(object=>{const isVisible=this.updateObjectVisibility(object);if(isVisible){visibleCount++;}else{culledCount++;}});const cullingTime=performance.now()-startTime;this.cullingStats={totalObjects:this.totalObjects,visibleObjects:visibleCount,culledObjects:culledCount,cullingTime:cullingTime,lastUpdate:Date.now()};this.cleanupBoundsCache();this.triggerEvent('cullingUpdated',this.cullingStats);if(window.arxLogger){window.arxLogger.performance('viewport_culling',cullingTime,{component:'viewport_manager',visible_count:visibleCount,total_objects:this.totalObjects,culled_count:culledCount,culling_time_ms:cullingTime.toFixed(2)});}}
cleanupBoundsCache(){const now=Date.now();if(now-this.lastBoundsCacheCleanup<10000){return;}
this.lastBoundsCacheCleanup=now;let cleanedCount=0;for(const[id,entry]of this.objectBoundsCache.entries()){if(now-entry.timestamp>this.boundsCacheExpiry){this.objectBoundsCache.delete(id);cleanedCount++;}}
if(cleanedCount>0){if(window.arxLogger){window.arxLogger.info('ViewportCulling: Cleaned up expired bounds cache entries',{component:'viewport_manager',cleaned_count:cleanedCount,cache_type:'bounds_cache'});}}}
queueCullingUpdate(){if(!this.cullingEnabled)return;if(this.throttledUpdateManager){this.throttledUpdateManager.queueUpdate('culling',{viewportBounds:this.getViewportBounds(),totalObjects:this.totalObjects});}else{this.performViewportCulling();}}
enableCulling(){this.cullingEnabled=true;this.performViewportCulling();if(window.arxLogger){window.arxLogger.info('ViewportCulling: Enabled',{component:'viewport_manager',feature:'viewport_culling',status:'enabled'});}}
disableCulling(){this.cullingEnabled=false;const objects=this.svg.querySelectorAll('.culled');objects.forEach(object=>{object.classList.remove('culled');object.style.display='';});this.visibleObjects.clear();if(window.arxLogger){window.arxLogger.info('ViewportCulling: Disabled',{component:'viewport_manager',feature:'viewport_culling',status:'disabled'});}}
toggleCulling(){if(this.cullingEnabled){this.disableCulling();}else{this.enableCulling();}}
getCullingStats(){return{...this.cullingStats};}
setCullingMargin(margin){this.cullingMargin=margin;this.performViewportCulling();if(window.arxLogger){window.arxLogger.info('ViewportCulling: Margin set',{component:'viewport_manager',feature:'viewport_culling',margin_px:margin});}}
setCullingThrottle(throttle){this.cullingUpdateThrottle=throttle;if(window.arxLogger){window.arxLogger.info('ViewportCulling: Throttle set',{component:'viewport_manager',feature:'viewport_culling',throttle_ms:throttle});}}
forceCullingUpdate(){this.performViewportCulling();}
destroy(){this.stopPanInertia();if(this.cullingAnimationFrame){cancelAnimationFrame(this.cullingAnimationFrame);this.cullingAnimationFrame=null;}
this.visibleObjects.clear();this.objectBoundsCache.clear();this.container.removeEventListener('wheel',this.handleWheel);this.container.removeEventListener('mousedown',this.handleMouseDown);document.removeEventListener('mousemove',this.handleMouseMove);document.removeEventListener('mouseup',this.handleMouseUp);document.removeEventListener('keydown',this.handleKeyDown);window.removeEventListener('resize',this.handleResize);if(this.updateTimeout){clearTimeout(this.updateTimeout);this.updateTimeout=null;}
this.isPanning=false;this.panVelocityX=0;this.panVelocityY=0;this.lastPanTime=null;this.eventHandlers.clear();this.container.classList.remove('panning','zooming','pan-enabled');this.container.style.cursor='';const elementsToRemove=['zoom-constraint','pan-boundary-feedback','pan-inertia-indicator','pan-velocity-indicator','pan-mode-indicator','pan-boundary-warning','keyboard-shortcut-feedback','help-overlay'];elementsToRemove.forEach(id=>{const element=document.getElementById(id);if(element){element.remove();}});}
handleThrottledUpdate(data){const{type,data:updateData}=data;switch(type){case'viewport':this.updateViewport();break;case'zoom':this.updateZoomDisplay();this.updateZoomButtonStates();break;case'pan':this.updateViewport();break;case'culling':this.performViewportCulling();break;case'symbols':this.updateSymbolPositions();break;case'ui':this.updateUIElements();break;}}
handleBatchedUpdate(data){const{type,data:batchedData}=data;switch(type){case'viewport':this.updateViewport();break;case'symbols':this.updateSymbolPositionsBatch(batchedData.updates);break;case'culling':this.performViewportCulling();break;}}
handleUpdateProcessed(data){const{processedCount,currentFPS,frameTime,pendingUpdates}=data;this.updatePerformanceMetrics({processedUpdates:processedCount,currentFPS:currentFPS,frameTime:frameTime,pendingUpdates:pendingUpdates});this.triggerEvent('performanceUpdate',{processedUpdates:processedCount,currentFPS:currentFPS,frameTime:frameTime,pendingUpdates:pendingUpdates});}
updatePerformanceMetrics(metrics){this.performanceMetrics={...this.performanceMetrics,...metrics,lastUpdate:performance.now()};}
updateSymbolPositionsBatch(updates){if(!updates||updates.length===0)return;const symbols=document.querySelectorAll('.placed-symbol');symbols.forEach(symbol=>{const x=parseFloat(symbol.getAttribute('data-x'));const y=parseFloat(symbol.getAttribute('data-y'));const rotation=parseFloat(symbol.getAttribute('data-rotation')||'0');const transform=`translate(${x},${y}) rotate(${rotation})`;symbol.setAttribute('transform',transform);});}
updateUIElements(){this.updateZoomDisplay();this.updateZoomButtonStates();const zoomLevel=document.getElementById('zoom-level');if(zoomLevel){zoomLevel.textContent=`${(this.currentZoom * 100).toFixed(0)}%`;}}
getZoomPercent(){return Math.round(this.currentZoom*100);}
setZoomPercent(percent){const zoom=Math.max(this.minZoom,Math.min(this.maxZoom,percent/100));this.setZoom(zoom);}
getMinZoom(){return this.minZoom;}
getMaxZoom(){return this.maxZoom;}
zoomToFullExtent(){const svg=this.svg;if(!svg)return;let bbox;try{bbox=svg.getBBox();}catch(e){return;}
const containerRect=this.container.getBoundingClientRect();const scaleX=containerRect.width/bbox.width;const scaleY=containerRect.height/bbox.height;const scale=Math.min(scaleX,scaleY,this.maxZoom);const centerX=bbox.x+bbox.width/2;const centerY=bbox.y+bbox.height/2;this.currentZoom=scale;this.panX=containerRect.width/2-centerX*scale;this.panY=containerRect.height/2-centerY*scale;this.updateViewport();this.saveZoomState();this.triggerEvent('zoomToFullExtent');}
zoomToSelection(bbox){if(!bbox||bbox.width===0||bbox.height===0)return;const containerRect=this.container.getBoundingClientRect();const scaleX=containerRect.width/bbox.width;const scaleY=containerRect.height/bbox.height;const scale=Math.min(scaleX,scaleY,this.maxZoom);const centerX=bbox.x+bbox.width/2;const centerY=bbox.y+bbox.height/2;this.currentZoom=scale;this.panX=containerRect.width/2-centerX*scale;this.panY=containerRect.height/2-centerY*scale;this.updateViewport();this.saveZoomState();this.triggerEvent('zoomToSelection',bbox);}}
if(typeof module!=='undefined'&&module.exports){module.exports=ViewportManager;}else if(typeof window!=='undefined'){window.ViewportManager=ViewportManager;}
