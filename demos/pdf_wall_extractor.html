<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arxos - PDF Wall Extractor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src='https://unpkg.com/tesseract.js@4.0.0/dist/tesseract.min.js'></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f0f0f0;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 300px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .toolbar {
            background: white;
            padding: 10px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
            background: #f5f5f5;
        }
        
        .viewport:active {
            cursor: grabbing;
        }
        
        #upload-zone {
            border: 3px dashed #0066cc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        #upload-zone:hover {
            background: #f0f8ff;
            border-color: #0052a3;
        }
        
        #upload-zone.dragover {
            background: #e6f3ff;
            border-color: #004080;
        }
        
        #pdf-canvas, #processed-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #processed-canvas {
            pointer-events: none;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .slider {
            width: 100%;
            margin: 10px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
        }
        
        button {
            padding: 8px 16px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #0052a3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .stats {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
        }
        
        .processing-status {
            background: #fff3cd;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            display: none;
        }
        
        .processing-status.active {
            display: block;
        }
        
        #layers-control label {
            display: block;
            margin: 5px 0;
            cursor: pointer;
        }
        
        #layers-control input {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h2>PDF Wall Extractor</h2>
            
            <div id="upload-zone">
                <p>üìÑ Drop PDF here</p>
                <p style="font-size: 12px; margin-top: 10px;">or click to browse</p>
                <input type="file" id="file-input" accept=".pdf" style="display: none;">
            </div>
            
            <div class="processing-status" id="processing-status">
                <strong>Processing...</strong>
                <div id="status-message">Converting PDF to image...</div>
            </div>
            
            <div class="control-group">
                <h3>Detection Settings</h3>
                
                <div class="slider-label">
                    <span>Line Threshold</span>
                    <span id="threshold-value">50</span>
                </div>
                <input type="range" class="slider" id="threshold-slider" 
                       min="1" max="100" value="50">
                
                <div class="slider-label">
                    <span>Min Line Length</span>
                    <span id="min-length-value">20px</span>
                </div>
                <input type="range" class="slider" id="min-length-slider" 
                       min="5" max="100" value="20">
                
                <div class="slider-label">
                    <span>Line Gap</span>
                    <span id="line-gap-value">10px</span>
                </div>
                <input type="range" class="slider" id="line-gap-slider" 
                       min="1" max="50" value="10">
            </div>
            
            <div class="control-group">
                <h3>Display Layers</h3>
                <div id="layers-control">
                    <label><input type="checkbox" id="show-original" checked> Original PDF</label>
                    <label><input type="checkbox" id="show-walls" checked> Detected Walls</label>
                    <label><input type="checkbox" id="show-rooms" checked> Rooms</label>
                    <label><input type="checkbox" id="show-labels" checked> Labels</label>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Page Navigation</h3>
                <div style="display: flex; gap: 5px; align-items: center; margin-bottom: 10px;">
                    <button id="prev-page" disabled>‚Üê Prev</button>
                    <span id="page-info">Page 1 of 1</span>
                    <button id="next-page" disabled>Next ‚Üí</button>
                </div>
                <button id="auto-detect-page">üîç Auto-detect Floor Plan</button>
            </div>
            
            <div class="control-group">
                <button id="reprocess-btn" disabled>Reprocess</button>
                <button id="export-btn" disabled>Export ArxObjects</button>
            </div>
            
            <div class="stats">
                <h3>Statistics</h3>
                <div class="stat-item">
                    <span>Walls Detected:</span>
                    <span id="walls-count">0</span>
                </div>
                <div class="stat-item">
                    <span>Rooms Found:</span>
                    <span id="rooms-count">0</span>
                </div>
                <div class="stat-item">
                    <span>Labels Extracted:</span>
                    <span id="labels-count">0</span>
                </div>
            </div>
        </div>
        
        <div class="main">
            <div class="toolbar">
                <button id="zoom-in">üîç+</button>
                <button id="zoom-out">üîç-</button>
                <button id="zoom-fit">Fit</button>
                <button id="pan-btn">‚úã Pan</button>
                <span style="margin-left: auto; font-size: 14px;">
                    Scale: <span id="scale-display">100%</span>
                </span>
            </div>
            
            <div class="viewport" id="viewport">
                <canvas id="pdf-canvas"></canvas>
                <canvas id="processed-canvas"></canvas>
            </div>
        </div>
    </div>
    
    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        class PDFWallExtractor {
            constructor() {
                this.pdfDoc = null;
                this.pageNum = 1;
                this.baseScale = 2.0; // Base resolution
                this.currentRenderScale = 2.0; // Current render scale
                this.walls = [];
                this.rooms = [];
                this.labels = [];
                this.lastZoomUpdate = 0;
                
                this.setupEventListeners();
                this.setupCanvas();
            }
            
            setupCanvas() {
                this.pdfCanvas = document.getElementById('pdf-canvas');
                this.processedCanvas = document.getElementById('processed-canvas');
                this.pdfCtx = this.pdfCanvas.getContext('2d');
                this.processedCtx = this.processedCanvas.getContext('2d');
            }
            
            setupEventListeners() {
                const uploadZone = document.getElementById('upload-zone');
                const fileInput = document.getElementById('file-input');
                
                uploadZone.addEventListener('click', () => fileInput.click());
                
                uploadZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadZone.classList.add('dragover');
                });
                
                uploadZone.addEventListener('dragleave', () => {
                    uploadZone.classList.remove('dragover');
                });
                
                uploadZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadZone.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0 && files[0].type === 'application/pdf') {
                        this.loadPDF(files[0]);
                    }
                });
                
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadPDF(e.target.files[0]);
                    }
                });
                
                // Control sliders
                document.getElementById('threshold-slider').addEventListener('input', (e) => {
                    document.getElementById('threshold-value').textContent = e.target.value;
                });
                
                document.getElementById('min-length-slider').addEventListener('input', (e) => {
                    document.getElementById('min-length-value').textContent = e.target.value + 'px';
                });
                
                document.getElementById('line-gap-slider').addEventListener('input', (e) => {
                    document.getElementById('line-gap-value').textContent = e.target.value + 'px';
                });
                
                // Buttons
                document.getElementById('reprocess-btn').addEventListener('click', () => {
                    this.processImage();
                });
                
                document.getElementById('export-btn').addEventListener('click', () => {
                    this.exportArxObjects();
                });
                
                // Layer toggles
                document.getElementById('show-original').addEventListener('change', (e) => {
                    this.pdfCanvas.style.opacity = e.target.checked ? '1' : '0';
                });
                
                document.getElementById('show-walls').addEventListener('change', () => {
                    this.renderProcessed();
                });
                
                document.getElementById('show-rooms').addEventListener('change', () => {
                    this.renderProcessed();
                });
                
                document.getElementById('show-labels').addEventListener('change', () => {
                    this.renderProcessed();
                });
                
                // Viewport controls
                document.getElementById('zoom-in').addEventListener('click', () => {
                    this.zoomIn();
                });
                
                document.getElementById('zoom-out').addEventListener('click', () => {
                    this.zoomOut();
                });
                
                document.getElementById('zoom-fit').addEventListener('click', () => {
                    this.fitToScreen();
                });
                
                document.getElementById('pan-btn').addEventListener('click', () => {
                    this.togglePanMode();
                });
                
                // Pan and zoom with mouse
                this.setupViewportInteraction();
                
                // Page navigation
                document.getElementById('prev-page').addEventListener('click', () => {
                    if (this.pageNum > 1) {
                        this.pageNum--;
                        console.log(`Switching to page ${this.pageNum}`);
                        this.updatePageInfo();
                        this.renderPage().then(() => this.processImage());
                    }
                });
                
                document.getElementById('next-page').addEventListener('click', () => {
                    if (this.pageNum < this.pdfDoc.numPages) {
                        this.pageNum++;
                        console.log(`Switching to page ${this.pageNum}`);
                        this.updatePageInfo();
                        this.renderPage().then(() => this.processImage());
                    }
                });
                
                document.getElementById('auto-detect-page').addEventListener('click', () => {
                    console.log('Auto-detect clicked');
                    this.autoDetectFloorPlan();
                });
            }
            
            async loadPDF(file) {
                // Store the file for later upload
                this.pdfFile = file;
                
                const arrayBuffer = await file.arrayBuffer();
                
                this.showProcessingStatus('Loading PDF...');
                
                try {
                    this.pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                    this.updatePageInfo();
                    await this.renderPage();
                    
                    // Enable buttons
                    document.getElementById('reprocess-btn').disabled = false;
                    document.getElementById('export-btn').disabled = false;
                    document.getElementById('prev-page').disabled = false;
                    document.getElementById('next-page').disabled = false;
                    document.getElementById('auto-detect-page').disabled = false;
                    
                    // Process the image
                    setTimeout(() => this.processImage(), 100);
                    
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    alert('Failed to load PDF. Please try another file.');
                }
            }
            
            async renderPage(renderScale = null) {
                this.showProcessingStatus('Rendering PDF...');
                
                const page = await this.pdfDoc.getPage(this.pageNum);
                
                // Use provided scale or calculate based on current zoom
                const targetScale = renderScale || this.calculateOptimalRenderScale();
                this.currentRenderScale = targetScale;
                
                const viewport = page.getViewport({ scale: targetScale });
                
                // Set canvas dimensions
                this.pdfCanvas.width = viewport.width;
                this.pdfCanvas.height = viewport.height;
                this.processedCanvas.width = viewport.width;
                this.processedCanvas.height = viewport.height;
                
                // Render PDF page
                await page.render({
                    canvasContext: this.pdfCtx,
                    viewport: viewport
                }).promise;
                
                // Reset transform since we re-rendered at higher resolution
                if (renderScale) {
                    this.adjustTransformForNewScale(targetScale);
                }
                
                this.hideProcessingStatus();
            }
            
            calculateOptimalRenderScale() {
                // Calculate what scale we need based on current zoom level
                const minScale = this.baseScale || 2.0; // Start with at least 2x for clarity
                const maxScale = 10.0; // Maximum 10x resolution for very high zoom
                
                // Current zoom factor
                const zoomFactor = this.currentScale || 1;
                
                // Always render at a scale that provides sharp details
                // Use a more aggressive scaling to ensure crisp rendering
                let targetScale = minScale * Math.max(1, zoomFactor);
                
                // Cap at maximum to prevent memory issues
                targetScale = Math.min(maxScale, targetScale);
                
                // Ensure we never go below the minimum for quality
                targetScale = Math.max(minScale, targetScale);
                
                console.log(`Zoom: ${zoomFactor.toFixed(2)}x, Render scale: ${targetScale.toFixed(2)}x`);
                
                return targetScale;
            }
            
            adjustTransformForNewScale(newScale) {
                // Adjust transform to account for the new canvas resolution
                const scaleRatio = newScale / this.baseScale;
                
                // Update current transform to compensate
                if (this.currentTranslate && this.currentScale) {
                    this.currentTranslate.x *= scaleRatio;
                    this.currentTranslate.y *= scaleRatio;
                    this.currentScale /= scaleRatio;
                    this.updateTransform();
                }
            }
            
            async processImage() {
                this.processingStartTime = Date.now();
                this.showProcessingStatus('Detecting walls...');
                
                // Get image data from canvas
                const imageData = this.pdfCtx.getImageData(
                    0, 0, this.pdfCanvas.width, this.pdfCanvas.height
                );
                
                // Detect walls using edge detection
                this.walls = this.detectWalls(imageData);
                
                this.showProcessingStatus('Finding rooms...');
                
                // Find rooms from walls
                this.rooms = this.findRooms(this.walls);
                
                this.showProcessingStatus('Extracting labels with OCR...');
                
                // Extract text labels using Tesseract OCR
                this.labels = await this.extractLabels(imageData);
                
                // Update statistics
                this.updateStats();
                
                // Render results
                this.renderProcessed();
                
                this.hideProcessingStatus();
            }
            
            detectWalls(imageData) {
                const walls = [];
                const width = imageData.width;
                const height = imageData.height;
                const data = imageData.data;
                
                // Convert to grayscale with better contrast
                const gray = new Uint8ClampedArray(width * height);
                for (let i = 0; i < data.length; i += 4) {
                    const idx = i / 4;
                    // Check if pixel is dark enough to be a wall
                    const luminance = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                    gray[idx] = luminance;
                }
                
                // Apply adaptive thresholding for better wall detection
                const binary = this.adaptiveThreshold(gray, width, height);
                
                // Morphological operations to clean up the image
                const cleaned = this.morphologicalClean(binary, width, height);
                
                // Enhanced edge detection
                const edges = this.cannyEdgeDetection(cleaned, width, height);
                
                // Improved Hough transform
                const threshold = parseInt(document.getElementById('threshold-slider').value);
                const minLength = parseInt(document.getElementById('min-length-slider').value) * this.scale;
                const lineGap = parseInt(document.getElementById('line-gap-slider').value);
                
                const lines = this.improvedHoughTransform(edges, width, height, threshold, minLength, lineGap);
                
                // Merge and clean up lines
                const mergedLines = this.mergeCollinearLines(lines, lineGap);
                
                // Filter lines to get only walls
                const filteredLines = this.filterWalls(mergedLines, binary, width, height);
                
                // Convert lines to wall objects with better classification
                filteredLines.forEach(line => {
                    const thickness = this.estimateThickness(binary, line, width);
                    
                    // Only add if thickness suggests it's a wall (not text or thin lines)
                    if (thickness >= 1.5 && thickness <= 20) {
                        walls.push({
                            startX: line.x1,
                            startY: line.y1,
                            endX: line.x2,
                            endY: line.y2,
                            thickness: thickness,
                            type: this.classifyWall(line, width, height)
                        });
                    }
                });
                
                // Remove duplicate walls
                return this.removeDuplicateWalls(walls);
            }
            
            sobelEdgeDetection(gray, width, height) {
                const edges = new Uint8ClampedArray(width * height);
                
                const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
                const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let pixelX = 0;
                        let pixelY = 0;
                        
                        for (let j = -1; j <= 1; j++) {
                            for (let i = -1; i <= 1; i++) {
                                const idx = (y + j) * width + (x + i);
                                const kernelIdx = (j + 1) * 3 + (i + 1);
                                
                                pixelX += gray[idx] * sobelX[kernelIdx];
                                pixelY += gray[idx] * sobelY[kernelIdx];
                            }
                        }
                        
                        const magnitude = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
                        edges[y * width + x] = Math.min(255, magnitude);
                    }
                }
                
                return edges;
            }
            
            adaptiveThreshold(gray, width, height) {
                const binary = new Uint8ClampedArray(width * height);
                const blockSize = 25;
                const C = 10;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // Calculate local mean
                        let sum = 0;
                        let count = 0;
                        
                        for (let dy = -blockSize; dy <= blockSize; dy++) {
                            for (let dx = -blockSize; dx <= blockSize; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;
                                
                                if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                    sum += gray[ny * width + nx];
                                    count++;
                                }
                            }
                        }
                        
                        const mean = sum / count;
                        const idx = y * width + x;
                        binary[idx] = gray[idx] < (mean - C) ? 255 : 0;
                    }
                }
                
                return binary;
            }
            
            morphologicalClean(binary, width, height) {
                // Erosion followed by dilation (opening) to remove noise
                const result = new Uint8ClampedArray(width * height);
                const kernel = 2;
                
                // First pass: erosion
                for (let y = kernel; y < height - kernel; y++) {
                    for (let x = kernel; x < width - kernel; x++) {
                        let min = 255;
                        for (let dy = -kernel; dy <= kernel; dy++) {
                            for (let dx = -kernel; dx <= kernel; dx++) {
                                const idx = (y + dy) * width + (x + dx);
                                if (binary[idx] < min) min = binary[idx];
                            }
                        }
                        result[y * width + x] = min;
                    }
                }
                
                // Second pass: dilation
                const final = new Uint8ClampedArray(width * height);
                for (let y = kernel; y < height - kernel; y++) {
                    for (let x = kernel; x < width - kernel; x++) {
                        let max = 0;
                        for (let dy = -kernel; dy <= kernel; dy++) {
                            for (let dx = -kernel; dx <= kernel; dx++) {
                                const idx = (y + dy) * width + (x + dx);
                                if (result[idx] > max) max = result[idx];
                            }
                        }
                        final[y * width + x] = max;
                    }
                }
                
                return final;
            }
            
            cannyEdgeDetection(binary, width, height) {
                // Simplified Canny edge detection
                const edges = new Uint8ClampedArray(width * height);
                
                // Apply Sobel operators
                const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
                const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
                
                const gradientMag = new Float32Array(width * height);
                const gradientDir = new Float32Array(width * height);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let gx = 0, gy = 0;
                        
                        for (let j = -1; j <= 1; j++) {
                            for (let i = -1; i <= 1; i++) {
                                const idx = (y + j) * width + (x + i);
                                const kernelIdx = (j + 1) * 3 + (i + 1);
                                gx += binary[idx] * sobelX[kernelIdx];
                                gy += binary[idx] * sobelY[kernelIdx];
                            }
                        }
                        
                        const idx = y * width + x;
                        gradientMag[idx] = Math.sqrt(gx * gx + gy * gy);
                        gradientDir[idx] = Math.atan2(gy, gx);
                    }
                }
                
                // Non-maximum suppression
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        const angle = gradientDir[idx];
                        const mag = gradientMag[idx];
                        
                        // Determine direction
                        let dx = 0, dy = 0;
                        const absAngle = Math.abs(angle);
                        if (absAngle < Math.PI / 8 || absAngle > 7 * Math.PI / 8) {
                            dx = 1; dy = 0; // Horizontal
                        } else if (absAngle < 3 * Math.PI / 8) {
                            dx = 1; dy = angle > 0 ? 1 : -1; // Diagonal
                        } else if (absAngle < 5 * Math.PI / 8) {
                            dx = 0; dy = 1; // Vertical
                        } else {
                            dx = 1; dy = angle > 0 ? -1 : 1; // Other diagonal
                        }
                        
                        const idx1 = (y + dy) * width + (x + dx);
                        const idx2 = (y - dy) * width + (x - dx);
                        
                        if (mag > gradientMag[idx1] && mag > gradientMag[idx2]) {
                            edges[idx] = mag > 50 ? 255 : 0;
                        }
                    }
                }
                
                return edges;
            }
            
            improvedHoughTransform(edges, width, height, threshold, minLength, lineGap) {
                const lines = [];
                const rhoResolution = 1;
                const thetaResolution = Math.PI / 180;
                const maxRho = Math.sqrt(width * width + height * height);
                
                // Accumulator array
                const accumulator = {};
                
                // Vote for lines
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (edges[y * width + x] > 0) {
                            // Try different angles
                            for (let theta = 0; theta < Math.PI; theta += thetaResolution) {
                                const rho = x * Math.cos(theta) + y * Math.sin(theta);
                                const key = `${Math.round(rho)}_${Math.round(theta * 180 / Math.PI)}`;
                                accumulator[key] = (accumulator[key] || 0) + 1;
                            }
                        }
                    }
                }
                
                // Find peaks in accumulator
                const peaks = [];
                for (const key in accumulator) {
                    if (accumulator[key] > threshold) {
                        const [rho, thetaDeg] = key.split('_').map(Number);
                        const theta = thetaDeg * Math.PI / 180;
                        peaks.push({ rho, theta, votes: accumulator[key] });
                    }
                }
                
                // Sort by votes
                peaks.sort((a, b) => b.votes - a.votes);
                
                // Convert peaks to line segments
                peaks.slice(0, 100).forEach(peak => {
                    const { rho, theta } = peak;
                    const cosTheta = Math.cos(theta);
                    const sinTheta = Math.sin(theta);
                    
                    // Find line segments along this infinite line
                    const segments = [];
                    let inSegment = false;
                    let segmentStart = null;
                    
                    if (Math.abs(cosTheta) > 0.5) {
                        // More horizontal
                        for (let x = 0; x < width; x++) {
                            const y = Math.round((rho - x * cosTheta) / sinTheta);
                            if (y >= 0 && y < height && edges[y * width + x] > 0) {
                                if (!inSegment) {
                                    segmentStart = { x, y };
                                    inSegment = true;
                                }
                            } else if (inSegment) {
                                const segmentEnd = { x: x - 1, y: Math.round((rho - (x - 1) * cosTheta) / sinTheta) };
                                const length = Math.sqrt(Math.pow(segmentEnd.x - segmentStart.x, 2) + Math.pow(segmentEnd.y - segmentStart.y, 2));
                                if (length >= minLength) {
                                    lines.push({
                                        x1: segmentStart.x,
                                        y1: segmentStart.y,
                                        x2: segmentEnd.x,
                                        y2: segmentEnd.y
                                    });
                                }
                                inSegment = false;
                            }
                        }
                    } else {
                        // More vertical
                        for (let y = 0; y < height; y++) {
                            const x = Math.round((rho - y * sinTheta) / cosTheta);
                            if (x >= 0 && x < width && edges[y * width + x] > 0) {
                                if (!inSegment) {
                                    segmentStart = { x, y };
                                    inSegment = true;
                                }
                            } else if (inSegment) {
                                const segmentEnd = { x: Math.round((rho - (y - 1) * sinTheta) / cosTheta), y: y - 1 };
                                const length = Math.sqrt(Math.pow(segmentEnd.x - segmentStart.x, 2) + Math.pow(segmentEnd.y - segmentStart.y, 2));
                                if (length >= minLength) {
                                    lines.push({
                                        x1: segmentStart.x,
                                        y1: segmentStart.y,
                                        x2: segmentEnd.x,
                                        y2: segmentEnd.y
                                    });
                                }
                                inSegment = false;
                            }
                        }
                    }
                });
                
                return lines;
            }
            
            mergeCollinearLines(lines, maxGap) {
                const merged = [];
                const used = new Array(lines.length).fill(false);
                
                for (let i = 0; i < lines.length; i++) {
                    if (used[i]) continue;
                    
                    let line1 = lines[i];
                    let extended = true;
                    
                    while (extended) {
                        extended = false;
                        
                        for (let j = 0; j < lines.length; j++) {
                            if (i === j || used[j]) continue;
                            
                            const line2 = lines[j];
                            
                            // Check if lines are collinear and close
                            if (this.areCollinear(line1, line2) && this.distance(line1, line2) < maxGap) {
                                // Merge lines
                                const points = [
                                    { x: line1.x1, y: line1.y1 },
                                    { x: line1.x2, y: line1.y2 },
                                    { x: line2.x1, y: line2.y1 },
                                    { x: line2.x2, y: line2.y2 }
                                ];
                                
                                // Find extreme points
                                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                                points.forEach(p => {
                                    if (p.x < minX) minX = p.x;
                                    if (p.x > maxX) maxX = p.x;
                                    if (p.y < minY) minY = p.y;
                                    if (p.y > maxY) maxY = p.y;
                                });
                                
                                // Update line1 with merged coordinates
                                if (Math.abs(maxX - minX) > Math.abs(maxY - minY)) {
                                    line1 = { x1: minX, y1: points.find(p => p.x === minX).y, x2: maxX, y2: points.find(p => p.x === maxX).y };
                                } else {
                                    line1 = { x1: points.find(p => p.y === minY).x, y1: minY, x2: points.find(p => p.y === maxY).x, y2: maxY };
                                }
                                
                                used[j] = true;
                                extended = true;
                            }
                        }
                    }
                    
                    merged.push(line1);
                    used[i] = true;
                }
                
                return merged;
            }
            
            areCollinear(line1, line2) {
                const angle1 = Math.atan2(line1.y2 - line1.y1, line1.x2 - line1.x1);
                const angle2 = Math.atan2(line2.y2 - line2.y1, line2.x2 - line2.x1);
                
                let diff = Math.abs(angle1 - angle2);
                if (diff > Math.PI) diff = 2 * Math.PI - diff;
                
                return diff < 0.1 || Math.abs(diff - Math.PI) < 0.1; // Within ~5 degrees
            }
            
            distance(line1, line2) {
                // Minimum distance between endpoints
                const distances = [
                    Math.sqrt(Math.pow(line1.x1 - line2.x1, 2) + Math.pow(line1.y1 - line2.y1, 2)),
                    Math.sqrt(Math.pow(line1.x1 - line2.x2, 2) + Math.pow(line1.y1 - line2.y2, 2)),
                    Math.sqrt(Math.pow(line1.x2 - line2.x1, 2) + Math.pow(line1.y2 - line2.y1, 2)),
                    Math.sqrt(Math.pow(line1.x2 - line2.x2, 2) + Math.pow(line1.y2 - line2.y2, 2))
                ];
                
                return Math.min(...distances);
            }
            
            estimateThickness(binary, line, width) {
                // Sample perpendicular to the line to estimate wall thickness
                const dx = line.x2 - line.x1;
                const dy = line.y2 - line.y1;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length === 0) return 2;
                
                // Perpendicular direction
                const perpX = -dy / length;
                const perpY = dx / length;
                
                // Sample at multiple points along the line
                let totalThickness = 0;
                let samples = 0;
                
                for (let t = 0.2; t <= 0.8; t += 0.2) {
                    const x = line.x1 + t * dx;
                    const y = line.y1 + t * dy;
                    
                    let thickness = 0;
                    for (let d = -20; d <= 20; d++) {
                        const sx = Math.round(x + d * perpX);
                        const sy = Math.round(y + d * perpY);
                        
                        if (sx >= 0 && sx < width && sy >= 0 && sy < binary.length / width) {
                            if (binary[sy * width + sx] > 128) {
                                thickness++;
                            }
                        }
                    }
                    
                    if (thickness > 0) {
                        totalThickness += thickness;
                        samples++;
                    }
                }
                
                return samples > 0 ? Math.max(2, totalThickness / samples) : 2;
            }
            
            filterWalls(lines, binary, width, height) {
                return lines.filter(line => {
                    // Calculate line length
                    const length = Math.sqrt(
                        Math.pow(line.x2 - line.x1, 2) + Math.pow(line.y2 - line.y1, 2)
                    );
                    
                    // Skip very short lines (likely text or noise)
                    if (length < 20) return false;
                    
                    // Check if line is mostly horizontal or vertical (walls typically are)
                    const angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
                    const angleDeg = Math.abs(angle * 180 / Math.PI);
                    const isAligned = angleDeg < 15 || angleDeg > 75 && angleDeg < 105 || angleDeg > 165;
                    
                    if (!isAligned) return false;
                    
                    // Check density of black pixels along the line
                    const samples = Math.min(50, Math.floor(length));
                    let blackPixels = 0;
                    
                    for (let i = 0; i < samples; i++) {
                        const t = i / (samples - 1);
                        const x = Math.round(line.x1 + t * (line.x2 - line.x1));
                        const y = Math.round(line.y1 + t * (line.y2 - line.y1));
                        
                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            if (binary[y * width + x] > 128) {
                                blackPixels++;
                            }
                        }
                    }
                    
                    // Wall should have high density of black pixels
                    const density = blackPixels / samples;
                    return density > 0.3;
                });
            }
            
            removeDuplicateWalls(walls) {
                const filtered = [];
                const threshold = 10; // pixels
                
                for (let i = 0; i < walls.length; i++) {
                    const wall1 = walls[i];
                    let isDuplicate = false;
                    
                    for (let j = 0; j < filtered.length; j++) {
                        const wall2 = filtered[j];
                        
                        // Check if walls are very close
                        const dist1 = Math.sqrt(
                            Math.pow(wall1.startX - wall2.startX, 2) + Math.pow(wall1.startY - wall2.startY, 2)
                        );
                        const dist2 = Math.sqrt(
                            Math.pow(wall1.endX - wall2.endX, 2) + Math.pow(wall1.endY - wall2.endY, 2)
                        );
                        
                        if (dist1 < threshold && dist2 < threshold) {
                            isDuplicate = true;
                            break;
                        }
                    }
                    
                    if (!isDuplicate) {
                        filtered.push(wall1);
                    }
                }
                
                return filtered;
            }
            
            houghTransform(edges, width, height, threshold, minLength, lineGap) {
                // Keep old method as fallback
                return this.improvedHoughTransform(edges, width, height, threshold, minLength, lineGap);
            }
            
            classifyWall(line, width, height) {
                const margin = 50;
                
                if (line.x1 < margin || line.x2 < margin ||
                    line.y1 < margin || line.y2 < margin ||
                    line.x1 > width - margin || line.x2 > width - margin ||
                    line.y1 > height - margin || line.y2 > height - margin) {
                    return 'exterior';
                }
                
                return 'interior';
            }
            
            findRooms(walls) {
                const rooms = [];
                
                // Simplified room detection
                // Find rectangles formed by walls
                // In production, use proper polygon detection
                
                return rooms;
            }
            
            async extractLabels(imageData) {
                const labels = [];
                
                try {
                    // Convert ImageData to canvas for Tesseract
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = imageData.width;
                    tempCanvas.height = imageData.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(imageData, 0, 0);
                    
                    // Run OCR with Tesseract.js
                    const result = await Tesseract.recognize(
                        tempCanvas,
                        'eng',
                        {
                            logger: m => {
                                if (m.status === 'recognizing text') {
                                    this.showProcessingStatus(`OCR Progress: ${Math.round(m.progress * 100)}%`);
                                }
                            }
                        }
                    );
                    
                    // Parse room numbers and labels from OCR results
                    const lines = result.data.lines;
                    for (const line of lines) {
                        const text = line.text.trim();
                        
                        // Pattern matching for room numbers
                        const roomNumberPattern = /^[A-Z]*[-]?\d{2,4}[A-Z]?$|^(IDF|MDF|ELEC|MECH)[-]?\d*$/;
                        const isRoomNumber = roomNumberPattern.test(text);
                        
                        if (text.length > 0 && text.length < 20) {
                            labels.push({
                                text: text,
                                type: isRoomNumber ? 'room_number' : 'label',
                                confidence: line.confidence,
                                bbox: line.bbox,
                                x: line.bbox.x0,
                                y: line.bbox.y0
                            });
                        }
                    }
                    
                    console.log(`Extracted ${labels.length} text labels via OCR`);
                } catch (error) {
                    console.warn('OCR extraction failed, continuing without labels:', error);
                }
                
                return labels;
            }
            
            renderProcessed() {
                const ctx = this.processedCtx;
                ctx.clearRect(0, 0, this.processedCanvas.width, this.processedCanvas.height);
                
                // Render walls
                if (document.getElementById('show-walls').checked) {
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 2;
                    
                    this.walls.forEach(wall => {
                        ctx.beginPath();
                        ctx.moveTo(wall.startX, wall.startY);
                        ctx.lineTo(wall.endX, wall.endY);
                        ctx.stroke();
                    });
                }
                
                // Render rooms
                if (document.getElementById('show-rooms').checked) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 1;
                    
                    this.rooms.forEach(room => {
                        if (room.polygon && room.polygon.length > 0) {
                            ctx.beginPath();
                            ctx.moveTo(room.polygon[0].x, room.polygon[0].y);
                            room.polygon.forEach(point => {
                                ctx.lineTo(point.x, point.y);
                            });
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        }
                    });
                }
                
                // Render labels
                if (document.getElementById('show-labels').checked) {
                    ctx.fillStyle = '#0000FF';
                    ctx.font = '12px Arial';
                    
                    this.labels.forEach(label => {
                        ctx.fillText(label.text, label.x, label.y);
                    });
                }
            }
            
            updateStats() {
                document.getElementById('walls-count').textContent = this.walls.length;
                document.getElementById('rooms-count').textContent = this.rooms.length;
                document.getElementById('labels-count').textContent = this.labels.length;
            }
            
            exportArxObjects() {
                const arxObjects = [];
                const timestamp = new Date().toISOString();
                const pdfDimensions = {
                    width: this.pdfCanvas.width,
                    height: this.pdfCanvas.height,
                    scale: this.scale
                };
                
                // Convert walls to ArxObjects with proper coordinate system
                this.walls.forEach((wall, index) => {
                    const wallId = `wall_${index.toString().padStart(4, '0')}`;
                    
                    // Convert pixel coordinates to normalized coordinates (0-1)
                    const normalizedCoords = {
                        startX: wall.startX / pdfDimensions.width,
                        startY: wall.startY / pdfDimensions.height,
                        endX: wall.endX / pdfDimensions.width,
                        endY: wall.endY / pdfDimensions.height
                    };
                    
                    arxObjects.push({
                        uuid: this.generateUUID(),
                        id: wallId,
                        type: 'wall',
                        system: 'structural',
                        geometry: {
                            type: 'LineString',
                            coordinates: [
                                [normalizedCoords.startX, normalizedCoords.startY, 0],
                                [normalizedCoords.endX, normalizedCoords.endY, 0]
                            ],
                            pixelCoordinates: {
                                start: [wall.startX, wall.startY],
                                end: [wall.endX, wall.endY]
                            }
                        },
                        properties: {
                            thickness: wall.thickness,
                            wallType: wall.type,
                            length: this.calculateDistance(wall.startX, wall.startY, wall.endX, wall.endY),
                            angle: this.calculateAngle(wall.startX, wall.startY, wall.endX, wall.endY),
                            material: 'unknown',
                            loadBearing: 'unknown'
                        },
                        metadata: {
                            extractedFrom: 'PDF',
                            extractionMethod: 'computer_vision',
                            confidence: this.calculateWallConfidence(wall),
                            timestamp: timestamp,
                            pageNumber: this.pageNum,
                            sourceDimensions: pdfDimensions
                        }
                    });
                });
                
                // Detect and convert rooms from walls
                const detectedRooms = this.detectRoomsFromWalls(this.walls);
                detectedRooms.forEach((room, index) => {
                    const roomId = `room_${index.toString().padStart(4, '0')}`;
                    
                    arxObjects.push({
                        uuid: this.generateUUID(),
                        id: roomId,
                        type: 'room',
                        system: 'spatial',
                        geometry: {
                            type: 'Polygon',
                            coordinates: [room.boundary.map(point => [
                                point.x / pdfDimensions.width,
                                point.y / pdfDimensions.height,
                                0
                            ])],
                            pixelCoordinates: room.boundary
                        },
                        properties: {
                            area: room.area,
                            perimeter: room.perimeter,
                            label: room.label || `Room ${index + 1}`,
                            roomNumber: room.roomNumber || null,
                            roomType: room.type || 'unknown',
                            occupancy: 'unknown'
                        },
                        metadata: {
                            extractedFrom: 'PDF',
                            extractionMethod: 'wall_boundary_detection',
                            confidence: room.confidence || 0.7,
                            timestamp: timestamp,
                            pageNumber: this.pageNum,
                            sourceDimensions: pdfDimensions
                        }
                    });
                });
                
                // Add building metadata
                const buildingMetadata = {
                    uuid: this.generateUUID(),
                    id: 'building_main',
                    type: 'building',
                    system: 'structural',
                    properties: {
                        totalWalls: this.walls.length,
                        totalRooms: detectedRooms.length,
                        buildingType: 'educational', // Could be detected from context
                        floorLevel: 1 // Could be extracted from labels
                    },
                    metadata: {
                        extractedFrom: 'PDF',
                        extractionMethod: 'automated_analysis',
                        timestamp: timestamp,
                        pageNumber: this.pageNum,
                        sourceDimensions: pdfDimensions,
                        processingSettings: {
                            threshold: parseInt(document.getElementById('threshold-slider').value),
                            minLength: parseInt(document.getElementById('min-length-slider').value),
                            lineGap: parseInt(document.getElementById('line-gap-slider').value)
                        }
                    }
                };
                
                arxObjects.unshift(buildingMetadata);
                
                // Create comprehensive export
                const exportData = {
                    arxos: {
                        version: '1.0',
                        timestamp: timestamp,
                        source: {
                            type: 'PDF',
                            pageNumber: this.pageNum,
                            dimensions: pdfDimensions
                        },
                        statistics: {
                            totalObjects: arxObjects.length,
                            walls: this.walls.length,
                            rooms: detectedRooms.length,
                            processingTime: Date.now() - this.processingStartTime
                        },
                        objects: arxObjects
                    }
                };
                
                // Try to upload to backend first
                this.uploadToBackend(exportData).then(response => {
                    if (response && response.success) {
                        alert(`Successfully uploaded ${arxObjects.length} objects to building ${response.building_id}`);
                        console.log('Upload successful:', response);
                    }
                }).catch(error => {
                    console.warn('Backend upload failed, saving locally:', error);
                    // Fallback to local download
                    const filename = `arxobjects_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], 
                        { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    console.log('Exported ArxObjects locally:', exportData);
                    alert(`Exported ${arxObjects.length} objects to ${filename}`);
                });
            }
            
            async uploadToBackend(exportData) {
                // Create FormData for multipart upload
                const formData = new FormData();
                
                // Add the PDF file if available
                if (this.pdfFile) {
                    formData.append('pdf', this.pdfFile);
                }
                
                // Add metadata
                formData.append('building_name', 'Uploaded Building');
                formData.append('floor', '1');
                formData.append('coordinate_system', 'normalized');
                formData.append('width_meters', '100'); // Default 100m width
                formData.append('height_meters', '100'); // Default 100m height
                
                // Add the extracted objects as JSON
                formData.append('arxobjects', JSON.stringify(exportData));
                
                try {
                    const response = await fetch('/api/buildings/upload', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    return result;
                } catch (error) {
                    console.error('Upload failed:', error);
                    throw error;
                }
            }
            
            showProcessingStatus(message) {
                const status = document.getElementById('processing-status');
                const statusMessage = document.getElementById('status-message');
                status.classList.add('active');
                statusMessage.textContent = message;
            }
            
            hideProcessingStatus() {
                document.getElementById('processing-status').classList.remove('active');
            }
            
            setupViewportInteraction() {
                const viewport = document.getElementById('viewport');
                let isPanning = false;
                let startPoint = { x: 0, y: 0 };
                let currentScale = 1;
                let currentTranslate = { x: 0, y: 0 };
                
                // Mouse events for panning
                viewport.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        isPanning = true;
                        startPoint = { x: e.clientX, y: e.clientY };
                        viewport.style.cursor = 'grabbing';
                    }
                });
                
                viewport.addEventListener('mousemove', (e) => {
                    if (isPanning) {
                        const dx = e.clientX - startPoint.x;
                        const dy = e.clientY - startPoint.y;
                        
                        currentTranslate.x += dx;
                        currentTranslate.y += dy;
                        
                        this.updateTransform();
                        
                        startPoint = { x: e.clientX, y: e.clientY };
                    }
                });
                
                viewport.addEventListener('mouseup', () => {
                    isPanning = false;
                    viewport.style.cursor = 'grab';
                });
                
                viewport.addEventListener('mouseleave', () => {
                    isPanning = false;
                    viewport.style.cursor = 'grab';
                });
                
                // Wheel events for zooming
                viewport.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const rect = viewport.getBoundingClientRect();
                    
                    // Get mouse position relative to viewport
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Calculate the point in the canvas coordinate system
                    const canvasX = (mouseX - currentTranslate.x) / currentScale;
                    const canvasY = (mouseY - currentTranslate.y) / currentScale;
                    
                    // Apply zoom
                    const newScale = currentScale * zoomFactor;
                    
                    // Adjust translation to keep the mouse point fixed
                    currentTranslate.x = mouseX - canvasX * newScale;
                    currentTranslate.y = mouseY - canvasY * newScale;
                    currentScale = newScale;
                    
                    this.updateTransform();
                    this.updateScaleDisplay();
                    
                    // Check if we need to re-render at higher resolution
                    this.checkForRerender();
                });
                
                this.currentScale = currentScale;
                this.currentTranslate = currentTranslate;
            }
            
            updateTransform() {
                const transform = `translate(${this.currentTranslate.x}px, ${this.currentTranslate.y}px) scale(${this.currentScale})`;
                this.pdfCanvas.style.transform = transform;
                this.processedCanvas.style.transform = transform;
            }
            
            updateScaleDisplay() {
                document.getElementById('scale-display').textContent = Math.round(this.currentScale * 100) + '%';
            }
            
            zoomIn() {
                this.currentScale *= 1.2;
                this.updateTransform();
                this.updateScaleDisplay();
                this.checkForRerender();
            }
            
            zoomOut() {
                this.currentScale *= 0.8;
                this.updateTransform();
                this.updateScaleDisplay();
                this.checkForRerender();
            }
            
            checkForRerender() {
                if (!this.pdfDoc) return;
                
                const now = Date.now();
                const timeSinceLastUpdate = now - this.lastZoomUpdate;
                
                // Debounce re-rendering to avoid excessive calls
                if (timeSinceLastUpdate < 500) {
                    clearTimeout(this.rerenderTimeout);
                }
                
                this.rerenderTimeout = setTimeout(() => {
                    this.considerRerender();
                }, 500);
                
                this.lastZoomUpdate = now;
            }
            
            async considerRerender() {
                const optimalScale = this.calculateOptimalRenderScale();
                const currentRenderScale = this.currentRenderScale;
                
                // Re-render if the optimal scale is significantly different
                const scaleDifference = Math.abs(optimalScale - currentRenderScale) / currentRenderScale;
                
                if (scaleDifference > 0.3) { // 30% difference threshold
                    console.log(`Re-rendering at scale ${optimalScale} (was ${currentRenderScale})`);
                    await this.renderPage(optimalScale);
                    
                    // Re-process walls if we increased resolution significantly
                    if (optimalScale > currentRenderScale * 1.5) {
                        setTimeout(() => this.processImage(), 100);
                    }
                }
            }
            
            fitToScreen() {
                const viewport = document.getElementById('viewport');
                const canvasRect = this.pdfCanvas.getBoundingClientRect();
                const viewportRect = viewport.getBoundingClientRect();
                
                const scaleX = viewportRect.width / this.pdfCanvas.width;
                const scaleY = viewportRect.height / this.pdfCanvas.height;
                
                this.currentScale = Math.min(scaleX, scaleY) * 0.9;
                this.currentTranslate = { x: 0, y: 0 };
                
                this.updateTransform();
                this.updateScaleDisplay();
            }
            
            togglePanMode() {
                // Pan mode is always enabled in this implementation
                const viewport = document.getElementById('viewport');
                viewport.style.cursor = viewport.style.cursor === 'grab' ? 'default' : 'grab';
            }
            
            updatePageInfo() {
                if (this.pdfDoc) {
                    console.log(`Updating page info: ${this.pageNum} of ${this.pdfDoc.numPages}`);
                    document.getElementById('page-info').textContent = `Page ${this.pageNum} of ${this.pdfDoc.numPages}`;
                    document.getElementById('prev-page').disabled = this.pageNum <= 1;
                    document.getElementById('next-page').disabled = this.pageNum >= this.pdfDoc.numPages;
                }
            }
            
            async autoDetectFloorPlan() {
                if (!this.pdfDoc) return;
                
                this.showProcessingStatus('Analyzing pages for floor plan...');
                
                let bestPage = 1;
                let maxWalls = 0;
                
                // Test each page and count potential walls
                for (let pageNum = 1; pageNum <= this.pdfDoc.numPages; pageNum++) {
                    const page = await this.pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 1.0 });
                    
                    // Create temporary canvas
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = viewport.width;
                    tempCanvas.height = viewport.height;
                    
                    // Render page
                    await page.render({
                        canvasContext: tempCtx,
                        viewport: viewport
                    }).promise;
                    
                    // Get image data and count potential walls
                    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const testWalls = this.detectWalls(imageData);
                    
                    console.log(`Page ${pageNum}: ${testWalls.length} walls detected`);
                    
                    if (testWalls.length > maxWalls) {
                        maxWalls = testWalls.length;
                        bestPage = pageNum;
                    }
                }
                
                // Switch to the page with the most walls detected
                if (bestPage !== this.pageNum) {
                    this.pageNum = bestPage;
                    await this.renderPage();
                    this.updatePageInfo();
                    this.processImage();
                    
                    alert(`Floor plan detected on page ${bestPage} (${maxWalls} walls found)`);
                } else {
                    alert(`Current page ${this.pageNum} appears to be the floor plan (${maxWalls} walls found)`);
                }
                
                this.hideProcessingStatus();
            }
            
            generateUUID() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }
            
            calculateDistance(x1, y1, x2, y2) {
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            }
            
            calculateAngle(x1, y1, x2, y2) {
                return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            }
            
            calculateWallConfidence(wall) {
                // Calculate confidence based on wall properties
                let confidence = 0.5; // Base confidence
                
                // Longer walls are more likely to be real
                const length = this.calculateDistance(wall.startX, wall.startY, wall.endX, wall.endY);
                if (length > 50) confidence += 0.2;
                if (length > 100) confidence += 0.1;
                
                // Thicker walls are more likely to be real
                if (wall.thickness > 3) confidence += 0.1;
                if (wall.thickness > 6) confidence += 0.1;
                
                // Aligned walls (horizontal/vertical) are more confident
                const angle = Math.abs(this.calculateAngle(wall.startX, wall.startY, wall.endX, wall.endY));
                const alignedAngles = [0, 90, 180, 270];
                const minAngleDiff = Math.min(...alignedAngles.map(a => Math.abs(angle - a)));
                if (minAngleDiff < 5) confidence += 0.1;
                
                return Math.min(1.0, confidence);
            }
            
            detectRoomsFromWalls(walls) {
                const rooms = [];
                
                // Simple room detection - find rectangular areas bounded by walls
                // This is a simplified implementation
                const gridSize = 50;
                const canvasWidth = this.pdfCanvas.width;
                const canvasHeight = this.pdfCanvas.height;
                
                // Create a grid to track enclosed areas
                const grid = {};
                
                // Mark wall locations on grid
                walls.forEach(wall => {
                    const steps = Math.ceil(this.calculateDistance(wall.startX, wall.startY, wall.endX, wall.endY) / 5);
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const x = Math.round((wall.startX + t * (wall.endX - wall.startX)) / gridSize);
                        const y = Math.round((wall.startY + t * (wall.endY - wall.startY)) / gridSize);
                        grid[`${x},${y}`] = true;
                    }
                });
                
                // Find enclosed areas (simplified flood fill)
                const visited = {};
                let roomIndex = 0;
                
                for (let x = 1; x < canvasWidth / gridSize - 1; x++) {
                    for (let y = 1; y < canvasHeight / gridSize - 1; y++) {
                        const key = `${x},${y}`;
                        if (!grid[key] && !visited[key]) {
                            const room = this.floodFillRoom(x, y, grid, visited, gridSize);
                            if (room && room.area > 1000) { // Filter out small areas
                                room.id = `room_${roomIndex++}`;
                                rooms.push(room);
                            }
                        }
                    }
                }
                
                return rooms;
            }
            
            floodFillRoom(startX, startY, wallGrid, visited, gridSize) {
                const stack = [{x: startX, y: startY}];
                const roomCells = [];
                const maxCells = 1000; // Prevent infinite loops
                
                while (stack.length > 0 && roomCells.length < maxCells) {
                    const {x, y} = stack.pop();
                    const key = `${x},${y}`;
                    
                    if (visited[key] || wallGrid[key]) continue;
                    
                    visited[key] = true;
                    roomCells.push({x: x * gridSize, y: y * gridSize});
                    
                    // Add neighbors
                    const neighbors = [
                        {x: x + 1, y: y},
                        {x: x - 1, y: y},
                        {x: x, y: y + 1},
                        {x: x, y: y - 1}
                    ];
                    
                    neighbors.forEach(neighbor => {
                        const neighborKey = `${neighbor.x},${neighbor.y}`;
                        if (!visited[neighborKey] && !wallGrid[neighborKey]) {
                            stack.push(neighbor);
                        }
                    });
                }
                
                if (roomCells.length < 4) return null; // Too small
                
                // Calculate bounding box
                const minX = Math.min(...roomCells.map(c => c.x));
                const maxX = Math.max(...roomCells.map(c => c.x));
                const minY = Math.min(...roomCells.map(c => c.y));
                const maxY = Math.max(...roomCells.map(c => c.y));
                
                // Create room boundary (simplified rectangle)
                const boundary = [
                    {x: minX, y: minY},
                    {x: maxX, y: minY},
                    {x: maxX, y: maxY},
                    {x: minX, y: maxY},
                    {x: minX, y: minY} // Close the polygon
                ];
                
                const area = (maxX - minX) * (maxY - minY);
                const perimeter = 2 * ((maxX - minX) + (maxY - minY));
                
                return {
                    boundary: boundary,
                    area: area,
                    perimeter: perimeter,
                    centroid: {
                        x: (minX + maxX) / 2,
                        y: (minY + maxY) / 2
                    },
                    confidence: 0.6
                };
            }
        }
        
        // Initialize the extractor
        const extractor = new PDFWallExtractor();
    </script>
</body>
</html>