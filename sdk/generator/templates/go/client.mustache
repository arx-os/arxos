package arxos

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// HTTPMethod represents HTTP methods
type HTTPMethod string

const (
	GET    HTTPMethod = "GET"
	POST   HTTPMethod = "POST"
	PUT    HTTPMethod = "PUT"
	DELETE HTTPMethod = "DELETE"
	PATCH  HTTPMethod = "PATCH"
	HEAD   HTTPMethod = "HEAD"
)

// RequestConfig holds request configuration
type RequestConfig struct {
	Method  HTTPMethod
	URL     string
	Params  map[string]string
	Data    interface{}
	Headers map[string]string
	Timeout time.Duration
}

// ClientConfig holds client configuration
type ClientConfig struct {
	BaseURL        string
	DefaultHeaders map[string]string
	Timeout        time.Duration
	MaxRetries     int
	HTTPClient     *http.Client
}

// AuthConfig holds authentication configuration
type AuthConfig struct {
	APIKey      string
	AccessToken string
	Username    string
	Password    string
}

// ArxosError represents an SDK error
type ArxosError struct {
	Message    string
	StatusCode int
	Code       string
	Details    map[string]interface{}
}

func (e *ArxosError) Error() string {
	return e.Message
}

// AuthenticationError represents authentication errors
type AuthenticationError struct {
	*ArxosError
}

func NewAuthenticationError(message string) *AuthenticationError {
	if message == "" {
		message = "Authentication failed"
	}
	return &AuthenticationError{
		ArxosError: &ArxosError{
			Message:    message,
			StatusCode: 401,
			Code:       "AUTHENTICATION_ERROR",
		},
	}
}

// ValidationError represents validation errors
type ValidationError struct {
	*ArxosError
}

func NewValidationError(message string) *ValidationError {
	if message == "" {
		message = "Validation failed"
	}
	return &ValidationError{
		ArxosError: &ArxosError{
			Message:    message,
			StatusCode: 400,
			Code:       "VALIDATION_ERROR",
		},
	}
}

// RateLimitError represents rate limit errors
type RateLimitError struct {
	*ArxosError
}

func NewRateLimitError(message string) *RateLimitError {
	if message == "" {
		message = "Rate limit exceeded"
	}
	return &RateLimitError{
		ArxosError: &ArxosError{
			Message:    message,
			StatusCode: 429,
			Code:       "RATE_LIMIT_ERROR",
		},
	}
}

// NotFoundError represents not found errors
type NotFoundError struct {
	*ArxosError
}

func NewNotFoundError(message string) *NotFoundError {
	if message == "" {
		message = "Resource not found"
	}
	return &NotFoundError{
		ArxosError: &ArxosError{
			Message:    message,
			StatusCode: 404,
			Code:       "NOT_FOUND_ERROR",
		},
	}
}

// ServerError represents server errors
type ServerError struct {
	*ArxosError
}

func NewServerError(message string) *ServerError {
	if message == "" {
		message = "Internal server error"
	}
	return &ServerError{
		ArxosError: &ArxosError{
			Message:    message,
			StatusCode: 500,
			Code:       "SERVER_ERROR",
		},
	}
}

// Response represents a generic API response
type Response struct {
	Success bool                   `json:"success"`
	Message string                 `json:"message,omitempty"`
	Data    interface{}            `json:"data,omitempty"`
	Errors  []string              `json:"errors,omitempty"`
}

// PaginatedResponse represents a paginated response
type PaginatedResponse struct {
	Items    []interface{} `json:"items"`
	Total    int           `json:"total"`
	Page     int           `json:"page"`
	PerPage  int           `json:"per_page"`
	HasNext  bool          `json:"has_next"`
	HasPrev  bool          `json:"has_prev"`
}

// RateLimiter handles rate limiting
type RateLimiter struct {
	maxRequests int
	windowMs    int64
	requests    []int64
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(maxRequests int, windowMs int64) *RateLimiter {
	return &RateLimiter{
		maxRequests: maxRequests,
		windowMs:    windowMs,
		requests:    make([]int64, 0),
	}
}

// CanMakeRequest checks if a request can be made
func (rl *RateLimiter) CanMakeRequest() bool {
	now := time.Now().UnixMilli()
	windowStart := now - rl.windowMs

	// Remove old requests
	var newRequests []int64
	for _, reqTime := range rl.requests {
		if reqTime > windowStart {
			newRequests = append(newRequests, reqTime)
		}
	}
	rl.requests = newRequests

	if len(rl.requests) >= rl.maxRequests {
		return false
	}

	rl.requests = append(rl.requests, now)
	return true
}

// WaitIfNeeded waits if rate limit is reached
func (rl *RateLimiter) WaitIfNeeded() {
	for !rl.CanMakeRequest() {
		time.Sleep(time.Second)
	}
}

// RetryHandler handles request retries
type RetryHandler struct {
	maxRetries           int
	retryDelay           time.Duration
	backoffMultiplier    float64
	retryableStatusCodes []int
}

// NewRetryHandler creates a new retry handler
func NewRetryHandler(maxRetries int, retryDelay time.Duration, backoffMultiplier float64) *RetryHandler {
	return &RetryHandler{
		maxRetries:        maxRetries,
		retryDelay:        retryDelay,
		backoffMultiplier: backoffMultiplier,
		retryableStatusCodes: []int{429, 500, 502, 503, 504},
	}
}

// Execute executes a request with retry logic
func (rh *RetryHandler) Execute(requestFunc func() (interface{}, error)) (interface{}, error) {
	var lastError error

	for attempt := 0; attempt <= rh.maxRetries; attempt++ {
		result, err := requestFunc()
		if err == nil {
			return result, nil
		}

		// Check if error is retryable
		if arxosErr, ok := err.(*ArxosError); ok {
			if !rh.isRetryableStatusCode(arxosErr.StatusCode) || attempt == rh.maxRetries {
				return nil, err
			}
		} else if attempt == rh.maxRetries {
			return nil, err
		}

		lastError = err
		delay := time.Duration(float64(rh.retryDelay) * float64(attempt+1) * rh.backoffMultiplier)
		time.Sleep(delay)
	}

	return nil, lastError
}

// isRetryableStatusCode checks if status code is retryable
func (rh *RetryHandler) isRetryableStatusCode(statusCode int) bool {
	for _, code := range rh.retryableStatusCodes {
		if code == statusCode {
			return true
		}
	}
	return false
}

// ResponseCache handles response caching
type ResponseCache struct {
	ttl     time.Duration
	maxSize int
	cache   map[string]cacheItem
}

type cacheItem struct {
	data      interface{}
	timestamp time.Time
}

// NewResponseCache creates a new response cache
func NewResponseCache(ttl time.Duration, maxSize int) *ResponseCache {
	return &ResponseCache{
		ttl:     ttl,
		maxSize: maxSize,
		cache:   make(map[string]cacheItem),
	}
}

// Get retrieves cached response
func (rc *ResponseCache) Get(key string) (interface{}, bool) {
	item, exists := rc.cache[key]
	if !exists {
		return nil, false
	}

	if time.Since(item.timestamp) > rc.ttl {
		delete(rc.cache, key)
		return nil, false
	}

	return item.data, true
}

// Set stores response in cache
func (rc *ResponseCache) Set(key string, data interface{}) {
	if len(rc.cache) >= rc.maxSize {
		// Remove oldest entry
		var oldestKey string
		var oldestTime time.Time
		for k, v := range rc.cache {
			if oldestKey == "" || v.timestamp.Before(oldestTime) {
				oldestKey = k
				oldestTime = v.timestamp
			}
		}
		if oldestKey != "" {
			delete(rc.cache, oldestKey)
		}
	}

	rc.cache[key] = cacheItem{
		data:      data,
		timestamp: time.Now(),
	}
}

// Clear clears the cache
func (rc *ResponseCache) Clear() {
	rc.cache = make(map[string]cacheItem)
}

// GetStats returns cache statistics
func (rc *ResponseCache) GetStats() map[string]interface{} {
	return map[string]interface{}{
		"size":     len(rc.cache),
		"max_size": rc.maxSize,
		"ttl":      rc.ttl,
	}
}

// AuthManager handles authentication
type AuthManager struct {
	client *{{classname}}Client
	config *AuthConfig
}

// NewAuthManager creates a new auth manager
func NewAuthManager(client *{{classname}}Client, config *AuthConfig) *AuthManager {
	return &AuthManager{
		client: client,
		config: config,
	}
}

// GetHeaders returns authentication headers
func (am *AuthManager) GetHeaders() map[string]string {
	headers := make(map[string]string)

	if am.config.APIKey != "" {
		headers["X-API-Key"] = am.config.APIKey
	}

	if am.config.AccessToken != "" {
		headers["Authorization"] = fmt.Sprintf("Bearer %s", am.config.AccessToken)
	}

	return headers
}

// Authenticate authenticates with username and password
func (am *AuthManager) Authenticate(ctx context.Context, username, password string) (string, error) {
	data := map[string]string{
		"username": username,
		"password": password,
	}

	response, err := am.client.MakeRequest(ctx, POST, "/auth/login", nil, data, nil)
	if err != nil {
		return "", NewAuthenticationError(fmt.Sprintf("Authentication failed: %v", err))
	}

	responseData, ok := response.(map[string]interface{})
	if !ok {
		return "", NewAuthenticationError("Invalid response format")
	}

	if accessToken, ok := responseData["access_token"].(string); ok {
		am.config.AccessToken = accessToken
		return accessToken, nil
	}

	return "", NewAuthenticationError("No access token in response")
}

// RefreshToken refreshes the authentication token
func (am *AuthManager) RefreshToken(ctx context.Context) (string, error) {
	if am.config.AccessToken == "" {
		return "", NewAuthenticationError("No token to refresh")
	}

	data := map[string]string{
		"token": am.config.AccessToken,
	}

	response, err := am.client.MakeRequest(ctx, POST, "/auth/refresh", nil, data, nil)
	if err != nil {
		return "", NewAuthenticationError(fmt.Sprintf("Token refresh failed: %v", err))
	}

	responseData, ok := response.(map[string]interface{})
	if !ok {
		return "", NewAuthenticationError("Invalid refresh response")
	}

	if accessToken, ok := responseData["access_token"].(string); ok {
		am.config.AccessToken = accessToken
		return accessToken, nil
	}

	return "", NewAuthenticationError("No access token in refresh response")
}

// Logout logs out and clears authentication
func (am *AuthManager) Logout(ctx context.Context) error {
	if am.config.AccessToken != "" {
		_, err := am.client.MakeRequest(ctx, POST, "/auth/logout", nil, nil, nil)
		if err != nil {
			// Log error but don't return it - logout should always succeed
			fmt.Printf("Warning: Logout request failed: %v\n", err)
		}
	}

	am.config.AccessToken = ""
	return nil
}

// {{classname}}Client represents the {{classname}} API client
type {{classname}}Client struct {
	baseURL        string
	httpClient     *http.Client
	defaultHeaders map[string]string
	authManager    *AuthManager
	rateLimiter    *RateLimiter
	retryHandler   *RetryHandler
	cache          *ResponseCache
}

// New{{classname}}Client creates a new {{classname}} client
func New{{classname}}Client(baseURL string, config *ClientConfig) *{{classname}}Client {
	if config == nil {
		config = &ClientConfig{}
	}

	if config.Timeout == 0 {
		config.Timeout = 30 * time.Second
	}

	if config.MaxRetries == 0 {
		config.MaxRetries = 3
	}

	httpClient := config.HTTPClient
	if httpClient == nil {
		httpClient = &http.Client{
			Timeout: config.Timeout,
		}
	}

	client := &{{classname}}Client{
		baseURL:        strings.TrimSuffix(baseURL, "/"),
		httpClient:     httpClient,
		defaultHeaders: config.DefaultHeaders,
		rateLimiter:    NewRateLimiter(100, 60000), // 100 requests per minute
		retryHandler:   NewRetryHandler(config.MaxRetries, time.Second, 2.0),
		cache:          NewResponseCache(5*time.Minute, 100),
	}

	if client.defaultHeaders == nil {
		client.defaultHeaders = make(map[string]string)
	}

	// Set default headers
	client.defaultHeaders["Content-Type"] = "application/json"
	client.defaultHeaders["Accept"] = "application/json"
	client.defaultHeaders["User-Agent"] = "Arxos-SDK-Go/1.0.0"

	return client
}

// SetAuthConfig sets authentication configuration
func (c *{{classname}}Client) SetAuthConfig(config *AuthConfig) {
	c.authManager = NewAuthManager(c, config)
}

// SetAuthToken sets the authentication token
func (c *{{classname}}Client) SetAuthToken(token string) {
	if c.authManager == nil {
		c.authManager = NewAuthManager(c, &AuthConfig{})
	}
	c.authManager.config.AccessToken = token
}

// ClearAuthToken clears the authentication token
func (c *{{classname}}Client) ClearAuthToken() {
	if c.authManager != nil {
		c.authManager.config.AccessToken = ""
	}
}

// GetAuthToken returns the current authentication token
func (c *{{classname}}Client) GetAuthToken() string {
	if c.authManager != nil {
		return c.authManager.config.AccessToken
	}
	return ""
}

// MakeRequest makes an HTTP request to the API
func (c *{{classname}}Client) MakeRequest(
	ctx context.Context,
	method HTTPMethod,
	endpoint string,
	params map[string]string,
	data interface{},
	headers map[string]string,
) (interface{}, error) {
	// Wait for rate limit
	c.rateLimiter.WaitIfNeeded()

	// Prepare request
	url := fmt.Sprintf("%s%s", c.baseURL, endpoint)
	
	// Add query parameters
	if len(params) > 0 {
		u, err := url.Parse(url)
		if err != nil {
			return nil, fmt.Errorf("invalid URL: %v", err)
		}
		
		q := u.Query()
		for k, v := range params {
			q.Set(k, v)
		}
		u.RawQuery = q.Encode()
		url = u.String()
	}

	// Prepare request body
	var body io.Reader
	if data != nil {
		jsonData, err := json.Marshal(data)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal request data: %v", err)
		}
		body = bytes.NewBuffer(jsonData)
	}

	// Create request
	req, err := http.NewRequestWithContext(ctx, string(method), url, body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}

	// Set headers
	for k, v := range c.defaultHeaders {
		req.Header.Set(k, v)
	}

	// Add authentication headers
	if c.authManager != nil {
		for k, v := range c.authManager.GetHeaders() {
			req.Header.Set(k, v)
		}
	}

	// Add custom headers
	for k, v := range headers {
		req.Header.Set(k, v)
	}

	// Execute request with retry logic
	var result interface{}
	err = c.retryHandler.Execute(func() (interface{}, error) {
		resp, err := c.httpClient.Do(req)
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()

		// Read response body
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %v", err)
		}

		// Handle error responses
		if resp.StatusCode >= 400 {
			return nil, c.handleErrorResponse(resp.StatusCode, respBody)
		}

		// Parse response
		var response interface{}
		if len(respBody) > 0 {
			if err := json.Unmarshal(respBody, &response); err != nil {
				return nil, fmt.Errorf("failed to parse response: %v", err)
			}
		}

		return response, nil
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

// handleErrorResponse handles error responses
func (c *{{classname}}Client) handleErrorResponse(statusCode int, body []byte) error {
	var errorData map[string]interface{}
	if len(body) > 0 {
		if err := json.Unmarshal(body, &errorData); err != nil {
			// If we can't parse the error response, create a generic error
			errorData = map[string]interface{}{
				"message": string(body),
				"code":    "UNKNOWN_ERROR",
			}
		}
	}

	message := "Unknown error"
	if msg, ok := errorData["message"].(string); ok {
		message = msg
	}

	code := "UNKNOWN_ERROR"
	if c, ok := errorData["code"].(string); ok {
		code = c
	}

	switch statusCode {
	case 401:
		return NewAuthenticationError(message)
	case 400:
		return NewValidationError(message)
	case 404:
		return NewNotFoundError(message)
	case 429:
		return NewRateLimitError(message)
	case 500, 502, 503, 504:
		return NewServerError(message)
	default:
		return &ArxosError{
			Message:    message,
			StatusCode: statusCode,
			Code:       code,
		}
	}
}

// MakeCachedRequest makes a cached request
func (c *{{classname}}Client) MakeCachedRequest(
	ctx context.Context,
	key string,
	requestFunc func() (interface{}, error),
) (interface{}, error) {
	// Check cache first
	if cached, exists := c.cache.Get(key); exists {
		return cached, nil
	}

	// Make request
	result, err := requestFunc()
	if err != nil {
		return nil, err
	}

	// Cache result
	c.cache.Set(key, result)
	return result, nil
}

{{#operations}}
{{#operation}}
// {{operationId}} {{summary}}
//
// {{notes}}
func (c *{{classname}}Client) {{operationId}}(
	ctx context.Context,
	{{#parameters}}
	{{paramName}}{{^required}} *{{dataType}}{{/required}}{{#required}} {{dataType}}{{/required}}{{#defaultValue}} = {{{defaultValue}}}{{/defaultValue}},
	{{/parameters}}
) ({{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}interface{}{{/returnType}}, error) {
	// Build URL with path parameters
	url := "{{{path}}}"{{#pathParams}}.Replace("{{paramName}}", fmt.Sprintf("%v", {{paramName}})){{/pathParams}}
	
	// Prepare request parameters
	params := make(map[string]string)
	{{#queryParams}}
	if {{paramName}} != nil {
		params["{{paramName}}"] = fmt.Sprintf("%v", *{{paramName}})
	}
	{{/queryParams}}
	
	// Prepare request data
	var data interface{}
	{{#hasBodyParam}}
	data = {{bodyParam.paramName}}
	{{/hasBodyParam}}
	
	// Make request
	return c.MakeRequest(ctx, {{httpMethod}}, url, params, data, nil)
}

{{/operation}}
{{/operations}}

// Enhanced{{classname}}Client represents an enhanced {{classname}} client
type Enhanced{{classname}}Client struct {
	*{{classname}}Client
}

// NewEnhanced{{classname}}Client creates a new enhanced {{classname}} client
func NewEnhanced{{classname}}Client(
	baseURL string,
	config *ClientConfig,
	authConfig *AuthConfig,
) *Enhanced{{classname}}Client {
	client := New{{classname}}Client(baseURL, config)
	
	if authConfig != nil {
		client.SetAuthConfig(authConfig)
	}
	
	return &Enhanced{{classname}}Client{
		{{classname}}Client: client,
	}
}

// GetAuthManager returns the authentication manager
func (c *Enhanced{{classname}}Client) GetAuthManager() *AuthManager {
	return c.authManager
}

// GetRateLimiter returns the rate limiter
func (c *Enhanced{{classname}}Client) GetRateLimiter() *RateLimiter {
	return c.rateLimiter
}

// GetCache returns the cache
func (c *Enhanced{{classname}}Client) GetCache() *ResponseCache {
	return c.cache
}

// Authenticate authenticates with username and password
func (c *Enhanced{{classname}}Client) Authenticate(ctx context.Context, username, password string) (string, error) {
	if c.authManager == nil {
		c.authManager = NewAuthManager(c.{{classname}}Client, &AuthConfig{})
	}
	return c.authManager.Authenticate(ctx, username, password)
}

// RefreshToken refreshes the authentication token
func (c *Enhanced{{classname}}Client) RefreshToken(ctx context.Context) (string, error) {
	if c.authManager == nil {
		return "", NewAuthenticationError("No authentication manager configured")
	}
	return c.authManager.RefreshToken(ctx)
}

// Logout logs out and clears authentication
func (c *Enhanced{{classname}}Client) Logout(ctx context.Context) error {
	if c.authManager != nil {
		return c.authManager.Logout(ctx)
	}
	return nil
} 