<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arxos BIM - PDF Diagnostic Tool</title>
    <style>
        body {
            font-family: monospace;
            background: #1a1a1a;
            color: #0f0;
            margin: 20px;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        
        .panel {
            background: #000;
            border: 1px solid #0f0;
            padding: 10px;
            overflow: auto;
        }
        
        h2 {
            color: #0f0;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        
        canvas {
            border: 1px solid #0f0;
            max-width: 100%;
            display: block;
            margin: 10px 0;
        }
        
        input[type="file"] {
            background: #0f0;
            color: #000;
            padding: 5px;
            margin: 10px 0;
        }
        
        .log {
            font-size: 12px;
            line-height: 1.4;
            white-space: pre-wrap;
        }
        
        .error { color: #f00; }
        .success { color: #0f0; }
        .info { color: #ff0; }
        .data { color: #0ff; }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h2>PDF DIAGNOSTIC ANALYZER</h2>
            <input type="file" id="pdfFile" accept=".pdf">
            <div id="status" class="log"></div>
            <canvas id="originalCanvas"></canvas>
            <canvas id="processedCanvas"></canvas>
        </div>
        
        <div class="panel">
            <h2>EXTRACTION LOG</h2>
            <div id="log" class="log"></div>
        </div>
    </div>

    <script>
        const log = (message, type = '') => {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toISOString().substr(11, 12);
            const className = type ? ` class="${type}"` : '';
            logDiv.innerHTML += `<div${className}>[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        };

        const status = (message) => {
            document.getElementById('status').innerHTML = message;
        };

        document.getElementById('pdfFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            log('=== PDF DIAGNOSTIC START ===', 'success');
            log(`File: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)`, 'info');
            
            try {
                // Load PDF.js
                if (!window.pdfjsLib) {
                    log('Loading PDF.js library...', 'info');
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
                    document.head.appendChild(script);
                    await new Promise(resolve => script.onload = resolve);
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                }
                
                // Load PDF
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                log(`PDF loaded: ${pdf.numPages} pages`, 'success');
                
                // Get first page
                const page = await pdf.getPage(1);
                const viewport = page.getViewport({ scale: 2.0 });
                log(`Page dimensions: ${viewport.width}x${viewport.height}`, 'info');
                
                // Render original
                status('Rendering original PDF...');
                const canvas1 = document.getElementById('originalCanvas');
                const ctx1 = canvas1.getContext('2d');
                canvas1.width = viewport.width;
                canvas1.height = viewport.height;
                
                await page.render({
                    canvasContext: ctx1,
                    viewport: viewport
                }).promise;
                
                log('Original rendered', 'success');
                
                // Extract vector operations
                status('Extracting vector operations...');
                const ops = await page.getOperatorList();
                log(`Total operations: ${ops.fnArray.length}`, 'data');
                
                // Count operation types
                const opCounts = {};
                const opNames = {
                    1: 'transform',
                    2: 'moveTo',
                    3: 'lineTo',
                    4: 'curveTo',
                    5: 'closePath',
                    6: 'rectangle',
                    7: 'stroke',
                    8: 'fill',
                    14: 'beginPath',
                    15: 'endPath',
                    19: 'save',
                    20: 'restore',
                    21: 'setLineWidth',
                    22: 'setLineCap',
                    23: 'setLineJoin',
                    24: 'setMiterLimit',
                    25: 'setDash',
                    26: 'setFlatness',
                    27: 'setStrokeRGBColor',
                    28: 'setFillRGBColor'
                };
                
                ops.fnArray.forEach(op => {
                    const name = opNames[op] || `op_${op}`;
                    opCounts[name] = (opCounts[name] || 0) + 1;
                });
                
                log('Operation counts:', 'data');
                Object.entries(opCounts).forEach(([op, count]) => {
                    log(`  ${op}: ${count}`, 'data');
                });
                
                // Extract lines and rectangles
                let lines = [];
                let rectangles = [];
                let currentPoint = null;
                let pathStarted = false;
                
                for (let i = 0; i < ops.fnArray.length; i++) {
                    const op = ops.fnArray[i];
                    const args = ops.argsArray[i];
                    
                    switch (op) {
                        case 2: // moveTo
                            currentPoint = { x: args[0], y: args[1] };
                            pathStarted = true;
                            break;
                            
                        case 3: // lineTo
                            if (currentPoint && pathStarted) {
                                lines.push({
                                    start: { ...currentPoint },
                                    end: { x: args[0], y: args[1] }
                                });
                                currentPoint = { x: args[0], y: args[1] };
                            }
                            break;
                            
                        case 6: // rectangle
                            const [x, y, w, h] = args;
                            rectangles.push({ x, y, width: w, height: h });
                            // Convert to lines
                            lines.push(
                                { start: {x, y}, end: {x: x+w, y} },
                                { start: {x: x+w, y}, end: {x: x+w, y: y+h} },
                                { start: {x: x+w, y: y+h}, end: {x, y: y+h} },
                                { start: {x, y: y+h}, end: {x, y} }
                            );
                            break;
                            
                        case 5: // closePath
                        case 7: // stroke
                        case 8: // fill
                            pathStarted = false;
                            break;
                    }
                }
                
                log(`Extracted: ${lines.length} lines, ${rectangles.length} rectangles`, 'success');
                
                // Analyze line characteristics
                const horizontalLines = lines.filter(l => Math.abs(l.start.y - l.end.y) < 1);
                const verticalLines = lines.filter(l => Math.abs(l.start.x - l.end.x) < 1);
                const diagonalLines = lines.length - horizontalLines.length - verticalLines.length;
                
                log('Line analysis:', 'data');
                log(`  Horizontal: ${horizontalLines.length}`, 'data');
                log(`  Vertical: ${verticalLines.length}`, 'data');
                log(`  Diagonal: ${diagonalLines}`, 'data');
                
                // Draw extracted lines on processed canvas
                status('Drawing extracted geometry...');
                const canvas2 = document.getElementById('processedCanvas');
                const ctx2 = canvas2.getContext('2d');
                canvas2.width = viewport.width;
                canvas2.height = viewport.height;
                
                // Scale factor for drawing
                const scale = viewport.width / 1000;
                
                // Clear and draw background
                ctx2.fillStyle = '#000';
                ctx2.fillRect(0, 0, canvas2.width, canvas2.height);
                
                // Draw lines
                ctx2.strokeStyle = '#0f0';
                ctx2.lineWidth = 2;
                
                lines.forEach(line => {
                    ctx2.beginPath();
                    ctx2.moveTo(line.start.x * scale, line.start.y * scale);
                    ctx2.lineTo(line.end.x * scale, line.end.y * scale);
                    ctx2.stroke();
                });
                
                // Draw rectangles
                ctx2.strokeStyle = '#ff0';
                rectangles.forEach(rect => {
                    ctx2.strokeRect(
                        rect.x * scale,
                        rect.y * scale,
                        rect.width * scale,
                        rect.height * scale
                    );
                });
                
                // Find unique endpoints
                const endpoints = new Set();
                lines.forEach(line => {
                    endpoints.add(`${Math.round(line.start.x)},${Math.round(line.start.y)}`);
                    endpoints.add(`${Math.round(line.end.x)},${Math.round(line.end.y)}`);
                });
                
                log(`Unique endpoints: ${endpoints.size}`, 'data');
                
                // Check for disconnected segments
                const connectionMap = {};
                lines.forEach(line => {
                    const startKey = `${Math.round(line.start.x)},${Math.round(line.start.y)}`;
                    const endKey = `${Math.round(line.end.x)},${Math.round(line.end.y)}`;
                    
                    connectionMap[startKey] = (connectionMap[startKey] || 0) + 1;
                    connectionMap[endKey] = (connectionMap[endKey] || 0) + 1;
                });
                
                const disconnected = Object.values(connectionMap).filter(c => c === 1).length;
                log(`Disconnected endpoints: ${disconnected}`, disconnected > 0 ? 'error' : 'success');
                
                // Calculate coverage
                const minX = Math.min(...lines.map(l => Math.min(l.start.x, l.end.x)));
                const maxX = Math.max(...lines.map(l => Math.max(l.start.x, l.end.x)));
                const minY = Math.min(...lines.map(l => Math.min(l.start.y, l.end.y)));
                const maxY = Math.max(...lines.map(l => Math.max(l.start.y, l.end.y)));
                
                const coverage = {
                    width: maxX - minX,
                    height: maxY - minY,
                    area: (maxX - minX) * (maxY - minY)
                };
                
                log('Coverage:', 'data');
                log(`  Bounds: (${minX.toFixed(1)}, ${minY.toFixed(1)}) to (${maxX.toFixed(1)}, ${maxY.toFixed(1)})`, 'data');
                log(`  Area: ${coverage.area.toFixed(0)} square units`, 'data');
                
                // Try alternative extraction using getTextContent
                const textContent = await page.getTextContent();
                log(`Text items: ${textContent.items.length}`, 'data');
                
                const roomLabels = textContent.items.filter(item => 
                    /room|rm\.|corridor|office|bathroom/i.test(item.str)
                );
                log(`Room labels found: ${roomLabels.length}`, 'info');
                roomLabels.forEach(label => {
                    log(`  "${label.str}" at (${label.transform[4].toFixed(1)}, ${label.transform[5].toFixed(1)})`, 'data');
                });
                
                status('Analysis complete!');
                log('=== DIAGNOSTIC COMPLETE ===', 'success');
                
            } catch (error) {
                log(`ERROR: ${error.message}`, 'error');
                console.error(error);
            }
        });
    </script>
</body>
</html>