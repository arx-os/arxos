<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HCPS BIM Diagnostic Tool</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #111;
    color: #ddd;
    padding: 20px;
}
.container {
    max-width: 1400px;
    margin: 0 auto;
}
h1 {
    background: linear-gradient(135deg, #4a9eff, #00ff88);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 20px;
}
.grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
}
.panel {
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 20px;
}
.panel h2 {
    font-size: 16px;
    margin-bottom: 15px;
    color: #4a9eff;
}
canvas {
    width: 100%;
    border: 1px solid #444;
    border-radius: 4px;
    background: #000;
}
.controls {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
}
button {
    padding: 10px 20px;
    background: #4a9eff;
    color: #000;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
}
button:hover {
    background: #5aafff;
}
.upload-zone {
    border: 2px dashed #333;
    border-radius: 8px;
    padding: 40px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
}
.upload-zone:hover {
    border-color: #4a9eff;
    background: rgba(74,158,255,0.05);
}
.log {
    background: #0a0a0a;
    border: 1px solid #222;
    border-radius: 4px;
    padding: 10px;
    height: 200px;
    overflow-y: auto;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 12px;
}
.log-entry {
    margin: 2px 0;
    padding: 2px 4px;
}
.log-info { color: #888; }
.log-success { color: #0f0; }
.log-error { color: #f44; }
.log-warn { color: #fa0; }
.stats {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    margin-top: 15px;
}
.stat {
    background: #0a0a0a;
    padding: 10px;
    border-radius: 4px;
    text-align: center;
}
.stat-value {
    font-size: 24px;
    font-weight: bold;
    color: #4a9eff;
}
.stat-label {
    font-size: 11px;
    color: #666;
    text-transform: uppercase;
}
#bimCanvas { cursor: crosshair; }
</style>
</head>
<body>

<div class="container">
    <h1>HCPS BIM Diagnostic Tool</h1>
    
    <div class="controls">
        <input type="file" id="fileInput" accept=".pdf" style="display:none">
        <button onclick="document.getElementById('fileInput').click()">Upload PDF</button>
        <button onclick="testDirectDraw()">Test Direct Draw</button>
        <button onclick="testExtraction()">Auto Extract</button>
        <button onclick="forceEdgeDetection()">Force Edge Detection</button>
        <button onclick="addDemoWalls()">Add Demo Walls</button>
        <button onclick="clearAll()">Clear All</button>
        <button onclick="zoomIn()">Zoom In</button>
        <button onclick="zoomOut()">Zoom Out</button>
        <button onclick="resetView()">Reset View</button>
    </div>
    
    <div class="grid">
        <!-- PDF Preview -->
        <div class="panel">
            <h2>üìÑ PDF Preview</h2>
            <canvas id="pdfCanvas"></canvas>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="pdfWidth">0</div>
                    <div class="stat-label">Width</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="pdfHeight">0</div>
                    <div class="stat-label">Height</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="pdfScale">1.0</div>
                    <div class="stat-label">Scale</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="darkPixels">0</div>
                    <div class="stat-label">Dark Pixels</div>
                </div>
            </div>
        </div>
        
        <!-- BIM Viewer -->
        <div class="panel">
            <h2>üèóÔ∏è BIM Viewer</h2>
            <canvas id="bimCanvas"></canvas>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="wallCount">0</div>
                    <div class="stat-label">Walls</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="viewZoom">1.0</div>
                    <div class="stat-label">Zoom</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="viewPanX">0</div>
                    <div class="stat-label">Pan X</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="viewPanY">0</div>
                    <div class="stat-label">Pan Y</div>
                </div>
            </div>
        </div>
        
        <!-- Extraction Preview -->
        <div class="panel">
            <h2>üîç Extraction Analysis</h2>
            <canvas id="extractCanvas"></canvas>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="threshold">128</div>
                    <div class="stat-label">Threshold</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="hLines">0</div>
                    <div class="stat-label">H-Lines</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="vLines">0</div>
                    <div class="stat-label">V-Lines</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="extracted">0</div>
                    <div class="stat-label">Extracted</div>
                </div>
            </div>
        </div>
        
        <!-- Console Log -->
        <div class="panel">
            <h2>üìù Console Log</h2>
            <div class="log" id="log"></div>
        </div>
    </div>
</div>

<script>
// Diagnostic BIM System
const Diagnostic = {
    pdfCanvas: null,
    pdfCtx: null,
    bimCanvas: null,
    bimCtx: null,
    extractCanvas: null,
    extractCtx: null,
    
    walls: [],
    zoom: 1.0,
    pan: { x: 0, y: 0 },
    pdfData: null,
    dragStart: null,
    
    init() {
        this.log('Initializing diagnostic system...', 'info');
        
        // Setup canvases
        this.pdfCanvas = document.getElementById('pdfCanvas');
        this.pdfCtx = this.pdfCanvas.getContext('2d');
        
        this.bimCanvas = document.getElementById('bimCanvas');
        this.bimCtx = this.bimCanvas.getContext('2d');
        
        this.extractCanvas = document.getElementById('extractCanvas');
        this.extractCtx = this.extractCanvas.getContext('2d');
        
        // Set canvas sizes
        [this.pdfCanvas, this.bimCanvas, this.extractCanvas].forEach(canvas => {
            canvas.width = 600;
            canvas.height = 400;
        });
        
        // BIM canvas interactions
        this.bimCanvas.onmousedown = (e) => this.mouseDown(e);
        this.bimCanvas.onmousemove = (e) => this.mouseMove(e);
        this.bimCanvas.onmouseup = (e) => this.mouseUp(e);
        this.bimCanvas.onwheel = (e) => this.wheel(e);
        
        // File input
        document.getElementById('fileInput').onchange = (e) => this.handleFile(e);
        
        this.renderBIM();
        this.log('System ready', 'success');
    },
    
    log(message, type = 'info') {
        const log = document.getElementById('log');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        const time = new Date().toLocaleTimeString();
        entry.textContent = `[${time}] ${message}`;
        log.appendChild(entry);
        log.scrollTop = log.scrollHeight;
        console.log(`[${type}] ${message}`);
    },
    
    async handleFile(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        this.log(`Loading PDF: ${file.name}`, 'info');
        
        try {
            const arrayBuffer = await file.arrayBuffer();
            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
            const pdf = await loadingTask.promise;
            
            this.log(`PDF loaded: ${pdf.numPages} pages`, 'success');
            
            const page = await pdf.getPage(1);
            const viewport = page.getViewport({ scale: 2.0 });
            
            // Update stats
            document.getElementById('pdfWidth').textContent = Math.round(viewport.width);
            document.getElementById('pdfHeight').textContent = Math.round(viewport.height);
            document.getElementById('pdfScale').textContent = '2.0';
            
            // Render to canvas
            this.pdfCanvas.width = viewport.width;
            this.pdfCanvas.height = viewport.height;
            
            await page.render({
                canvasContext: this.pdfCtx,
                viewport: viewport
            }).promise;
            
            this.log('PDF rendered', 'success');
            
            // Store for extraction
            this.pdfData = {
                canvas: this.pdfCanvas,
                ctx: this.pdfCtx,
                width: viewport.width,
                height: viewport.height
            };
            
            // Auto-extract
            this.testExtraction();
            
        } catch (error) {
            this.log(`Error: ${error.message}`, 'error');
        }
    },
    
    testDirectDraw() {
        this.log('Testing direct draw...', 'info');
        
        // Clear and add test walls
        this.walls = [
            { id: 'd1', x1: -200, y1: -150, x2: 200, y2: -150 },
            { id: 'd2', x1: 200, y1: -150, x2: 200, y2: 150 },
            { id: 'd3', x1: 200, y1: 150, x2: -200, y2: 150 },
            { id: 'd4', x1: -200, y1: 150, x2: -200, y2: -150 },
            { id: 'd5', x1: -200, y1: 0, x2: 200, y2: 0 },
            { id: 'd6', x1: 0, y1: -150, x2: 0, y2: 150 }
        ];
        
        document.getElementById('wallCount').textContent = this.walls.length;
        this.log(`Added ${this.walls.length} test walls`, 'success');
        
        this.renderBIM();
    },
    
    testExtraction() {
        if (!this.pdfData) {
            this.log('No PDF loaded', 'error');
            return;
        }
        
        this.log('Extracting walls from PDF...', 'info');
        
        const imageData = this.pdfData.ctx.getImageData(
            0, 0, this.pdfData.width, this.pdfData.height
        );
        
        // Try multiple thresholds to find the best one
        const thresholds = [240, 230, 220, 210, 200, 180, 160, 140, 128];
        let bestThreshold = 128;
        let maxDarkPixels = 0;
        
        for (let thresh of thresholds) {
            let darkCount = 0;
            for (let i = 0; i < imageData.data.length; i += 4) {
                const brightness = (imageData.data[i] + imageData.data[i+1] + imageData.data[i+2]) / 3;
                if (brightness < thresh) darkCount++;
            }
            
            // Look for threshold that gives reasonable dark pixel count (1-10% of image)
            const percentage = (darkCount / (imageData.data.length/4)) * 100;
            if (percentage > 0.5 && percentage < 10) {
                bestThreshold = thresh;
                maxDarkPixels = darkCount;
                this.log(`Found good threshold ${thresh} with ${percentage.toFixed(2)}% dark pixels`, 'info');
                break;
            }
        }
        
        const threshold = bestThreshold;
        document.getElementById('darkPixels').textContent = maxDarkPixels;
        document.getElementById('threshold').textContent = threshold;
        
        // Extract walls with simple algorithm
        this.walls = [];
        const scale = 400 / Math.max(this.pdfData.width, this.pdfData.height);
        
        // Horizontal lines - scan with finer resolution
        let hLines = 0;
        for (let y = 0; y < this.pdfData.height; y += 5) {
            let lineStart = -1;
            let darkRun = 0;
            let gaps = 0;
            
            for (let x = 0; x < this.pdfData.width; x += 2) {
                const idx = (y * this.pdfData.width + x) * 4;
                const brightness = (imageData.data[idx] + imageData.data[idx+1] + imageData.data[idx+2]) / 3;
                
                if (brightness < threshold) {
                    if (lineStart === -1) lineStart = x;
                    darkRun++;
                    gaps = 0;
                } else {
                    // Allow small gaps in lines
                    if (lineStart !== -1) {
                        gaps++;
                        if (gaps > 5) {
                            if (darkRun > 5) {
                                const x1 = (lineStart - this.pdfData.width/2) * scale;
                                const y1 = (y - this.pdfData.height/2) * scale;
                                const x2 = (x - gaps*2 - this.pdfData.width/2) * scale;
                                const y2 = y1;
                                
                                if (Math.abs(x2 - x1) > 20) {
                                    this.walls.push({ id: `h${hLines++}`, x1, y1, x2, y2 });
                                }
                            }
                            lineStart = -1;
                            darkRun = 0;
                            gaps = 0;
                        }
                    }
                }
            }
        }
        
        // Vertical lines - scan with finer resolution
        let vLines = 0;
        for (let x = 0; x < this.pdfData.width; x += 5) {
            let lineStart = -1;
            let darkRun = 0;
            let gaps = 0;
            
            for (let y = 0; y < this.pdfData.height; y += 2) {
                const idx = (y * this.pdfData.width + x) * 4;
                const brightness = (imageData.data[idx] + imageData.data[idx+1] + imageData.data[idx+2]) / 3;
                
                if (brightness < threshold) {
                    if (lineStart === -1) lineStart = y;
                    darkRun++;
                    gaps = 0;
                } else {
                    // Allow small gaps in lines
                    if (lineStart !== -1) {
                        gaps++;
                        if (gaps > 5) {
                            if (darkRun > 5) {
                                const x1 = (x - this.pdfData.width/2) * scale;
                                const y1 = (lineStart - this.pdfData.height/2) * scale;
                                const x2 = x1;
                                const y2 = (y - gaps*2 - this.pdfData.height/2) * scale;
                                
                                if (Math.abs(y2 - y1) > 20) {
                                    this.walls.push({ id: `v${vLines++}`, x1, y1, x2, y2 });
                                }
                            }
                            lineStart = -1;
                            darkRun = 0;
                            gaps = 0;
                        }
                    }
                }
            }
        }
        
        // If no walls found, try edge detection
        if (this.walls.length === 0) {
            this.log('No walls found with line detection, trying edge detection...', 'warn');
            this.walls = this.edgeDetection(imageData);
        }
        
        // Clean up and merge walls
        this.walls = this.cleanupWalls(this.walls);
        
        // Update stats
        document.getElementById('hLines').textContent = hLines;
        document.getElementById('vLines').textContent = vLines;
        document.getElementById('extracted').textContent = this.walls.length;
        document.getElementById('wallCount').textContent = this.walls.length;
        
        this.log(`Extracted ${this.walls.length} walls (${hLines} horizontal, ${vLines} vertical)`, 
                 this.walls.length > 0 ? 'success' : 'warn');
        
        // Visualize extraction
        this.visualizeExtraction(imageData, threshold);
        
        // Render BIM
        this.renderBIM();
    },
    
    cleanupWalls(walls) {
        if (walls.length === 0) return walls;
        
        this.log(`Cleaning up ${walls.length} walls...`, 'info');
        
        // First, remove very short segments
        let filtered = walls.filter(wall => {
            const length = Math.hypot(wall.x2 - wall.x1, wall.y2 - wall.y1);
            return length > 15; // Minimum 15 pixels
        });
        
        this.log(`After filtering short segments: ${filtered.length} walls`, 'info');
        
        // Separate horizontal and vertical walls
        const horizontal = [];
        const vertical = [];
        
        for (let wall of filtered) {
            const dx = Math.abs(wall.x2 - wall.x1);
            const dy = Math.abs(wall.y2 - wall.y1);
            
            if (dx > dy) {
                // Horizontal wall - make it perfectly horizontal
                wall.y2 = wall.y1;
                horizontal.push(wall);
            } else {
                // Vertical wall - make it perfectly vertical
                wall.x2 = wall.x1;
                vertical.push(wall);
            }
        }
        
        // Merge nearby parallel walls with stricter criteria
        const merged = [];
        const mergeThreshold = 8; // Reduced from 15 to be less aggressive
        
        // Merge horizontal walls
        const usedH = new Set();
        for (let i = 0; i < horizontal.length; i++) {
            if (usedH.has(i)) continue;
            
            const wall1 = horizontal[i];
            let minX = Math.min(wall1.x1, wall1.x2);
            let maxX = Math.max(wall1.x1, wall1.x2);
            let y = wall1.y1;
            
            // Find all walls on similar Y coordinate
            for (let j = i + 1; j < horizontal.length; j++) {
                if (usedH.has(j)) continue;
                
                const wall2 = horizontal[j];
                if (Math.abs(wall2.y1 - y) < mergeThreshold) {
                    // Check if walls overlap or are close
                    const min2 = Math.min(wall2.x1, wall2.x2);
                    const max2 = Math.max(wall2.x1, wall2.x2);
                    
                    // If walls are close or overlapping, merge them
                    if (max2 >= minX - mergeThreshold && min2 <= maxX + mergeThreshold) {
                        minX = Math.min(minX, min2);
                        maxX = Math.max(maxX, max2);
                        usedH.add(j);
                    }
                }
            }
            
            merged.push({
                id: `mh${merged.length}`,
                x1: minX, y1: y,
                x2: maxX, y2: y
            });
            usedH.add(i);
        }
        
        // Merge vertical walls
        const usedV = new Set();
        for (let i = 0; i < vertical.length; i++) {
            if (usedV.has(i)) continue;
            
            const wall1 = vertical[i];
            let minY = Math.min(wall1.y1, wall1.y2);
            let maxY = Math.max(wall1.y1, wall1.y2);
            let x = wall1.x1;
            
            // Find all walls on similar X coordinate
            for (let j = i + 1; j < vertical.length; j++) {
                if (usedV.has(j)) continue;
                
                const wall2 = vertical[j];
                if (Math.abs(wall2.x1 - x) < mergeThreshold) {
                    // Check if walls overlap or are close
                    const min2 = Math.min(wall2.y1, wall2.y2);
                    const max2 = Math.max(wall2.y1, wall2.y2);
                    
                    // If walls are close or overlapping, merge them
                    if (max2 >= minY - mergeThreshold && min2 <= maxY + mergeThreshold) {
                        minY = Math.min(minY, min2);
                        maxY = Math.max(maxY, max2);
                        usedV.add(j);
                    }
                }
            }
            
            merged.push({
                id: `mv${merged.length}`,
                x1: x, y1: minY,
                x2: x, y2: maxY
            });
            usedV.add(i);
        }
        
        this.log(`Merged to ${merged.length} walls`, 'success');
        return merged;
    },
    
    edgeDetection(imageData) {
        const width = this.pdfData.width;
        const height = this.pdfData.height;
        const data = imageData.data;
        const walls = [];
        const scale = 400 / Math.max(width, height);
        
        // Sobel edge detection for vertical and horizontal edges
        for (let y = 1; y < height - 1; y += 10) {
            for (let x = 1; x < width - 1; x += 10) {
                // Get 3x3 kernel values
                const idx = (y * width + x) * 4;
                const tl = data[((y-1) * width + (x-1)) * 4];
                const tm = data[((y-1) * width + x) * 4];
                const tr = data[((y-1) * width + (x+1)) * 4];
                const ml = data[(y * width + (x-1)) * 4];
                const mm = data[idx];
                const mr = data[(y * width + (x+1)) * 4];
                const bl = data[((y+1) * width + (x-1)) * 4];
                const bm = data[((y+1) * width + x) * 4];
                const br = data[((y+1) * width + (x+1)) * 4];
                
                // Sobel X (vertical edges)
                const gx = -tl - 2*ml - bl + tr + 2*mr + br;
                // Sobel Y (horizontal edges)
                const gy = -tl - 2*tm - tr + bl + 2*bm + br;
                
                const magnitude = Math.sqrt(gx * gx + gy * gy);
                
                if (magnitude > 100) {
                    // Strong edge detected - create a small wall segment
                    const wx = (x - width/2) * scale;
                    const wy = (y - height/2) * scale;
                    
                    if (Math.abs(gx) > Math.abs(gy)) {
                        // Vertical edge
                        walls.push({
                            id: `e${walls.length}`,
                            x1: wx, y1: wy - 10,
                            x2: wx, y2: wy + 10
                        });
                    } else {
                        // Horizontal edge
                        walls.push({
                            id: `e${walls.length}`,
                            x1: wx - 10, y1: wy,
                            x2: wx + 10, y2: wy
                        });
                    }
                }
            }
        }
        
        this.log(`Edge detection found ${walls.length} edge segments`, walls.length > 0 ? 'success' : 'warn');
        return walls;
    },
    
    visualizeExtraction(imageData, threshold) {
        // Create binary image
        const canvas = this.extractCanvas;
        const ctx = this.extractCtx;
        
        canvas.width = 600;
        canvas.height = 400;
        
        const scale = Math.min(600 / this.pdfData.width, 400 / this.pdfData.height);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, 600, 400);
        
        // Draw threshold visualization
        const outputData = ctx.createImageData(
            Math.floor(this.pdfData.width * scale),
            Math.floor(this.pdfData.height * scale)
        );
        
        for (let y = 0; y < outputData.height; y++) {
            for (let x = 0; x < outputData.width; x++) {
                const srcX = Math.floor(x / scale);
                const srcY = Math.floor(y / scale);
                const srcIdx = (srcY * this.pdfData.width + srcX) * 4;
                const dstIdx = (y * outputData.width + x) * 4;
                
                const brightness = (imageData.data[srcIdx] + 
                                  imageData.data[srcIdx+1] + 
                                  imageData.data[srcIdx+2]) / 3;
                
                const value = brightness < threshold ? 255 : 0;
                outputData.data[dstIdx] = value;
                outputData.data[dstIdx+1] = value;
                outputData.data[dstIdx+2] = value;
                outputData.data[dstIdx+3] = 255;
            }
        }
        
        ctx.putImageData(outputData, 0, 0);
        
        // Overlay extracted walls
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 2;
        
        const drawScale = 400 / Math.max(this.pdfData.width, this.pdfData.height);
        
        ctx.save();
        ctx.translate(300, 200);
        
        for (let wall of this.walls) {
            ctx.beginPath();
            ctx.moveTo(wall.x1, wall.y1);
            ctx.lineTo(wall.x2, wall.y2);
            ctx.stroke();
        }
        
        ctx.restore();
    },
    
    renderBIM() {
        const ctx = this.bimCtx;
        const canvas = this.bimCanvas;
        
        // Clear
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Save state
        ctx.save();
        
        // Apply transforms
        ctx.translate(canvas.width/2 + this.pan.x, canvas.height/2 + this.pan.y);
        ctx.scale(this.zoom, this.zoom);
        
        // Draw grid
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 0.5;
        
        for (let i = -10; i <= 10; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 50, -500);
            ctx.lineTo(i * 50, 500);
            ctx.moveTo(-500, i * 50);
            ctx.lineTo(500, i * 50);
            ctx.stroke();
        }
        
        // Draw origin
        ctx.strokeStyle = '#f44';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-20, 0);
        ctx.lineTo(20, 0);
        ctx.moveTo(0, -20);
        ctx.lineTo(0, 20);
        ctx.stroke();
        
        // Draw walls
        ctx.strokeStyle = '#4a9eff';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        
        for (let wall of this.walls) {
            ctx.beginPath();
            ctx.moveTo(wall.x1, wall.y1);
            ctx.lineTo(wall.x2, wall.y2);
            ctx.stroke();
        }
        
        // Draw wall endpoints
        ctx.fillStyle = '#4a9eff';
        for (let wall of this.walls) {
            ctx.beginPath();
            ctx.arc(wall.x1, wall.y1, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(wall.x2, wall.y2, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
        
        // Update stats
        document.getElementById('viewZoom').textContent = this.zoom.toFixed(2);
        document.getElementById('viewPanX').textContent = Math.round(this.pan.x);
        document.getElementById('viewPanY').textContent = Math.round(this.pan.y);
    },
    
    mouseDown(e) {
        this.dragStart = {
            x: e.clientX,
            y: e.clientY,
            panX: this.pan.x,
            panY: this.pan.y
        };
    },
    
    mouseMove(e) {
        if (this.dragStart) {
            this.pan.x = this.dragStart.panX + (e.clientX - this.dragStart.x);
            this.pan.y = this.dragStart.panY + (e.clientY - this.dragStart.y);
            this.renderBIM();
        }
    },
    
    mouseUp(e) {
        this.dragStart = null;
    },
    
    wheel(e) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        this.zoom = Math.max(0.1, Math.min(5, this.zoom * delta));
        this.renderBIM();
    },
    
    clearAll() {
        this.walls = [];
        this.pdfData = null;
        this.zoom = 1.0;
        this.pan = { x: 0, y: 0 };
        
        // Clear canvases
        this.pdfCtx.clearRect(0, 0, this.pdfCanvas.width, this.pdfCanvas.height);
        this.extractCtx.clearRect(0, 0, this.extractCanvas.width, this.extractCanvas.height);
        
        // Reset stats
        document.querySelectorAll('.stat-value').forEach(el => {
            if (el.id !== 'viewZoom') el.textContent = '0';
        });
        document.getElementById('viewZoom').textContent = '1.0';
        
        this.renderBIM();
        this.log('Cleared all data', 'info');
    }
};

// Utility functions
function testDirectDraw() {
    Diagnostic.testDirectDraw();
}

function testExtraction() {
    Diagnostic.testExtraction();
}

function forceEdgeDetection() {
    if (!Diagnostic.pdfData) {
        Diagnostic.log('No PDF loaded', 'error');
        return;
    }
    
    Diagnostic.log('Forcing edge detection...', 'info');
    const imageData = Diagnostic.pdfData.ctx.getImageData(
        0, 0, Diagnostic.pdfData.width, Diagnostic.pdfData.height
    );
    Diagnostic.walls = Diagnostic.edgeDetection(imageData);
    document.getElementById('wallCount').textContent = Diagnostic.walls.length;
    Diagnostic.renderBIM();
}

function addDemoWalls() {
    Diagnostic.log('Adding demo walls from PDF bounds...', 'info');
    
    if (Diagnostic.pdfData) {
        const scale = 400 / Math.max(Diagnostic.pdfData.width, Diagnostic.pdfData.height);
        const w = Diagnostic.pdfData.width * scale / 2;
        const h = Diagnostic.pdfData.height * scale / 2;
        
        Diagnostic.walls = [
            { id: 'demo1', x1: -w, y1: -h, x2: w, y2: -h },
            { id: 'demo2', x1: w, y1: -h, x2: w, y2: h },
            { id: 'demo3', x1: w, y1: h, x2: -w, y2: h },
            { id: 'demo4', x1: -w, y1: h, x2: -w, y2: -h },
            { id: 'demo5', x1: 0, y1: -h, x2: 0, y2: h },
            { id: 'demo6', x1: -w, y1: 0, x2: w, y2: 0 }
        ];
    } else {
        Diagnostic.walls = [
            { id: 'demo1', x1: -200, y1: -150, x2: 200, y2: -150 },
            { id: 'demo2', x1: 200, y1: -150, x2: 200, y2: 150 },
            { id: 'demo3', x1: 200, y1: 150, x2: -200, y2: 150 },
            { id: 'demo4', x1: -200, y1: 150, x2: -200, y2: -150 },
            { id: 'demo5', x1: 0, y1: -150, x2: 0, y2: 150 },
            { id: 'demo6', x1: -200, y1: 0, x2: 200, y2: 0 }
        ];
    }
    
    document.getElementById('wallCount').textContent = Diagnostic.walls.length;
    Diagnostic.log(`Added ${Diagnostic.walls.length} demo walls`, 'success');
    Diagnostic.renderBIM();
}

function clearAll() {
    Diagnostic.clearAll();
}

function zoomIn() {
    Diagnostic.zoom *= 1.2;
    Diagnostic.renderBIM();
}

function zoomOut() {
    Diagnostic.zoom *= 0.8;
    Diagnostic.renderBIM();
}

function resetView() {
    Diagnostic.zoom = 1.0;
    Diagnostic.pan = { x: 0, y: 0 };
    Diagnostic.renderBIM();
}

// Initialize
window.onload = () => {
    Diagnostic.init();
};
</script>

</body>
</html>